/* tslint:disable */
/* eslint-disable */
/**
 *
 *
 *
 *
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import {
  V1NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressions,
  V1NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressionsFromJSON,
  V1NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressionsFromJSONTyped,
  V1NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressionsToJSON,
} from './';

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 * @export
 * @interface V1NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelector
 */
export interface V1NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   * @type {Array<V1NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressions>}
   * @memberof V1NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelector
   */
  matchExpressions?: Array<V1NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressions>;
  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   * @type {{ [key: string]: string; }}
   * @memberof V1NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelector
   */
  matchLabels?: { [key: string]: string };
}

export function V1NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelectorFromJSON(
  json: any,
): V1NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelector {
  return V1NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelectorFromJSONTyped(json, false);
}

export function V1NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelectorFromJSONTyped(
  json: any,
  _ignoreDiscriminator: boolean,
): V1NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelector {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    matchExpressions: !exists(json, 'matchExpressions')
      ? undefined
      : (json['matchExpressions'] as Array<any>).map(
          V1NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressionsFromJSON,
        ),
    matchLabels: !exists(json, 'matchLabels') ? undefined : json['matchLabels'],
  };
}

export function V1NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelectorToJSON(
  value?: V1NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelector | null,
): any {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    matchExpressions:
      value.matchExpressions === undefined
        ? undefined
        : (value.matchExpressions as Array<any>).map(
            V1NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressionsToJSON,
          ),
    matchLabels: value.matchLabels,
  };
}
