/* tslint:disable */
/* eslint-disable */
/**
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: unversioned
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    IoK8sApiAuthenticationV1TokenRequest,
    IoK8sApiAuthenticationV1TokenRequestFromJSON,
    IoK8sApiAuthenticationV1TokenRequestToJSON,
    IoK8sApiAutoscalingV1Scale,
    IoK8sApiAutoscalingV1ScaleFromJSON,
    IoK8sApiAutoscalingV1ScaleToJSON,
    IoK8sApiCoreV1Binding,
    IoK8sApiCoreV1BindingFromJSON,
    IoK8sApiCoreV1BindingToJSON,
    IoK8sApiCoreV1ComponentStatus,
    IoK8sApiCoreV1ComponentStatusFromJSON,
    IoK8sApiCoreV1ComponentStatusToJSON,
    IoK8sApiCoreV1ComponentStatusList,
    IoK8sApiCoreV1ComponentStatusListFromJSON,
    IoK8sApiCoreV1ComponentStatusListToJSON,
    IoK8sApiCoreV1ConfigMap,
    IoK8sApiCoreV1ConfigMapFromJSON,
    IoK8sApiCoreV1ConfigMapToJSON,
    IoK8sApiCoreV1ConfigMapList,
    IoK8sApiCoreV1ConfigMapListFromJSON,
    IoK8sApiCoreV1ConfigMapListToJSON,
    IoK8sApiCoreV1Endpoints,
    IoK8sApiCoreV1EndpointsFromJSON,
    IoK8sApiCoreV1EndpointsToJSON,
    IoK8sApiCoreV1EndpointsList,
    IoK8sApiCoreV1EndpointsListFromJSON,
    IoK8sApiCoreV1EndpointsListToJSON,
    IoK8sApiCoreV1Event,
    IoK8sApiCoreV1EventFromJSON,
    IoK8sApiCoreV1EventToJSON,
    IoK8sApiCoreV1EventList,
    IoK8sApiCoreV1EventListFromJSON,
    IoK8sApiCoreV1EventListToJSON,
    IoK8sApiCoreV1LimitRange,
    IoK8sApiCoreV1LimitRangeFromJSON,
    IoK8sApiCoreV1LimitRangeToJSON,
    IoK8sApiCoreV1LimitRangeList,
    IoK8sApiCoreV1LimitRangeListFromJSON,
    IoK8sApiCoreV1LimitRangeListToJSON,
    IoK8sApiCoreV1Namespace,
    IoK8sApiCoreV1NamespaceFromJSON,
    IoK8sApiCoreV1NamespaceToJSON,
    IoK8sApiCoreV1NamespaceList,
    IoK8sApiCoreV1NamespaceListFromJSON,
    IoK8sApiCoreV1NamespaceListToJSON,
    IoK8sApiCoreV1Node,
    IoK8sApiCoreV1NodeFromJSON,
    IoK8sApiCoreV1NodeToJSON,
    IoK8sApiCoreV1NodeList,
    IoK8sApiCoreV1NodeListFromJSON,
    IoK8sApiCoreV1NodeListToJSON,
    IoK8sApiCoreV1PersistentVolume,
    IoK8sApiCoreV1PersistentVolumeFromJSON,
    IoK8sApiCoreV1PersistentVolumeToJSON,
    IoK8sApiCoreV1PersistentVolumeClaim,
    IoK8sApiCoreV1PersistentVolumeClaimFromJSON,
    IoK8sApiCoreV1PersistentVolumeClaimToJSON,
    IoK8sApiCoreV1PersistentVolumeClaimList,
    IoK8sApiCoreV1PersistentVolumeClaimListFromJSON,
    IoK8sApiCoreV1PersistentVolumeClaimListToJSON,
    IoK8sApiCoreV1PersistentVolumeList,
    IoK8sApiCoreV1PersistentVolumeListFromJSON,
    IoK8sApiCoreV1PersistentVolumeListToJSON,
    IoK8sApiCoreV1Pod,
    IoK8sApiCoreV1PodFromJSON,
    IoK8sApiCoreV1PodToJSON,
    IoK8sApiCoreV1PodList,
    IoK8sApiCoreV1PodListFromJSON,
    IoK8sApiCoreV1PodListToJSON,
    IoK8sApiCoreV1PodTemplate,
    IoK8sApiCoreV1PodTemplateFromJSON,
    IoK8sApiCoreV1PodTemplateToJSON,
    IoK8sApiCoreV1PodTemplateList,
    IoK8sApiCoreV1PodTemplateListFromJSON,
    IoK8sApiCoreV1PodTemplateListToJSON,
    IoK8sApiCoreV1ReplicationController,
    IoK8sApiCoreV1ReplicationControllerFromJSON,
    IoK8sApiCoreV1ReplicationControllerToJSON,
    IoK8sApiCoreV1ReplicationControllerList,
    IoK8sApiCoreV1ReplicationControllerListFromJSON,
    IoK8sApiCoreV1ReplicationControllerListToJSON,
    IoK8sApiCoreV1ResourceQuota,
    IoK8sApiCoreV1ResourceQuotaFromJSON,
    IoK8sApiCoreV1ResourceQuotaToJSON,
    IoK8sApiCoreV1ResourceQuotaList,
    IoK8sApiCoreV1ResourceQuotaListFromJSON,
    IoK8sApiCoreV1ResourceQuotaListToJSON,
    IoK8sApiCoreV1Secret,
    IoK8sApiCoreV1SecretFromJSON,
    IoK8sApiCoreV1SecretToJSON,
    IoK8sApiCoreV1SecretList,
    IoK8sApiCoreV1SecretListFromJSON,
    IoK8sApiCoreV1SecretListToJSON,
    IoK8sApiCoreV1Service,
    IoK8sApiCoreV1ServiceFromJSON,
    IoK8sApiCoreV1ServiceToJSON,
    IoK8sApiCoreV1ServiceAccount,
    IoK8sApiCoreV1ServiceAccountFromJSON,
    IoK8sApiCoreV1ServiceAccountToJSON,
    IoK8sApiCoreV1ServiceAccountList,
    IoK8sApiCoreV1ServiceAccountListFromJSON,
    IoK8sApiCoreV1ServiceAccountListToJSON,
    IoK8sApiCoreV1ServiceList,
    IoK8sApiCoreV1ServiceListFromJSON,
    IoK8sApiCoreV1ServiceListToJSON,
    IoK8sApiPolicyV1Eviction,
    IoK8sApiPolicyV1EvictionFromJSON,
    IoK8sApiPolicyV1EvictionToJSON,
    IoK8sApimachineryPkgApisMetaV1APIResourceList,
    IoK8sApimachineryPkgApisMetaV1APIResourceListFromJSON,
    IoK8sApimachineryPkgApisMetaV1APIResourceListToJSON,
    IoK8sApimachineryPkgApisMetaV1DeleteOptions,
    IoK8sApimachineryPkgApisMetaV1DeleteOptionsFromJSON,
    IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON,
    IoK8sApimachineryPkgApisMetaV1Status,
    IoK8sApimachineryPkgApisMetaV1StatusFromJSON,
    IoK8sApimachineryPkgApisMetaV1StatusToJSON,
    IoK8sApimachineryPkgApisMetaV1WatchEvent,
    IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON,
    IoK8sApimachineryPkgApisMetaV1WatchEventToJSON,
} from '../models';

export interface ConnectCoreV1DeleteNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1DeleteNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1DeleteNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1DeleteNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1DeleteNodeProxyWithPathRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1GetNamespacedPodAttachRequest {
    name: string;
    namespace: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface ConnectCoreV1GetNamespacedPodExecRequest {
    name: string;
    namespace: string;
    command?: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface ConnectCoreV1GetNamespacedPodPortforwardRequest {
    name: string;
    namespace: string;
    ports?: number;
}

export interface ConnectCoreV1GetNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1GetNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1GetNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1GetNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1GetNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1GetNodeProxyWithPathRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1HeadNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1HeadNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1HeadNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1HeadNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1HeadNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1HeadNodeProxyWithPathRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1OptionsNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1OptionsNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1OptionsNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1OptionsNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1OptionsNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1OptionsNodeProxyWithPathRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1PatchNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PatchNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PatchNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PatchNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PatchNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1PatchNodeProxyWithPathRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1PostNamespacedPodAttachRequest {
    name: string;
    namespace: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface ConnectCoreV1PostNamespacedPodExecRequest {
    name: string;
    namespace: string;
    command?: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface ConnectCoreV1PostNamespacedPodPortforwardRequest {
    name: string;
    namespace: string;
    ports?: number;
}

export interface ConnectCoreV1PostNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PostNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PostNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PostNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PostNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1PostNodeProxyWithPathRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1PutNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PutNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PutNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PutNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PutNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1PutNodeProxyWithPathRequest {
    name: string;
    path?: string;
}

export interface CreateCoreV1NamespaceRequest {
    body: IoK8sApiCoreV1Namespace;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CreateCoreV1NamespacedBindingRequest {
    namespace: string;
    body: IoK8sApiCoreV1Binding;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
}

export interface CreateCoreV1NamespacedConfigMapRequest {
    namespace: string;
    body: IoK8sApiCoreV1ConfigMap;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CreateCoreV1NamespacedEndpointsRequest {
    namespace: string;
    body: IoK8sApiCoreV1Endpoints;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CreateCoreV1NamespacedEventRequest {
    namespace: string;
    body: IoK8sApiCoreV1Event;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CreateCoreV1NamespacedLimitRangeRequest {
    namespace: string;
    body: IoK8sApiCoreV1LimitRange;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CreateCoreV1NamespacedPersistentVolumeClaimRequest {
    namespace: string;
    body: IoK8sApiCoreV1PersistentVolumeClaim;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CreateCoreV1NamespacedPodRequest {
    namespace: string;
    body: IoK8sApiCoreV1Pod;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CreateCoreV1NamespacedPodBindingRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Binding;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
}

export interface CreateCoreV1NamespacedPodEvictionRequest {
    name: string;
    namespace: string;
    body: IoK8sApiPolicyV1Eviction;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
}

export interface CreateCoreV1NamespacedPodTemplateRequest {
    namespace: string;
    body: IoK8sApiCoreV1PodTemplate;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CreateCoreV1NamespacedReplicationControllerRequest {
    namespace: string;
    body: IoK8sApiCoreV1ReplicationController;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CreateCoreV1NamespacedResourceQuotaRequest {
    namespace: string;
    body: IoK8sApiCoreV1ResourceQuota;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CreateCoreV1NamespacedSecretRequest {
    namespace: string;
    body: IoK8sApiCoreV1Secret;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CreateCoreV1NamespacedServiceRequest {
    namespace: string;
    body: IoK8sApiCoreV1Service;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CreateCoreV1NamespacedServiceAccountRequest {
    namespace: string;
    body: IoK8sApiCoreV1ServiceAccount;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CreateCoreV1NamespacedServiceAccountTokenRequest {
    name: string;
    namespace: string;
    body: IoK8sApiAuthenticationV1TokenRequest;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
}

export interface CreateCoreV1NodeRequest {
    body: IoK8sApiCoreV1Node;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CreateCoreV1PersistentVolumeRequest {
    body: IoK8sApiCoreV1PersistentVolume;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface DeleteCoreV1CollectionNamespacedConfigMapRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedEndpointsRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedEventRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedLimitRangeRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedPersistentVolumeClaimRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedPodRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedPodTemplateRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedReplicationControllerRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedResourceQuotaRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedSecretRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedServiceRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedServiceAccountRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNodeRequest {
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionPersistentVolumeRequest {
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespaceRequest {
    name: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedConfigMapRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedEndpointsRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedEventRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedPodRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedSecretRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedServiceRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NodeRequest {
    name: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1PersistentVolumeRequest {
    name: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface ListCoreV1ComponentStatusRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1ConfigMapForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1EndpointsForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1EventForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1LimitRangeForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespaceRequest {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedConfigMapRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedEndpointsRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedEventRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedLimitRangeRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedPersistentVolumeClaimRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedPodRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedPodTemplateRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedReplicationControllerRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedResourceQuotaRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedSecretRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedServiceRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedServiceAccountRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NodeRequest {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1PersistentVolumeRequest {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1PersistentVolumeClaimForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1PodForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1PodTemplateForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1ReplicationControllerForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1ResourceQuotaForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1SecretForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1ServiceAccountForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1ServiceForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface PatchCoreV1NamespaceRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespaceStatusRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedConfigMapRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedEndpointsRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedEventRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedPersistentVolumeClaimStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedPodRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedPodEphemeralcontainersRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedPodStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedReplicationControllerScaleRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedReplicationControllerStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedResourceQuotaStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedSecretRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedServiceRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedServiceStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NodeRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1NodeStatusRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1PersistentVolumeRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface PatchCoreV1PersistentVolumeStatusRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface ReadCoreV1ComponentStatusRequest {
    name: string;
    pretty?: string;
}

export interface ReadCoreV1NamespaceRequest {
    name: string;
    pretty?: string;
}

export interface ReadCoreV1NamespaceStatusRequest {
    name: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedConfigMapRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedEndpointsRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedEventRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedPersistentVolumeClaimStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedPodRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedPodEphemeralcontainersRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedPodLogRequest {
    name: string;
    namespace: string;
    container?: string;
    follow?: boolean;
    insecureSkipTLSVerifyBackend?: boolean;
    limitBytes?: number;
    pretty?: string;
    previous?: boolean;
    sinceSeconds?: number;
    tailLines?: number;
    timestamps?: boolean;
}

export interface ReadCoreV1NamespacedPodStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedReplicationControllerScaleRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedReplicationControllerStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedResourceQuotaStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedSecretRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedServiceRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedServiceStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NodeRequest {
    name: string;
    pretty?: string;
}

export interface ReadCoreV1NodeStatusRequest {
    name: string;
    pretty?: string;
}

export interface ReadCoreV1PersistentVolumeRequest {
    name: string;
    pretty?: string;
}

export interface ReadCoreV1PersistentVolumeStatusRequest {
    name: string;
    pretty?: string;
}

export interface ReplaceCoreV1NamespaceRequest {
    name: string;
    body: IoK8sApiCoreV1Namespace;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespaceFinalizeRequest {
    name: string;
    body: IoK8sApiCoreV1Namespace;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
}

export interface ReplaceCoreV1NamespaceStatusRequest {
    name: string;
    body: IoK8sApiCoreV1Namespace;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedConfigMapRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1ConfigMap;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedEndpointsRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Endpoints;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedEventRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Event;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1LimitRange;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1PersistentVolumeClaim;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedPersistentVolumeClaimStatusRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1PersistentVolumeClaim;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedPodRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Pod;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedPodEphemeralcontainersRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Pod;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedPodStatusRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Pod;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1PodTemplate;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1ReplicationController;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedReplicationControllerScaleRequest {
    name: string;
    namespace: string;
    body: IoK8sApiAutoscalingV1Scale;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedReplicationControllerStatusRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1ReplicationController;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1ResourceQuota;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedResourceQuotaStatusRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1ResourceQuota;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedSecretRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Secret;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedServiceRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Service;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1ServiceAccount;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NamespacedServiceStatusRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Service;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NodeRequest {
    name: string;
    body: IoK8sApiCoreV1Node;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1NodeStatusRequest {
    name: string;
    body: IoK8sApiCoreV1Node;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1PersistentVolumeRequest {
    name: string;
    body: IoK8sApiCoreV1PersistentVolume;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface ReplaceCoreV1PersistentVolumeStatusRequest {
    name: string;
    body: IoK8sApiCoreV1PersistentVolume;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface WatchCoreV1ConfigMapListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1EndpointsListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1EventListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1LimitRangeListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespaceRequest {
    name: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespaceListRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedConfigMapRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedConfigMapListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedEndpointsRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedEndpointsListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedEventRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedEventListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedLimitRangeListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedPersistentVolumeClaimListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedPodRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedPodListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedPodTemplateListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedReplicationControllerListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedResourceQuotaListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedSecretRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedSecretListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedServiceRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedServiceAccountListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedServiceListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NodeRequest {
    name: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NodeListRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1PersistentVolumeRequest {
    name: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1PersistentVolumeListRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1PodListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1PodTemplateListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1ReplicationControllerListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1ResourceQuotaListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1SecretListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1ServiceAccountListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1ServiceListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

/**
 * 
 */
export class CoreV1Api extends runtime.BaseAPI {

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectCoreV1DeleteNamespacedPodProxyRaw(requestParameters: ConnectCoreV1DeleteNamespacedPodProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1DeleteNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1DeleteNamespacedPodProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectCoreV1DeleteNamespacedPodProxy(requestParameters: ConnectCoreV1DeleteNamespacedPodProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1DeleteNamespacedPodProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectCoreV1DeleteNamespacedPodProxyWithPathRaw(requestParameters: ConnectCoreV1DeleteNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1DeleteNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1DeleteNamespacedPodProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectCoreV1DeleteNamespacedPodProxyWithPath(requestParameters: ConnectCoreV1DeleteNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1DeleteNamespacedPodProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectCoreV1DeleteNamespacedServiceProxyRaw(requestParameters: ConnectCoreV1DeleteNamespacedServiceProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1DeleteNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1DeleteNamespacedServiceProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectCoreV1DeleteNamespacedServiceProxy(requestParameters: ConnectCoreV1DeleteNamespacedServiceProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1DeleteNamespacedServiceProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectCoreV1DeleteNamespacedServiceProxyWithPathRaw(requestParameters: ConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1DeleteNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1DeleteNamespacedServiceProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectCoreV1DeleteNamespacedServiceProxyWithPath(requestParameters: ConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1DeleteNamespacedServiceProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectCoreV1DeleteNodeProxyRaw(requestParameters: ConnectCoreV1DeleteNodeProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1DeleteNodeProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectCoreV1DeleteNodeProxy(requestParameters: ConnectCoreV1DeleteNodeProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1DeleteNodeProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectCoreV1DeleteNodeProxyWithPathRaw(requestParameters: ConnectCoreV1DeleteNodeProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1DeleteNodeProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectCoreV1DeleteNodeProxyWithPath(requestParameters: ConnectCoreV1DeleteNodeProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1DeleteNodeProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to attach of Pod
     */
    async connectCoreV1GetNamespacedPodAttachRaw(requestParameters: ConnectCoreV1GetNamespacedPodAttachRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNamespacedPodAttach.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1GetNamespacedPodAttach.');
        }

        const queryParameters: any = {};

        if (requestParameters.container !== undefined) {
            queryParameters['container'] = requestParameters.container;
        }

        if (requestParameters.stderr !== undefined) {
            queryParameters['stderr'] = requestParameters.stderr;
        }

        if (requestParameters.stdin !== undefined) {
            queryParameters['stdin'] = requestParameters.stdin;
        }

        if (requestParameters.stdout !== undefined) {
            queryParameters['stdout'] = requestParameters.stdout;
        }

        if (requestParameters.tty !== undefined) {
            queryParameters['tty'] = requestParameters.tty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/attach`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to attach of Pod
     */
    async connectCoreV1GetNamespacedPodAttach(requestParameters: ConnectCoreV1GetNamespacedPodAttachRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1GetNamespacedPodAttachRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to exec of Pod
     */
    async connectCoreV1GetNamespacedPodExecRaw(requestParameters: ConnectCoreV1GetNamespacedPodExecRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNamespacedPodExec.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1GetNamespacedPodExec.');
        }

        const queryParameters: any = {};

        if (requestParameters.command !== undefined) {
            queryParameters['command'] = requestParameters.command;
        }

        if (requestParameters.container !== undefined) {
            queryParameters['container'] = requestParameters.container;
        }

        if (requestParameters.stderr !== undefined) {
            queryParameters['stderr'] = requestParameters.stderr;
        }

        if (requestParameters.stdin !== undefined) {
            queryParameters['stdin'] = requestParameters.stdin;
        }

        if (requestParameters.stdout !== undefined) {
            queryParameters['stdout'] = requestParameters.stdout;
        }

        if (requestParameters.tty !== undefined) {
            queryParameters['tty'] = requestParameters.tty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/exec`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to exec of Pod
     */
    async connectCoreV1GetNamespacedPodExec(requestParameters: ConnectCoreV1GetNamespacedPodExecRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1GetNamespacedPodExecRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to portforward of Pod
     */
    async connectCoreV1GetNamespacedPodPortforwardRaw(requestParameters: ConnectCoreV1GetNamespacedPodPortforwardRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNamespacedPodPortforward.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1GetNamespacedPodPortforward.');
        }

        const queryParameters: any = {};

        if (requestParameters.ports !== undefined) {
            queryParameters['ports'] = requestParameters.ports;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/portforward`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to portforward of Pod
     */
    async connectCoreV1GetNamespacedPodPortforward(requestParameters: ConnectCoreV1GetNamespacedPodPortforwardRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1GetNamespacedPodPortforwardRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectCoreV1GetNamespacedPodProxyRaw(requestParameters: ConnectCoreV1GetNamespacedPodProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1GetNamespacedPodProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectCoreV1GetNamespacedPodProxy(requestParameters: ConnectCoreV1GetNamespacedPodProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1GetNamespacedPodProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectCoreV1GetNamespacedPodProxyWithPathRaw(requestParameters: ConnectCoreV1GetNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1GetNamespacedPodProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectCoreV1GetNamespacedPodProxyWithPath(requestParameters: ConnectCoreV1GetNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1GetNamespacedPodProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectCoreV1GetNamespacedServiceProxyRaw(requestParameters: ConnectCoreV1GetNamespacedServiceProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1GetNamespacedServiceProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectCoreV1GetNamespacedServiceProxy(requestParameters: ConnectCoreV1GetNamespacedServiceProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1GetNamespacedServiceProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectCoreV1GetNamespacedServiceProxyWithPathRaw(requestParameters: ConnectCoreV1GetNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1GetNamespacedServiceProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectCoreV1GetNamespacedServiceProxyWithPath(requestParameters: ConnectCoreV1GetNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1GetNamespacedServiceProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectCoreV1GetNodeProxyRaw(requestParameters: ConnectCoreV1GetNodeProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNodeProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectCoreV1GetNodeProxy(requestParameters: ConnectCoreV1GetNodeProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1GetNodeProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectCoreV1GetNodeProxyWithPathRaw(requestParameters: ConnectCoreV1GetNodeProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNodeProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectCoreV1GetNodeProxyWithPath(requestParameters: ConnectCoreV1GetNodeProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1GetNodeProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectCoreV1HeadNamespacedPodProxyRaw(requestParameters: ConnectCoreV1HeadNamespacedPodProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1HeadNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1HeadNamespacedPodProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectCoreV1HeadNamespacedPodProxy(requestParameters: ConnectCoreV1HeadNamespacedPodProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1HeadNamespacedPodProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectCoreV1HeadNamespacedPodProxyWithPathRaw(requestParameters: ConnectCoreV1HeadNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1HeadNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1HeadNamespacedPodProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectCoreV1HeadNamespacedPodProxyWithPath(requestParameters: ConnectCoreV1HeadNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1HeadNamespacedPodProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectCoreV1HeadNamespacedServiceProxyRaw(requestParameters: ConnectCoreV1HeadNamespacedServiceProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1HeadNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1HeadNamespacedServiceProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectCoreV1HeadNamespacedServiceProxy(requestParameters: ConnectCoreV1HeadNamespacedServiceProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1HeadNamespacedServiceProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectCoreV1HeadNamespacedServiceProxyWithPathRaw(requestParameters: ConnectCoreV1HeadNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1HeadNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1HeadNamespacedServiceProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectCoreV1HeadNamespacedServiceProxyWithPath(requestParameters: ConnectCoreV1HeadNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1HeadNamespacedServiceProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectCoreV1HeadNodeProxyRaw(requestParameters: ConnectCoreV1HeadNodeProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1HeadNodeProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectCoreV1HeadNodeProxy(requestParameters: ConnectCoreV1HeadNodeProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1HeadNodeProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectCoreV1HeadNodeProxyWithPathRaw(requestParameters: ConnectCoreV1HeadNodeProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1HeadNodeProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectCoreV1HeadNodeProxyWithPath(requestParameters: ConnectCoreV1HeadNodeProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1HeadNodeProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectCoreV1OptionsNamespacedPodProxyRaw(requestParameters: ConnectCoreV1OptionsNamespacedPodProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1OptionsNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1OptionsNamespacedPodProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectCoreV1OptionsNamespacedPodProxy(requestParameters: ConnectCoreV1OptionsNamespacedPodProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1OptionsNamespacedPodProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectCoreV1OptionsNamespacedPodProxyWithPathRaw(requestParameters: ConnectCoreV1OptionsNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1OptionsNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1OptionsNamespacedPodProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectCoreV1OptionsNamespacedPodProxyWithPath(requestParameters: ConnectCoreV1OptionsNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1OptionsNamespacedPodProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectCoreV1OptionsNamespacedServiceProxyRaw(requestParameters: ConnectCoreV1OptionsNamespacedServiceProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1OptionsNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1OptionsNamespacedServiceProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectCoreV1OptionsNamespacedServiceProxy(requestParameters: ConnectCoreV1OptionsNamespacedServiceProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1OptionsNamespacedServiceProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectCoreV1OptionsNamespacedServiceProxyWithPathRaw(requestParameters: ConnectCoreV1OptionsNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1OptionsNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1OptionsNamespacedServiceProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectCoreV1OptionsNamespacedServiceProxyWithPath(requestParameters: ConnectCoreV1OptionsNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1OptionsNamespacedServiceProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectCoreV1OptionsNodeProxyRaw(requestParameters: ConnectCoreV1OptionsNodeProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1OptionsNodeProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectCoreV1OptionsNodeProxy(requestParameters: ConnectCoreV1OptionsNodeProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1OptionsNodeProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectCoreV1OptionsNodeProxyWithPathRaw(requestParameters: ConnectCoreV1OptionsNodeProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1OptionsNodeProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectCoreV1OptionsNodeProxyWithPath(requestParameters: ConnectCoreV1OptionsNodeProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1OptionsNodeProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectCoreV1PatchNamespacedPodProxyRaw(requestParameters: ConnectCoreV1PatchNamespacedPodProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PatchNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PatchNamespacedPodProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectCoreV1PatchNamespacedPodProxy(requestParameters: ConnectCoreV1PatchNamespacedPodProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PatchNamespacedPodProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectCoreV1PatchNamespacedPodProxyWithPathRaw(requestParameters: ConnectCoreV1PatchNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PatchNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PatchNamespacedPodProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectCoreV1PatchNamespacedPodProxyWithPath(requestParameters: ConnectCoreV1PatchNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PatchNamespacedPodProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectCoreV1PatchNamespacedServiceProxyRaw(requestParameters: ConnectCoreV1PatchNamespacedServiceProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PatchNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PatchNamespacedServiceProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectCoreV1PatchNamespacedServiceProxy(requestParameters: ConnectCoreV1PatchNamespacedServiceProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PatchNamespacedServiceProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectCoreV1PatchNamespacedServiceProxyWithPathRaw(requestParameters: ConnectCoreV1PatchNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PatchNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PatchNamespacedServiceProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectCoreV1PatchNamespacedServiceProxyWithPath(requestParameters: ConnectCoreV1PatchNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PatchNamespacedServiceProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectCoreV1PatchNodeProxyRaw(requestParameters: ConnectCoreV1PatchNodeProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PatchNodeProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectCoreV1PatchNodeProxy(requestParameters: ConnectCoreV1PatchNodeProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PatchNodeProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectCoreV1PatchNodeProxyWithPathRaw(requestParameters: ConnectCoreV1PatchNodeProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PatchNodeProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectCoreV1PatchNodeProxyWithPath(requestParameters: ConnectCoreV1PatchNodeProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PatchNodeProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to attach of Pod
     */
    async connectCoreV1PostNamespacedPodAttachRaw(requestParameters: ConnectCoreV1PostNamespacedPodAttachRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNamespacedPodAttach.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PostNamespacedPodAttach.');
        }

        const queryParameters: any = {};

        if (requestParameters.container !== undefined) {
            queryParameters['container'] = requestParameters.container;
        }

        if (requestParameters.stderr !== undefined) {
            queryParameters['stderr'] = requestParameters.stderr;
        }

        if (requestParameters.stdin !== undefined) {
            queryParameters['stdin'] = requestParameters.stdin;
        }

        if (requestParameters.stdout !== undefined) {
            queryParameters['stdout'] = requestParameters.stdout;
        }

        if (requestParameters.tty !== undefined) {
            queryParameters['tty'] = requestParameters.tty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/attach`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to attach of Pod
     */
    async connectCoreV1PostNamespacedPodAttach(requestParameters: ConnectCoreV1PostNamespacedPodAttachRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PostNamespacedPodAttachRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to exec of Pod
     */
    async connectCoreV1PostNamespacedPodExecRaw(requestParameters: ConnectCoreV1PostNamespacedPodExecRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNamespacedPodExec.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PostNamespacedPodExec.');
        }

        const queryParameters: any = {};

        if (requestParameters.command !== undefined) {
            queryParameters['command'] = requestParameters.command;
        }

        if (requestParameters.container !== undefined) {
            queryParameters['container'] = requestParameters.container;
        }

        if (requestParameters.stderr !== undefined) {
            queryParameters['stderr'] = requestParameters.stderr;
        }

        if (requestParameters.stdin !== undefined) {
            queryParameters['stdin'] = requestParameters.stdin;
        }

        if (requestParameters.stdout !== undefined) {
            queryParameters['stdout'] = requestParameters.stdout;
        }

        if (requestParameters.tty !== undefined) {
            queryParameters['tty'] = requestParameters.tty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/exec`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to exec of Pod
     */
    async connectCoreV1PostNamespacedPodExec(requestParameters: ConnectCoreV1PostNamespacedPodExecRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PostNamespacedPodExecRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to portforward of Pod
     */
    async connectCoreV1PostNamespacedPodPortforwardRaw(requestParameters: ConnectCoreV1PostNamespacedPodPortforwardRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNamespacedPodPortforward.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PostNamespacedPodPortforward.');
        }

        const queryParameters: any = {};

        if (requestParameters.ports !== undefined) {
            queryParameters['ports'] = requestParameters.ports;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/portforward`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to portforward of Pod
     */
    async connectCoreV1PostNamespacedPodPortforward(requestParameters: ConnectCoreV1PostNamespacedPodPortforwardRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PostNamespacedPodPortforwardRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectCoreV1PostNamespacedPodProxyRaw(requestParameters: ConnectCoreV1PostNamespacedPodProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PostNamespacedPodProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectCoreV1PostNamespacedPodProxy(requestParameters: ConnectCoreV1PostNamespacedPodProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PostNamespacedPodProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectCoreV1PostNamespacedPodProxyWithPathRaw(requestParameters: ConnectCoreV1PostNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PostNamespacedPodProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectCoreV1PostNamespacedPodProxyWithPath(requestParameters: ConnectCoreV1PostNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PostNamespacedPodProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectCoreV1PostNamespacedServiceProxyRaw(requestParameters: ConnectCoreV1PostNamespacedServiceProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PostNamespacedServiceProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectCoreV1PostNamespacedServiceProxy(requestParameters: ConnectCoreV1PostNamespacedServiceProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PostNamespacedServiceProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectCoreV1PostNamespacedServiceProxyWithPathRaw(requestParameters: ConnectCoreV1PostNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PostNamespacedServiceProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectCoreV1PostNamespacedServiceProxyWithPath(requestParameters: ConnectCoreV1PostNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PostNamespacedServiceProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectCoreV1PostNodeProxyRaw(requestParameters: ConnectCoreV1PostNodeProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNodeProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectCoreV1PostNodeProxy(requestParameters: ConnectCoreV1PostNodeProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PostNodeProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectCoreV1PostNodeProxyWithPathRaw(requestParameters: ConnectCoreV1PostNodeProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNodeProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectCoreV1PostNodeProxyWithPath(requestParameters: ConnectCoreV1PostNodeProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PostNodeProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectCoreV1PutNamespacedPodProxyRaw(requestParameters: ConnectCoreV1PutNamespacedPodProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PutNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PutNamespacedPodProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectCoreV1PutNamespacedPodProxy(requestParameters: ConnectCoreV1PutNamespacedPodProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PutNamespacedPodProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectCoreV1PutNamespacedPodProxyWithPathRaw(requestParameters: ConnectCoreV1PutNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PutNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PutNamespacedPodProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectCoreV1PutNamespacedPodProxyWithPath(requestParameters: ConnectCoreV1PutNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PutNamespacedPodProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectCoreV1PutNamespacedServiceProxyRaw(requestParameters: ConnectCoreV1PutNamespacedServiceProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PutNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PutNamespacedServiceProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectCoreV1PutNamespacedServiceProxy(requestParameters: ConnectCoreV1PutNamespacedServiceProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PutNamespacedServiceProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectCoreV1PutNamespacedServiceProxyWithPathRaw(requestParameters: ConnectCoreV1PutNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PutNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PutNamespacedServiceProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectCoreV1PutNamespacedServiceProxyWithPath(requestParameters: ConnectCoreV1PutNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PutNamespacedServiceProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectCoreV1PutNodeProxyRaw(requestParameters: ConnectCoreV1PutNodeProxyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PutNodeProxy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectCoreV1PutNodeProxy(requestParameters: ConnectCoreV1PutNodeProxyRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PutNodeProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectCoreV1PutNodeProxyWithPathRaw(requestParameters: ConnectCoreV1PutNodeProxyWithPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PutNodeProxyWithPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectCoreV1PutNodeProxyWithPath(requestParameters: ConnectCoreV1PutNodeProxyWithPathRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.connectCoreV1PutNodeProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a Namespace
     */
    async createCoreV1NamespaceRaw(requestParameters: CreateCoreV1NamespaceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1Namespace.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1NamespaceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * create a Namespace
     */
    async createCoreV1Namespace(requestParameters: CreateCoreV1NamespaceRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.createCoreV1NamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a Binding
     */
    async createCoreV1NamespacedBindingRaw(requestParameters: CreateCoreV1NamespacedBindingRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Binding>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedBinding.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedBinding.');
        }

        const queryParameters: any = {};

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/bindings`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1BindingToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1BindingFromJSON(jsonValue));
    }

    /**
     * create a Binding
     */
    async createCoreV1NamespacedBinding(requestParameters: CreateCoreV1NamespacedBindingRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Binding> {
        const response = await this.createCoreV1NamespacedBindingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a ConfigMap
     */
    async createCoreV1NamespacedConfigMapRaw(requestParameters: CreateCoreV1NamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ConfigMap>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedConfigMap.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ConfigMapToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ConfigMapFromJSON(jsonValue));
    }

    /**
     * create a ConfigMap
     */
    async createCoreV1NamespacedConfigMap(requestParameters: CreateCoreV1NamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ConfigMap> {
        const response = await this.createCoreV1NamespacedConfigMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create Endpoints
     */
    async createCoreV1NamespacedEndpointsRaw(requestParameters: CreateCoreV1NamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Endpoints>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedEndpoints.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1EndpointsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EndpointsFromJSON(jsonValue));
    }

    /**
     * create Endpoints
     */
    async createCoreV1NamespacedEndpoints(requestParameters: CreateCoreV1NamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Endpoints> {
        const response = await this.createCoreV1NamespacedEndpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create an Event
     */
    async createCoreV1NamespacedEventRaw(requestParameters: CreateCoreV1NamespacedEventRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Event>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedEvent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedEvent.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1EventToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EventFromJSON(jsonValue));
    }

    /**
     * create an Event
     */
    async createCoreV1NamespacedEvent(requestParameters: CreateCoreV1NamespacedEventRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Event> {
        const response = await this.createCoreV1NamespacedEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a LimitRange
     */
    async createCoreV1NamespacedLimitRangeRaw(requestParameters: CreateCoreV1NamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1LimitRange>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedLimitRange.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1LimitRangeToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1LimitRangeFromJSON(jsonValue));
    }

    /**
     * create a LimitRange
     */
    async createCoreV1NamespacedLimitRange(requestParameters: CreateCoreV1NamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1LimitRange> {
        const response = await this.createCoreV1NamespacedLimitRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a PersistentVolumeClaim
     */
    async createCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters: CreateCoreV1NamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaim>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedPersistentVolumeClaim.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PersistentVolumeClaimToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * create a PersistentVolumeClaim
     */
    async createCoreV1NamespacedPersistentVolumeClaim(requestParameters: CreateCoreV1NamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
        const response = await this.createCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a Pod
     */
    async createCoreV1NamespacedPodRaw(requestParameters: CreateCoreV1NamespacedPodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedPod.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedPod.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PodToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * create a Pod
     */
    async createCoreV1NamespacedPod(requestParameters: CreateCoreV1NamespacedPodRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.createCoreV1NamespacedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create binding of a Pod
     */
    async createCoreV1NamespacedPodBindingRaw(requestParameters: CreateCoreV1NamespacedPodBindingRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Binding>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling createCoreV1NamespacedPodBinding.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedPodBinding.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedPodBinding.');
        }

        const queryParameters: any = {};

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/binding`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1BindingToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1BindingFromJSON(jsonValue));
    }

    /**
     * create binding of a Pod
     */
    async createCoreV1NamespacedPodBinding(requestParameters: CreateCoreV1NamespacedPodBindingRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Binding> {
        const response = await this.createCoreV1NamespacedPodBindingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create eviction of a Pod
     */
    async createCoreV1NamespacedPodEvictionRaw(requestParameters: CreateCoreV1NamespacedPodEvictionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiPolicyV1Eviction>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling createCoreV1NamespacedPodEviction.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedPodEviction.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedPodEviction.');
        }

        const queryParameters: any = {};

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/eviction`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiPolicyV1EvictionToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiPolicyV1EvictionFromJSON(jsonValue));
    }

    /**
     * create eviction of a Pod
     */
    async createCoreV1NamespacedPodEviction(requestParameters: CreateCoreV1NamespacedPodEvictionRequest, initOverrides?: RequestInit): Promise<IoK8sApiPolicyV1Eviction> {
        const response = await this.createCoreV1NamespacedPodEvictionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a PodTemplate
     */
    async createCoreV1NamespacedPodTemplateRaw(requestParameters: CreateCoreV1NamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodTemplate>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedPodTemplate.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PodTemplateToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodTemplateFromJSON(jsonValue));
    }

    /**
     * create a PodTemplate
     */
    async createCoreV1NamespacedPodTemplate(requestParameters: CreateCoreV1NamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PodTemplate> {
        const response = await this.createCoreV1NamespacedPodTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a ReplicationController
     */
    async createCoreV1NamespacedReplicationControllerRaw(requestParameters: CreateCoreV1NamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationController>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedReplicationController.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ReplicationControllerToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * create a ReplicationController
     */
    async createCoreV1NamespacedReplicationController(requestParameters: CreateCoreV1NamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ReplicationController> {
        const response = await this.createCoreV1NamespacedReplicationControllerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a ResourceQuota
     */
    async createCoreV1NamespacedResourceQuotaRaw(requestParameters: CreateCoreV1NamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuota>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedResourceQuota.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ResourceQuotaToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * create a ResourceQuota
     */
    async createCoreV1NamespacedResourceQuota(requestParameters: CreateCoreV1NamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ResourceQuota> {
        const response = await this.createCoreV1NamespacedResourceQuotaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a Secret
     */
    async createCoreV1NamespacedSecretRaw(requestParameters: CreateCoreV1NamespacedSecretRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Secret>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedSecret.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedSecret.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1SecretToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1SecretFromJSON(jsonValue));
    }

    /**
     * create a Secret
     */
    async createCoreV1NamespacedSecret(requestParameters: CreateCoreV1NamespacedSecretRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Secret> {
        const response = await this.createCoreV1NamespacedSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a Service
     */
    async createCoreV1NamespacedServiceRaw(requestParameters: CreateCoreV1NamespacedServiceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Service>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedService.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedService.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ServiceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceFromJSON(jsonValue));
    }

    /**
     * create a Service
     */
    async createCoreV1NamespacedService(requestParameters: CreateCoreV1NamespacedServiceRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Service> {
        const response = await this.createCoreV1NamespacedServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a ServiceAccount
     */
    async createCoreV1NamespacedServiceAccountRaw(requestParameters: CreateCoreV1NamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceAccount>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedServiceAccount.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ServiceAccountToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * create a ServiceAccount
     */
    async createCoreV1NamespacedServiceAccount(requestParameters: CreateCoreV1NamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ServiceAccount> {
        const response = await this.createCoreV1NamespacedServiceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create token of a ServiceAccount
     */
    async createCoreV1NamespacedServiceAccountTokenRaw(requestParameters: CreateCoreV1NamespacedServiceAccountTokenRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiAuthenticationV1TokenRequest>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling createCoreV1NamespacedServiceAccountToken.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedServiceAccountToken.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedServiceAccountToken.');
        }

        const queryParameters: any = {};

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}/token`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiAuthenticationV1TokenRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiAuthenticationV1TokenRequestFromJSON(jsonValue));
    }

    /**
     * create token of a ServiceAccount
     */
    async createCoreV1NamespacedServiceAccountToken(requestParameters: CreateCoreV1NamespacedServiceAccountTokenRequest, initOverrides?: RequestInit): Promise<IoK8sApiAuthenticationV1TokenRequest> {
        const response = await this.createCoreV1NamespacedServiceAccountTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a Node
     */
    async createCoreV1NodeRaw(requestParameters: CreateCoreV1NodeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Node>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1Node.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1NodeToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeFromJSON(jsonValue));
    }

    /**
     * create a Node
     */
    async createCoreV1Node(requestParameters: CreateCoreV1NodeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Node> {
        const response = await this.createCoreV1NodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a PersistentVolume
     */
    async createCoreV1PersistentVolumeRaw(requestParameters: CreateCoreV1PersistentVolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolume>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1PersistentVolume.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PersistentVolumeToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * create a PersistentVolume
     */
    async createCoreV1PersistentVolume(requestParameters: CreateCoreV1PersistentVolumeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolume> {
        const response = await this.createCoreV1PersistentVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of ConfigMap
     */
    async deleteCoreV1CollectionNamespacedConfigMapRaw(requestParameters: DeleteCoreV1CollectionNamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedConfigMap.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ConfigMap
     */
    async deleteCoreV1CollectionNamespacedConfigMap(requestParameters: DeleteCoreV1CollectionNamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedConfigMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of Endpoints
     */
    async deleteCoreV1CollectionNamespacedEndpointsRaw(requestParameters: DeleteCoreV1CollectionNamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedEndpoints.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Endpoints
     */
    async deleteCoreV1CollectionNamespacedEndpoints(requestParameters: DeleteCoreV1CollectionNamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedEndpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of Event
     */
    async deleteCoreV1CollectionNamespacedEventRaw(requestParameters: DeleteCoreV1CollectionNamespacedEventRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedEvent.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Event
     */
    async deleteCoreV1CollectionNamespacedEvent(requestParameters: DeleteCoreV1CollectionNamespacedEventRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of LimitRange
     */
    async deleteCoreV1CollectionNamespacedLimitRangeRaw(requestParameters: DeleteCoreV1CollectionNamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedLimitRange.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of LimitRange
     */
    async deleteCoreV1CollectionNamespacedLimitRange(requestParameters: DeleteCoreV1CollectionNamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedLimitRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of PersistentVolumeClaim
     */
    async deleteCoreV1CollectionNamespacedPersistentVolumeClaimRaw(requestParameters: DeleteCoreV1CollectionNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedPersistentVolumeClaim.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of PersistentVolumeClaim
     */
    async deleteCoreV1CollectionNamespacedPersistentVolumeClaim(requestParameters: DeleteCoreV1CollectionNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedPersistentVolumeClaimRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of Pod
     */
    async deleteCoreV1CollectionNamespacedPodRaw(requestParameters: DeleteCoreV1CollectionNamespacedPodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedPod.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Pod
     */
    async deleteCoreV1CollectionNamespacedPod(requestParameters: DeleteCoreV1CollectionNamespacedPodRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of PodTemplate
     */
    async deleteCoreV1CollectionNamespacedPodTemplateRaw(requestParameters: DeleteCoreV1CollectionNamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedPodTemplate.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of PodTemplate
     */
    async deleteCoreV1CollectionNamespacedPodTemplate(requestParameters: DeleteCoreV1CollectionNamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedPodTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of ReplicationController
     */
    async deleteCoreV1CollectionNamespacedReplicationControllerRaw(requestParameters: DeleteCoreV1CollectionNamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedReplicationController.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ReplicationController
     */
    async deleteCoreV1CollectionNamespacedReplicationController(requestParameters: DeleteCoreV1CollectionNamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedReplicationControllerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of ResourceQuota
     */
    async deleteCoreV1CollectionNamespacedResourceQuotaRaw(requestParameters: DeleteCoreV1CollectionNamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedResourceQuota.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ResourceQuota
     */
    async deleteCoreV1CollectionNamespacedResourceQuota(requestParameters: DeleteCoreV1CollectionNamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedResourceQuotaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of Secret
     */
    async deleteCoreV1CollectionNamespacedSecretRaw(requestParameters: DeleteCoreV1CollectionNamespacedSecretRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedSecret.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Secret
     */
    async deleteCoreV1CollectionNamespacedSecret(requestParameters: DeleteCoreV1CollectionNamespacedSecretRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of Service
     */
    async deleteCoreV1CollectionNamespacedServiceRaw(requestParameters: DeleteCoreV1CollectionNamespacedServiceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedService.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Service
     */
    async deleteCoreV1CollectionNamespacedService(requestParameters: DeleteCoreV1CollectionNamespacedServiceRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of ServiceAccount
     */
    async deleteCoreV1CollectionNamespacedServiceAccountRaw(requestParameters: DeleteCoreV1CollectionNamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedServiceAccount.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ServiceAccount
     */
    async deleteCoreV1CollectionNamespacedServiceAccount(requestParameters: DeleteCoreV1CollectionNamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedServiceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of Node
     */
    async deleteCoreV1CollectionNodeRaw(requestParameters: DeleteCoreV1CollectionNodeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Node
     */
    async deleteCoreV1CollectionNode(requestParameters: DeleteCoreV1CollectionNodeRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of PersistentVolume
     */
    async deleteCoreV1CollectionPersistentVolumeRaw(requestParameters: DeleteCoreV1CollectionPersistentVolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of PersistentVolume
     */
    async deleteCoreV1CollectionPersistentVolume(requestParameters: DeleteCoreV1CollectionPersistentVolumeRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionPersistentVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a Namespace
     */
    async deleteCoreV1NamespaceRaw(requestParameters: DeleteCoreV1NamespaceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1Namespace.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a Namespace
     */
    async deleteCoreV1Namespace(requestParameters: DeleteCoreV1NamespaceRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a ConfigMap
     */
    async deleteCoreV1NamespacedConfigMapRaw(requestParameters: DeleteCoreV1NamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedConfigMap.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a ConfigMap
     */
    async deleteCoreV1NamespacedConfigMap(requestParameters: DeleteCoreV1NamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedConfigMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete Endpoints
     */
    async deleteCoreV1NamespacedEndpointsRaw(requestParameters: DeleteCoreV1NamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedEndpoints.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete Endpoints
     */
    async deleteCoreV1NamespacedEndpoints(requestParameters: DeleteCoreV1NamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedEndpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete an Event
     */
    async deleteCoreV1NamespacedEventRaw(requestParameters: DeleteCoreV1NamespacedEventRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedEvent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedEvent.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete an Event
     */
    async deleteCoreV1NamespacedEvent(requestParameters: DeleteCoreV1NamespacedEventRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a LimitRange
     */
    async deleteCoreV1NamespacedLimitRangeRaw(requestParameters: DeleteCoreV1NamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedLimitRange.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a LimitRange
     */
    async deleteCoreV1NamespacedLimitRange(requestParameters: DeleteCoreV1NamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedLimitRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a PersistentVolumeClaim
     */
    async deleteCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters: DeleteCoreV1NamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedPersistentVolumeClaim.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * delete a PersistentVolumeClaim
     */
    async deleteCoreV1NamespacedPersistentVolumeClaim(requestParameters: DeleteCoreV1NamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
        const response = await this.deleteCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a Pod
     */
    async deleteCoreV1NamespacedPodRaw(requestParameters: DeleteCoreV1NamespacedPodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedPod.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedPod.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * delete a Pod
     */
    async deleteCoreV1NamespacedPod(requestParameters: DeleteCoreV1NamespacedPodRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.deleteCoreV1NamespacedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a PodTemplate
     */
    async deleteCoreV1NamespacedPodTemplateRaw(requestParameters: DeleteCoreV1NamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodTemplate>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedPodTemplate.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodTemplateFromJSON(jsonValue));
    }

    /**
     * delete a PodTemplate
     */
    async deleteCoreV1NamespacedPodTemplate(requestParameters: DeleteCoreV1NamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PodTemplate> {
        const response = await this.deleteCoreV1NamespacedPodTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a ReplicationController
     */
    async deleteCoreV1NamespacedReplicationControllerRaw(requestParameters: DeleteCoreV1NamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedReplicationController.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a ReplicationController
     */
    async deleteCoreV1NamespacedReplicationController(requestParameters: DeleteCoreV1NamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedReplicationControllerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a ResourceQuota
     */
    async deleteCoreV1NamespacedResourceQuotaRaw(requestParameters: DeleteCoreV1NamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedResourceQuota.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * delete a ResourceQuota
     */
    async deleteCoreV1NamespacedResourceQuota(requestParameters: DeleteCoreV1NamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ResourceQuota> {
        const response = await this.deleteCoreV1NamespacedResourceQuotaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a Secret
     */
    async deleteCoreV1NamespacedSecretRaw(requestParameters: DeleteCoreV1NamespacedSecretRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedSecret.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a Secret
     */
    async deleteCoreV1NamespacedSecret(requestParameters: DeleteCoreV1NamespacedSecretRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a Service
     */
    async deleteCoreV1NamespacedServiceRaw(requestParameters: DeleteCoreV1NamespacedServiceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedService.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedService.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceFromJSON(jsonValue));
    }

    /**
     * delete a Service
     */
    async deleteCoreV1NamespacedService(requestParameters: DeleteCoreV1NamespacedServiceRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Service> {
        const response = await this.deleteCoreV1NamespacedServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a ServiceAccount
     */
    async deleteCoreV1NamespacedServiceAccountRaw(requestParameters: DeleteCoreV1NamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceAccount>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedServiceAccount.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * delete a ServiceAccount
     */
    async deleteCoreV1NamespacedServiceAccount(requestParameters: DeleteCoreV1NamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ServiceAccount> {
        const response = await this.deleteCoreV1NamespacedServiceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a Node
     */
    async deleteCoreV1NodeRaw(requestParameters: DeleteCoreV1NodeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1Node.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a Node
     */
    async deleteCoreV1Node(requestParameters: DeleteCoreV1NodeRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a PersistentVolume
     */
    async deleteCoreV1PersistentVolumeRaw(requestParameters: DeleteCoreV1PersistentVolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1PersistentVolume.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * delete a PersistentVolume
     */
    async deleteCoreV1PersistentVolume(requestParameters: DeleteCoreV1PersistentVolumeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolume> {
        const response = await this.deleteCoreV1PersistentVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get available resources
     */
    async getCoreV1APIResourcesRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1APIResourceList>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue));
    }

    /**
     * get available resources
     */
    async getCoreV1APIResources(initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
        const response = await this.getCoreV1APIResourcesRaw(initOverrides);
        return await response.value();
    }

    /**
     * list objects of kind ComponentStatus
     */
    async listCoreV1ComponentStatusRaw(requestParameters: ListCoreV1ComponentStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ComponentStatusList>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/componentstatuses`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ComponentStatusListFromJSON(jsonValue));
    }

    /**
     * list objects of kind ComponentStatus
     */
    async listCoreV1ComponentStatus(requestParameters: ListCoreV1ComponentStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ComponentStatusList> {
        const response = await this.listCoreV1ComponentStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listCoreV1ConfigMapForAllNamespacesRaw(requestParameters: ListCoreV1ConfigMapForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ConfigMapList>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/configmaps`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ConfigMapListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listCoreV1ConfigMapForAllNamespaces(requestParameters: ListCoreV1ConfigMapForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ConfigMapList> {
        const response = await this.listCoreV1ConfigMapForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listCoreV1EndpointsForAllNamespacesRaw(requestParameters: ListCoreV1EndpointsForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1EndpointsList>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/endpoints`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EndpointsListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listCoreV1EndpointsForAllNamespaces(requestParameters: ListCoreV1EndpointsForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1EndpointsList> {
        const response = await this.listCoreV1EndpointsForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Event
     */
    async listCoreV1EventForAllNamespacesRaw(requestParameters: ListCoreV1EventForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1EventList>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/events`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EventListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Event
     */
    async listCoreV1EventForAllNamespaces(requestParameters: ListCoreV1EventForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1EventList> {
        const response = await this.listCoreV1EventForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listCoreV1LimitRangeForAllNamespacesRaw(requestParameters: ListCoreV1LimitRangeForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1LimitRangeList>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/limitranges`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1LimitRangeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listCoreV1LimitRangeForAllNamespaces(requestParameters: ListCoreV1LimitRangeForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1LimitRangeList> {
        const response = await this.listCoreV1LimitRangeForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Namespace
     */
    async listCoreV1NamespaceRaw(requestParameters: ListCoreV1NamespaceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1NamespaceList>> {
        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Namespace
     */
    async listCoreV1Namespace(requestParameters: ListCoreV1NamespaceRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1NamespaceList> {
        const response = await this.listCoreV1NamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listCoreV1NamespacedConfigMapRaw(requestParameters: ListCoreV1NamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ConfigMapList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedConfigMap.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ConfigMapListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listCoreV1NamespacedConfigMap(requestParameters: ListCoreV1NamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ConfigMapList> {
        const response = await this.listCoreV1NamespacedConfigMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listCoreV1NamespacedEndpointsRaw(requestParameters: ListCoreV1NamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1EndpointsList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedEndpoints.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EndpointsListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listCoreV1NamespacedEndpoints(requestParameters: ListCoreV1NamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1EndpointsList> {
        const response = await this.listCoreV1NamespacedEndpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Event
     */
    async listCoreV1NamespacedEventRaw(requestParameters: ListCoreV1NamespacedEventRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1EventList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedEvent.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EventListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Event
     */
    async listCoreV1NamespacedEvent(requestParameters: ListCoreV1NamespacedEventRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1EventList> {
        const response = await this.listCoreV1NamespacedEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listCoreV1NamespacedLimitRangeRaw(requestParameters: ListCoreV1NamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1LimitRangeList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedLimitRange.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1LimitRangeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listCoreV1NamespacedLimitRange(requestParameters: ListCoreV1NamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1LimitRangeList> {
        const response = await this.listCoreV1NamespacedLimitRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters: ListCoreV1NamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaimList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedPersistentVolumeClaim.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listCoreV1NamespacedPersistentVolumeClaim(requestParameters: ListCoreV1NamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolumeClaimList> {
        const response = await this.listCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Pod
     */
    async listCoreV1NamespacedPodRaw(requestParameters: ListCoreV1NamespacedPodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedPod.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Pod
     */
    async listCoreV1NamespacedPod(requestParameters: ListCoreV1NamespacedPodRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PodList> {
        const response = await this.listCoreV1NamespacedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listCoreV1NamespacedPodTemplateRaw(requestParameters: ListCoreV1NamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodTemplateList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedPodTemplate.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodTemplateListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listCoreV1NamespacedPodTemplate(requestParameters: ListCoreV1NamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PodTemplateList> {
        const response = await this.listCoreV1NamespacedPodTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listCoreV1NamespacedReplicationControllerRaw(requestParameters: ListCoreV1NamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationControllerList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedReplicationController.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listCoreV1NamespacedReplicationController(requestParameters: ListCoreV1NamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ReplicationControllerList> {
        const response = await this.listCoreV1NamespacedReplicationControllerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listCoreV1NamespacedResourceQuotaRaw(requestParameters: ListCoreV1NamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuotaList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedResourceQuota.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listCoreV1NamespacedResourceQuota(requestParameters: ListCoreV1NamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ResourceQuotaList> {
        const response = await this.listCoreV1NamespacedResourceQuotaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Secret
     */
    async listCoreV1NamespacedSecretRaw(requestParameters: ListCoreV1NamespacedSecretRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1SecretList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedSecret.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1SecretListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Secret
     */
    async listCoreV1NamespacedSecret(requestParameters: ListCoreV1NamespacedSecretRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1SecretList> {
        const response = await this.listCoreV1NamespacedSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Service
     */
    async listCoreV1NamespacedServiceRaw(requestParameters: ListCoreV1NamespacedServiceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedService.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Service
     */
    async listCoreV1NamespacedService(requestParameters: ListCoreV1NamespacedServiceRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ServiceList> {
        const response = await this.listCoreV1NamespacedServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listCoreV1NamespacedServiceAccountRaw(requestParameters: ListCoreV1NamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceAccountList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedServiceAccount.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceAccountListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listCoreV1NamespacedServiceAccount(requestParameters: ListCoreV1NamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ServiceAccountList> {
        const response = await this.listCoreV1NamespacedServiceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Node
     */
    async listCoreV1NodeRaw(requestParameters: ListCoreV1NodeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1NodeList>> {
        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Node
     */
    async listCoreV1Node(requestParameters: ListCoreV1NodeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1NodeList> {
        const response = await this.listCoreV1NodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind PersistentVolume
     */
    async listCoreV1PersistentVolumeRaw(requestParameters: ListCoreV1PersistentVolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeList>> {
        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PersistentVolume
     */
    async listCoreV1PersistentVolume(requestParameters: ListCoreV1PersistentVolumeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolumeList> {
        const response = await this.listCoreV1PersistentVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listCoreV1PersistentVolumeClaimForAllNamespacesRaw(requestParameters: ListCoreV1PersistentVolumeClaimForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaimList>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumeclaims`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listCoreV1PersistentVolumeClaimForAllNamespaces(requestParameters: ListCoreV1PersistentVolumeClaimForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolumeClaimList> {
        const response = await this.listCoreV1PersistentVolumeClaimForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Pod
     */
    async listCoreV1PodForAllNamespacesRaw(requestParameters: ListCoreV1PodForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodList>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/pods`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Pod
     */
    async listCoreV1PodForAllNamespaces(requestParameters: ListCoreV1PodForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PodList> {
        const response = await this.listCoreV1PodForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listCoreV1PodTemplateForAllNamespacesRaw(requestParameters: ListCoreV1PodTemplateForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodTemplateList>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/podtemplates`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodTemplateListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listCoreV1PodTemplateForAllNamespaces(requestParameters: ListCoreV1PodTemplateForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PodTemplateList> {
        const response = await this.listCoreV1PodTemplateForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listCoreV1ReplicationControllerForAllNamespacesRaw(requestParameters: ListCoreV1ReplicationControllerForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationControllerList>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/replicationcontrollers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listCoreV1ReplicationControllerForAllNamespaces(requestParameters: ListCoreV1ReplicationControllerForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ReplicationControllerList> {
        const response = await this.listCoreV1ReplicationControllerForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listCoreV1ResourceQuotaForAllNamespacesRaw(requestParameters: ListCoreV1ResourceQuotaForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuotaList>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/resourcequotas`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listCoreV1ResourceQuotaForAllNamespaces(requestParameters: ListCoreV1ResourceQuotaForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ResourceQuotaList> {
        const response = await this.listCoreV1ResourceQuotaForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Secret
     */
    async listCoreV1SecretForAllNamespacesRaw(requestParameters: ListCoreV1SecretForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1SecretList>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/secrets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1SecretListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Secret
     */
    async listCoreV1SecretForAllNamespaces(requestParameters: ListCoreV1SecretForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1SecretList> {
        const response = await this.listCoreV1SecretForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listCoreV1ServiceAccountForAllNamespacesRaw(requestParameters: ListCoreV1ServiceAccountForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceAccountList>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/serviceaccounts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceAccountListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listCoreV1ServiceAccountForAllNamespaces(requestParameters: ListCoreV1ServiceAccountForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ServiceAccountList> {
        const response = await this.listCoreV1ServiceAccountForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Service
     */
    async listCoreV1ServiceForAllNamespacesRaw(requestParameters: ListCoreV1ServiceForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceList>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/services`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Service
     */
    async listCoreV1ServiceForAllNamespaces(requestParameters: ListCoreV1ServiceForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ServiceList> {
        const response = await this.listCoreV1ServiceForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified Namespace
     */
    async patchCoreV1NamespaceRaw(requestParameters: PatchCoreV1NamespaceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1Namespace.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1Namespace.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * partially update the specified Namespace
     */
    async patchCoreV1Namespace(requestParameters: PatchCoreV1NamespaceRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.patchCoreV1NamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified Namespace
     */
    async patchCoreV1NamespaceStatusRaw(requestParameters: PatchCoreV1NamespaceStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespaceStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespaceStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Namespace
     */
    async patchCoreV1NamespaceStatus(requestParameters: PatchCoreV1NamespaceStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.patchCoreV1NamespaceStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified ConfigMap
     */
    async patchCoreV1NamespacedConfigMapRaw(requestParameters: PatchCoreV1NamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ConfigMap>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedConfigMap.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ConfigMapFromJSON(jsonValue));
    }

    /**
     * partially update the specified ConfigMap
     */
    async patchCoreV1NamespacedConfigMap(requestParameters: PatchCoreV1NamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ConfigMap> {
        const response = await this.patchCoreV1NamespacedConfigMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified Endpoints
     */
    async patchCoreV1NamespacedEndpointsRaw(requestParameters: PatchCoreV1NamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Endpoints>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedEndpoints.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EndpointsFromJSON(jsonValue));
    }

    /**
     * partially update the specified Endpoints
     */
    async patchCoreV1NamespacedEndpoints(requestParameters: PatchCoreV1NamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Endpoints> {
        const response = await this.patchCoreV1NamespacedEndpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified Event
     */
    async patchCoreV1NamespacedEventRaw(requestParameters: PatchCoreV1NamespacedEventRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Event>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedEvent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedEvent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedEvent.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EventFromJSON(jsonValue));
    }

    /**
     * partially update the specified Event
     */
    async patchCoreV1NamespacedEvent(requestParameters: PatchCoreV1NamespacedEventRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Event> {
        const response = await this.patchCoreV1NamespacedEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified LimitRange
     */
    async patchCoreV1NamespacedLimitRangeRaw(requestParameters: PatchCoreV1NamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1LimitRange>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedLimitRange.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1LimitRangeFromJSON(jsonValue));
    }

    /**
     * partially update the specified LimitRange
     */
    async patchCoreV1NamespacedLimitRange(requestParameters: PatchCoreV1NamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1LimitRange> {
        const response = await this.patchCoreV1NamespacedLimitRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified PersistentVolumeClaim
     */
    async patchCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters: PatchCoreV1NamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedPersistentVolumeClaim.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * partially update the specified PersistentVolumeClaim
     */
    async patchCoreV1NamespacedPersistentVolumeClaim(requestParameters: PatchCoreV1NamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
        const response = await this.patchCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified PersistentVolumeClaim
     */
    async patchCoreV1NamespacedPersistentVolumeClaimStatusRaw(requestParameters: PatchCoreV1NamespacedPersistentVolumeClaimStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified PersistentVolumeClaim
     */
    async patchCoreV1NamespacedPersistentVolumeClaimStatus(requestParameters: PatchCoreV1NamespacedPersistentVolumeClaimStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
        const response = await this.patchCoreV1NamespacedPersistentVolumeClaimStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified Pod
     */
    async patchCoreV1NamespacedPodRaw(requestParameters: PatchCoreV1NamespacedPodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedPod.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedPod.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedPod.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * partially update the specified Pod
     */
    async patchCoreV1NamespacedPod(requestParameters: PatchCoreV1NamespacedPodRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.patchCoreV1NamespacedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update ephemeralcontainers of the specified Pod
     */
    async patchCoreV1NamespacedPodEphemeralcontainersRaw(requestParameters: PatchCoreV1NamespacedPodEphemeralcontainersRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedPodEphemeralcontainers.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedPodEphemeralcontainers.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedPodEphemeralcontainers.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * partially update ephemeralcontainers of the specified Pod
     */
    async patchCoreV1NamespacedPodEphemeralcontainers(requestParameters: PatchCoreV1NamespacedPodEphemeralcontainersRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.patchCoreV1NamespacedPodEphemeralcontainersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified Pod
     */
    async patchCoreV1NamespacedPodStatusRaw(requestParameters: PatchCoreV1NamespacedPodStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedPodStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedPodStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedPodStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Pod
     */
    async patchCoreV1NamespacedPodStatus(requestParameters: PatchCoreV1NamespacedPodStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.patchCoreV1NamespacedPodStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified PodTemplate
     */
    async patchCoreV1NamespacedPodTemplateRaw(requestParameters: PatchCoreV1NamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodTemplate>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedPodTemplate.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodTemplateFromJSON(jsonValue));
    }

    /**
     * partially update the specified PodTemplate
     */
    async patchCoreV1NamespacedPodTemplate(requestParameters: PatchCoreV1NamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PodTemplate> {
        const response = await this.patchCoreV1NamespacedPodTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified ReplicationController
     */
    async patchCoreV1NamespacedReplicationControllerRaw(requestParameters: PatchCoreV1NamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedReplicationController.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * partially update the specified ReplicationController
     */
    async patchCoreV1NamespacedReplicationController(requestParameters: PatchCoreV1NamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ReplicationController> {
        const response = await this.patchCoreV1NamespacedReplicationControllerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update scale of the specified ReplicationController
     */
    async patchCoreV1NamespacedReplicationControllerScaleRaw(requestParameters: PatchCoreV1NamespacedReplicationControllerScaleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiAutoscalingV1Scale>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedReplicationControllerScale.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedReplicationControllerScale.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedReplicationControllerScale.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiAutoscalingV1ScaleFromJSON(jsonValue));
    }

    /**
     * partially update scale of the specified ReplicationController
     */
    async patchCoreV1NamespacedReplicationControllerScale(requestParameters: PatchCoreV1NamespacedReplicationControllerScaleRequest, initOverrides?: RequestInit): Promise<IoK8sApiAutoscalingV1Scale> {
        const response = await this.patchCoreV1NamespacedReplicationControllerScaleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified ReplicationController
     */
    async patchCoreV1NamespacedReplicationControllerStatusRaw(requestParameters: PatchCoreV1NamespacedReplicationControllerStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedReplicationControllerStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedReplicationControllerStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedReplicationControllerStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified ReplicationController
     */
    async patchCoreV1NamespacedReplicationControllerStatus(requestParameters: PatchCoreV1NamespacedReplicationControllerStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ReplicationController> {
        const response = await this.patchCoreV1NamespacedReplicationControllerStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified ResourceQuota
     */
    async patchCoreV1NamespacedResourceQuotaRaw(requestParameters: PatchCoreV1NamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedResourceQuota.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * partially update the specified ResourceQuota
     */
    async patchCoreV1NamespacedResourceQuota(requestParameters: PatchCoreV1NamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ResourceQuota> {
        const response = await this.patchCoreV1NamespacedResourceQuotaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified ResourceQuota
     */
    async patchCoreV1NamespacedResourceQuotaStatusRaw(requestParameters: PatchCoreV1NamespacedResourceQuotaStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedResourceQuotaStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedResourceQuotaStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedResourceQuotaStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified ResourceQuota
     */
    async patchCoreV1NamespacedResourceQuotaStatus(requestParameters: PatchCoreV1NamespacedResourceQuotaStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ResourceQuota> {
        const response = await this.patchCoreV1NamespacedResourceQuotaStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified Secret
     */
    async patchCoreV1NamespacedSecretRaw(requestParameters: PatchCoreV1NamespacedSecretRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Secret>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedSecret.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedSecret.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1SecretFromJSON(jsonValue));
    }

    /**
     * partially update the specified Secret
     */
    async patchCoreV1NamespacedSecret(requestParameters: PatchCoreV1NamespacedSecretRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Secret> {
        const response = await this.patchCoreV1NamespacedSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified Service
     */
    async patchCoreV1NamespacedServiceRaw(requestParameters: PatchCoreV1NamespacedServiceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedService.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedService.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedService.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceFromJSON(jsonValue));
    }

    /**
     * partially update the specified Service
     */
    async patchCoreV1NamespacedService(requestParameters: PatchCoreV1NamespacedServiceRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Service> {
        const response = await this.patchCoreV1NamespacedServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified ServiceAccount
     */
    async patchCoreV1NamespacedServiceAccountRaw(requestParameters: PatchCoreV1NamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceAccount>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedServiceAccount.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * partially update the specified ServiceAccount
     */
    async patchCoreV1NamespacedServiceAccount(requestParameters: PatchCoreV1NamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ServiceAccount> {
        const response = await this.patchCoreV1NamespacedServiceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified Service
     */
    async patchCoreV1NamespacedServiceStatusRaw(requestParameters: PatchCoreV1NamespacedServiceStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedServiceStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedServiceStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedServiceStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Service
     */
    async patchCoreV1NamespacedServiceStatus(requestParameters: PatchCoreV1NamespacedServiceStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Service> {
        const response = await this.patchCoreV1NamespacedServiceStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified Node
     */
    async patchCoreV1NodeRaw(requestParameters: PatchCoreV1NodeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1Node.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1Node.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeFromJSON(jsonValue));
    }

    /**
     * partially update the specified Node
     */
    async patchCoreV1Node(requestParameters: PatchCoreV1NodeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Node> {
        const response = await this.patchCoreV1NodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified Node
     */
    async patchCoreV1NodeStatusRaw(requestParameters: PatchCoreV1NodeStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NodeStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NodeStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Node
     */
    async patchCoreV1NodeStatus(requestParameters: PatchCoreV1NodeStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Node> {
        const response = await this.patchCoreV1NodeStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified PersistentVolume
     */
    async patchCoreV1PersistentVolumeRaw(requestParameters: PatchCoreV1PersistentVolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1PersistentVolume.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1PersistentVolume.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * partially update the specified PersistentVolume
     */
    async patchCoreV1PersistentVolume(requestParameters: PatchCoreV1PersistentVolumeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolume> {
        const response = await this.patchCoreV1PersistentVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified PersistentVolume
     */
    async patchCoreV1PersistentVolumeStatusRaw(requestParameters: PatchCoreV1PersistentVolumeStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1PersistentVolumeStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1PersistentVolumeStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified PersistentVolume
     */
    async patchCoreV1PersistentVolumeStatus(requestParameters: PatchCoreV1PersistentVolumeStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolume> {
        const response = await this.patchCoreV1PersistentVolumeStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified ComponentStatus
     */
    async readCoreV1ComponentStatusRaw(requestParameters: ReadCoreV1ComponentStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ComponentStatus>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1ComponentStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/componentstatuses/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ComponentStatusFromJSON(jsonValue));
    }

    /**
     * read the specified ComponentStatus
     */
    async readCoreV1ComponentStatus(requestParameters: ReadCoreV1ComponentStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ComponentStatus> {
        const response = await this.readCoreV1ComponentStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified Namespace
     */
    async readCoreV1NamespaceRaw(requestParameters: ReadCoreV1NamespaceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1Namespace.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * read the specified Namespace
     */
    async readCoreV1Namespace(requestParameters: ReadCoreV1NamespaceRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.readCoreV1NamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified Namespace
     */
    async readCoreV1NamespaceStatusRaw(requestParameters: ReadCoreV1NamespaceStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespaceStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * read status of the specified Namespace
     */
    async readCoreV1NamespaceStatus(requestParameters: ReadCoreV1NamespaceStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.readCoreV1NamespaceStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified ConfigMap
     */
    async readCoreV1NamespacedConfigMapRaw(requestParameters: ReadCoreV1NamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ConfigMap>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedConfigMap.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ConfigMapFromJSON(jsonValue));
    }

    /**
     * read the specified ConfigMap
     */
    async readCoreV1NamespacedConfigMap(requestParameters: ReadCoreV1NamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ConfigMap> {
        const response = await this.readCoreV1NamespacedConfigMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified Endpoints
     */
    async readCoreV1NamespacedEndpointsRaw(requestParameters: ReadCoreV1NamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Endpoints>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedEndpoints.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EndpointsFromJSON(jsonValue));
    }

    /**
     * read the specified Endpoints
     */
    async readCoreV1NamespacedEndpoints(requestParameters: ReadCoreV1NamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Endpoints> {
        const response = await this.readCoreV1NamespacedEndpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified Event
     */
    async readCoreV1NamespacedEventRaw(requestParameters: ReadCoreV1NamespacedEventRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Event>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedEvent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedEvent.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EventFromJSON(jsonValue));
    }

    /**
     * read the specified Event
     */
    async readCoreV1NamespacedEvent(requestParameters: ReadCoreV1NamespacedEventRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Event> {
        const response = await this.readCoreV1NamespacedEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified LimitRange
     */
    async readCoreV1NamespacedLimitRangeRaw(requestParameters: ReadCoreV1NamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1LimitRange>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedLimitRange.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1LimitRangeFromJSON(jsonValue));
    }

    /**
     * read the specified LimitRange
     */
    async readCoreV1NamespacedLimitRange(requestParameters: ReadCoreV1NamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1LimitRange> {
        const response = await this.readCoreV1NamespacedLimitRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified PersistentVolumeClaim
     */
    async readCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters: ReadCoreV1NamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedPersistentVolumeClaim.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * read the specified PersistentVolumeClaim
     */
    async readCoreV1NamespacedPersistentVolumeClaim(requestParameters: ReadCoreV1NamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
        const response = await this.readCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified PersistentVolumeClaim
     */
    async readCoreV1NamespacedPersistentVolumeClaimStatusRaw(requestParameters: ReadCoreV1NamespacedPersistentVolumeClaimStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * read status of the specified PersistentVolumeClaim
     */
    async readCoreV1NamespacedPersistentVolumeClaimStatus(requestParameters: ReadCoreV1NamespacedPersistentVolumeClaimStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
        const response = await this.readCoreV1NamespacedPersistentVolumeClaimStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified Pod
     */
    async readCoreV1NamespacedPodRaw(requestParameters: ReadCoreV1NamespacedPodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedPod.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedPod.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * read the specified Pod
     */
    async readCoreV1NamespacedPod(requestParameters: ReadCoreV1NamespacedPodRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.readCoreV1NamespacedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read ephemeralcontainers of the specified Pod
     */
    async readCoreV1NamespacedPodEphemeralcontainersRaw(requestParameters: ReadCoreV1NamespacedPodEphemeralcontainersRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedPodEphemeralcontainers.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedPodEphemeralcontainers.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * read ephemeralcontainers of the specified Pod
     */
    async readCoreV1NamespacedPodEphemeralcontainers(requestParameters: ReadCoreV1NamespacedPodEphemeralcontainersRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.readCoreV1NamespacedPodEphemeralcontainersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read log of the specified Pod
     */
    async readCoreV1NamespacedPodLogRaw(requestParameters: ReadCoreV1NamespacedPodLogRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedPodLog.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedPodLog.');
        }

        const queryParameters: any = {};

        if (requestParameters.container !== undefined) {
            queryParameters['container'] = requestParameters.container;
        }

        if (requestParameters.follow !== undefined) {
            queryParameters['follow'] = requestParameters.follow;
        }

        if (requestParameters.insecureSkipTLSVerifyBackend !== undefined) {
            queryParameters['insecureSkipTLSVerifyBackend'] = requestParameters.insecureSkipTLSVerifyBackend;
        }

        if (requestParameters.limitBytes !== undefined) {
            queryParameters['limitBytes'] = requestParameters.limitBytes;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.previous !== undefined) {
            queryParameters['previous'] = requestParameters.previous;
        }

        if (requestParameters.sinceSeconds !== undefined) {
            queryParameters['sinceSeconds'] = requestParameters.sinceSeconds;
        }

        if (requestParameters.tailLines !== undefined) {
            queryParameters['tailLines'] = requestParameters.tailLines;
        }

        if (requestParameters.timestamps !== undefined) {
            queryParameters['timestamps'] = requestParameters.timestamps;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/log`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * read log of the specified Pod
     */
    async readCoreV1NamespacedPodLog(requestParameters: ReadCoreV1NamespacedPodLogRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.readCoreV1NamespacedPodLogRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified Pod
     */
    async readCoreV1NamespacedPodStatusRaw(requestParameters: ReadCoreV1NamespacedPodStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedPodStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedPodStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * read status of the specified Pod
     */
    async readCoreV1NamespacedPodStatus(requestParameters: ReadCoreV1NamespacedPodStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.readCoreV1NamespacedPodStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified PodTemplate
     */
    async readCoreV1NamespacedPodTemplateRaw(requestParameters: ReadCoreV1NamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodTemplate>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedPodTemplate.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodTemplateFromJSON(jsonValue));
    }

    /**
     * read the specified PodTemplate
     */
    async readCoreV1NamespacedPodTemplate(requestParameters: ReadCoreV1NamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PodTemplate> {
        const response = await this.readCoreV1NamespacedPodTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified ReplicationController
     */
    async readCoreV1NamespacedReplicationControllerRaw(requestParameters: ReadCoreV1NamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedReplicationController.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * read the specified ReplicationController
     */
    async readCoreV1NamespacedReplicationController(requestParameters: ReadCoreV1NamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ReplicationController> {
        const response = await this.readCoreV1NamespacedReplicationControllerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read scale of the specified ReplicationController
     */
    async readCoreV1NamespacedReplicationControllerScaleRaw(requestParameters: ReadCoreV1NamespacedReplicationControllerScaleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiAutoscalingV1Scale>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedReplicationControllerScale.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedReplicationControllerScale.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiAutoscalingV1ScaleFromJSON(jsonValue));
    }

    /**
     * read scale of the specified ReplicationController
     */
    async readCoreV1NamespacedReplicationControllerScale(requestParameters: ReadCoreV1NamespacedReplicationControllerScaleRequest, initOverrides?: RequestInit): Promise<IoK8sApiAutoscalingV1Scale> {
        const response = await this.readCoreV1NamespacedReplicationControllerScaleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified ReplicationController
     */
    async readCoreV1NamespacedReplicationControllerStatusRaw(requestParameters: ReadCoreV1NamespacedReplicationControllerStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedReplicationControllerStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedReplicationControllerStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * read status of the specified ReplicationController
     */
    async readCoreV1NamespacedReplicationControllerStatus(requestParameters: ReadCoreV1NamespacedReplicationControllerStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ReplicationController> {
        const response = await this.readCoreV1NamespacedReplicationControllerStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified ResourceQuota
     */
    async readCoreV1NamespacedResourceQuotaRaw(requestParameters: ReadCoreV1NamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedResourceQuota.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * read the specified ResourceQuota
     */
    async readCoreV1NamespacedResourceQuota(requestParameters: ReadCoreV1NamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ResourceQuota> {
        const response = await this.readCoreV1NamespacedResourceQuotaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified ResourceQuota
     */
    async readCoreV1NamespacedResourceQuotaStatusRaw(requestParameters: ReadCoreV1NamespacedResourceQuotaStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedResourceQuotaStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedResourceQuotaStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * read status of the specified ResourceQuota
     */
    async readCoreV1NamespacedResourceQuotaStatus(requestParameters: ReadCoreV1NamespacedResourceQuotaStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ResourceQuota> {
        const response = await this.readCoreV1NamespacedResourceQuotaStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified Secret
     */
    async readCoreV1NamespacedSecretRaw(requestParameters: ReadCoreV1NamespacedSecretRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Secret>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedSecret.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1SecretFromJSON(jsonValue));
    }

    /**
     * read the specified Secret
     */
    async readCoreV1NamespacedSecret(requestParameters: ReadCoreV1NamespacedSecretRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Secret> {
        const response = await this.readCoreV1NamespacedSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified Service
     */
    async readCoreV1NamespacedServiceRaw(requestParameters: ReadCoreV1NamespacedServiceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedService.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedService.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceFromJSON(jsonValue));
    }

    /**
     * read the specified Service
     */
    async readCoreV1NamespacedService(requestParameters: ReadCoreV1NamespacedServiceRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Service> {
        const response = await this.readCoreV1NamespacedServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified ServiceAccount
     */
    async readCoreV1NamespacedServiceAccountRaw(requestParameters: ReadCoreV1NamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceAccount>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedServiceAccount.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * read the specified ServiceAccount
     */
    async readCoreV1NamespacedServiceAccount(requestParameters: ReadCoreV1NamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ServiceAccount> {
        const response = await this.readCoreV1NamespacedServiceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified Service
     */
    async readCoreV1NamespacedServiceStatusRaw(requestParameters: ReadCoreV1NamespacedServiceStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedServiceStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedServiceStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceFromJSON(jsonValue));
    }

    /**
     * read status of the specified Service
     */
    async readCoreV1NamespacedServiceStatus(requestParameters: ReadCoreV1NamespacedServiceStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Service> {
        const response = await this.readCoreV1NamespacedServiceStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified Node
     */
    async readCoreV1NodeRaw(requestParameters: ReadCoreV1NodeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1Node.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeFromJSON(jsonValue));
    }

    /**
     * read the specified Node
     */
    async readCoreV1Node(requestParameters: ReadCoreV1NodeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Node> {
        const response = await this.readCoreV1NodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified Node
     */
    async readCoreV1NodeStatusRaw(requestParameters: ReadCoreV1NodeStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NodeStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeFromJSON(jsonValue));
    }

    /**
     * read status of the specified Node
     */
    async readCoreV1NodeStatus(requestParameters: ReadCoreV1NodeStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Node> {
        const response = await this.readCoreV1NodeStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified PersistentVolume
     */
    async readCoreV1PersistentVolumeRaw(requestParameters: ReadCoreV1PersistentVolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1PersistentVolume.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * read the specified PersistentVolume
     */
    async readCoreV1PersistentVolume(requestParameters: ReadCoreV1PersistentVolumeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolume> {
        const response = await this.readCoreV1PersistentVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified PersistentVolume
     */
    async readCoreV1PersistentVolumeStatusRaw(requestParameters: ReadCoreV1PersistentVolumeStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1PersistentVolumeStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * read status of the specified PersistentVolume
     */
    async readCoreV1PersistentVolumeStatus(requestParameters: ReadCoreV1PersistentVolumeStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolume> {
        const response = await this.readCoreV1PersistentVolumeStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified Namespace
     */
    async replaceCoreV1NamespaceRaw(requestParameters: ReplaceCoreV1NamespaceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1Namespace.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1Namespace.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1NamespaceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * replace the specified Namespace
     */
    async replaceCoreV1Namespace(requestParameters: ReplaceCoreV1NamespaceRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.replaceCoreV1NamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace finalize of the specified Namespace
     */
    async replaceCoreV1NamespaceFinalizeRaw(requestParameters: ReplaceCoreV1NamespaceFinalizeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespaceFinalize.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespaceFinalize.');
        }

        const queryParameters: any = {};

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/finalize`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1NamespaceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * replace finalize of the specified Namespace
     */
    async replaceCoreV1NamespaceFinalize(requestParameters: ReplaceCoreV1NamespaceFinalizeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.replaceCoreV1NamespaceFinalizeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified Namespace
     */
    async replaceCoreV1NamespaceStatusRaw(requestParameters: ReplaceCoreV1NamespaceStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespaceStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespaceStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1NamespaceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Namespace
     */
    async replaceCoreV1NamespaceStatus(requestParameters: ReplaceCoreV1NamespaceStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.replaceCoreV1NamespaceStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified ConfigMap
     */
    async replaceCoreV1NamespacedConfigMapRaw(requestParameters: ReplaceCoreV1NamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ConfigMap>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedConfigMap.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ConfigMapToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ConfigMapFromJSON(jsonValue));
    }

    /**
     * replace the specified ConfigMap
     */
    async replaceCoreV1NamespacedConfigMap(requestParameters: ReplaceCoreV1NamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ConfigMap> {
        const response = await this.replaceCoreV1NamespacedConfigMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified Endpoints
     */
    async replaceCoreV1NamespacedEndpointsRaw(requestParameters: ReplaceCoreV1NamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Endpoints>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedEndpoints.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1EndpointsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EndpointsFromJSON(jsonValue));
    }

    /**
     * replace the specified Endpoints
     */
    async replaceCoreV1NamespacedEndpoints(requestParameters: ReplaceCoreV1NamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Endpoints> {
        const response = await this.replaceCoreV1NamespacedEndpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified Event
     */
    async replaceCoreV1NamespacedEventRaw(requestParameters: ReplaceCoreV1NamespacedEventRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Event>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedEvent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedEvent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedEvent.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1EventToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EventFromJSON(jsonValue));
    }

    /**
     * replace the specified Event
     */
    async replaceCoreV1NamespacedEvent(requestParameters: ReplaceCoreV1NamespacedEventRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Event> {
        const response = await this.replaceCoreV1NamespacedEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified LimitRange
     */
    async replaceCoreV1NamespacedLimitRangeRaw(requestParameters: ReplaceCoreV1NamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1LimitRange>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedLimitRange.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1LimitRangeToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1LimitRangeFromJSON(jsonValue));
    }

    /**
     * replace the specified LimitRange
     */
    async replaceCoreV1NamespacedLimitRange(requestParameters: ReplaceCoreV1NamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1LimitRange> {
        const response = await this.replaceCoreV1NamespacedLimitRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified PersistentVolumeClaim
     */
    async replaceCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters: ReplaceCoreV1NamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedPersistentVolumeClaim.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PersistentVolumeClaimToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * replace the specified PersistentVolumeClaim
     */
    async replaceCoreV1NamespacedPersistentVolumeClaim(requestParameters: ReplaceCoreV1NamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
        const response = await this.replaceCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified PersistentVolumeClaim
     */
    async replaceCoreV1NamespacedPersistentVolumeClaimStatusRaw(requestParameters: ReplaceCoreV1NamespacedPersistentVolumeClaimStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PersistentVolumeClaimToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * replace status of the specified PersistentVolumeClaim
     */
    async replaceCoreV1NamespacedPersistentVolumeClaimStatus(requestParameters: ReplaceCoreV1NamespacedPersistentVolumeClaimStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
        const response = await this.replaceCoreV1NamespacedPersistentVolumeClaimStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified Pod
     */
    async replaceCoreV1NamespacedPodRaw(requestParameters: ReplaceCoreV1NamespacedPodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedPod.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedPod.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedPod.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PodToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * replace the specified Pod
     */
    async replaceCoreV1NamespacedPod(requestParameters: ReplaceCoreV1NamespacedPodRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.replaceCoreV1NamespacedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace ephemeralcontainers of the specified Pod
     */
    async replaceCoreV1NamespacedPodEphemeralcontainersRaw(requestParameters: ReplaceCoreV1NamespacedPodEphemeralcontainersRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedPodEphemeralcontainers.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedPodEphemeralcontainers.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedPodEphemeralcontainers.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PodToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * replace ephemeralcontainers of the specified Pod
     */
    async replaceCoreV1NamespacedPodEphemeralcontainers(requestParameters: ReplaceCoreV1NamespacedPodEphemeralcontainersRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.replaceCoreV1NamespacedPodEphemeralcontainersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified Pod
     */
    async replaceCoreV1NamespacedPodStatusRaw(requestParameters: ReplaceCoreV1NamespacedPodStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedPodStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedPodStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedPodStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PodToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Pod
     */
    async replaceCoreV1NamespacedPodStatus(requestParameters: ReplaceCoreV1NamespacedPodStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.replaceCoreV1NamespacedPodStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified PodTemplate
     */
    async replaceCoreV1NamespacedPodTemplateRaw(requestParameters: ReplaceCoreV1NamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodTemplate>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedPodTemplate.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PodTemplateToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodTemplateFromJSON(jsonValue));
    }

    /**
     * replace the specified PodTemplate
     */
    async replaceCoreV1NamespacedPodTemplate(requestParameters: ReplaceCoreV1NamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PodTemplate> {
        const response = await this.replaceCoreV1NamespacedPodTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified ReplicationController
     */
    async replaceCoreV1NamespacedReplicationControllerRaw(requestParameters: ReplaceCoreV1NamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedReplicationController.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ReplicationControllerToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * replace the specified ReplicationController
     */
    async replaceCoreV1NamespacedReplicationController(requestParameters: ReplaceCoreV1NamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ReplicationController> {
        const response = await this.replaceCoreV1NamespacedReplicationControllerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace scale of the specified ReplicationController
     */
    async replaceCoreV1NamespacedReplicationControllerScaleRaw(requestParameters: ReplaceCoreV1NamespacedReplicationControllerScaleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiAutoscalingV1Scale>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedReplicationControllerScale.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedReplicationControllerScale.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedReplicationControllerScale.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiAutoscalingV1ScaleToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiAutoscalingV1ScaleFromJSON(jsonValue));
    }

    /**
     * replace scale of the specified ReplicationController
     */
    async replaceCoreV1NamespacedReplicationControllerScale(requestParameters: ReplaceCoreV1NamespacedReplicationControllerScaleRequest, initOverrides?: RequestInit): Promise<IoK8sApiAutoscalingV1Scale> {
        const response = await this.replaceCoreV1NamespacedReplicationControllerScaleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified ReplicationController
     */
    async replaceCoreV1NamespacedReplicationControllerStatusRaw(requestParameters: ReplaceCoreV1NamespacedReplicationControllerStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedReplicationControllerStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedReplicationControllerStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedReplicationControllerStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ReplicationControllerToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * replace status of the specified ReplicationController
     */
    async replaceCoreV1NamespacedReplicationControllerStatus(requestParameters: ReplaceCoreV1NamespacedReplicationControllerStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ReplicationController> {
        const response = await this.replaceCoreV1NamespacedReplicationControllerStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified ResourceQuota
     */
    async replaceCoreV1NamespacedResourceQuotaRaw(requestParameters: ReplaceCoreV1NamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedResourceQuota.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ResourceQuotaToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * replace the specified ResourceQuota
     */
    async replaceCoreV1NamespacedResourceQuota(requestParameters: ReplaceCoreV1NamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ResourceQuota> {
        const response = await this.replaceCoreV1NamespacedResourceQuotaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified ResourceQuota
     */
    async replaceCoreV1NamespacedResourceQuotaStatusRaw(requestParameters: ReplaceCoreV1NamespacedResourceQuotaStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedResourceQuotaStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedResourceQuotaStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedResourceQuotaStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ResourceQuotaToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * replace status of the specified ResourceQuota
     */
    async replaceCoreV1NamespacedResourceQuotaStatus(requestParameters: ReplaceCoreV1NamespacedResourceQuotaStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ResourceQuota> {
        const response = await this.replaceCoreV1NamespacedResourceQuotaStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified Secret
     */
    async replaceCoreV1NamespacedSecretRaw(requestParameters: ReplaceCoreV1NamespacedSecretRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Secret>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedSecret.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedSecret.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1SecretToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1SecretFromJSON(jsonValue));
    }

    /**
     * replace the specified Secret
     */
    async replaceCoreV1NamespacedSecret(requestParameters: ReplaceCoreV1NamespacedSecretRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Secret> {
        const response = await this.replaceCoreV1NamespacedSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified Service
     */
    async replaceCoreV1NamespacedServiceRaw(requestParameters: ReplaceCoreV1NamespacedServiceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedService.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedService.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedService.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ServiceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceFromJSON(jsonValue));
    }

    /**
     * replace the specified Service
     */
    async replaceCoreV1NamespacedService(requestParameters: ReplaceCoreV1NamespacedServiceRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Service> {
        const response = await this.replaceCoreV1NamespacedServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified ServiceAccount
     */
    async replaceCoreV1NamespacedServiceAccountRaw(requestParameters: ReplaceCoreV1NamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceAccount>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedServiceAccount.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ServiceAccountToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * replace the specified ServiceAccount
     */
    async replaceCoreV1NamespacedServiceAccount(requestParameters: ReplaceCoreV1NamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1ServiceAccount> {
        const response = await this.replaceCoreV1NamespacedServiceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified Service
     */
    async replaceCoreV1NamespacedServiceStatusRaw(requestParameters: ReplaceCoreV1NamespacedServiceStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedServiceStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedServiceStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedServiceStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ServiceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Service
     */
    async replaceCoreV1NamespacedServiceStatus(requestParameters: ReplaceCoreV1NamespacedServiceStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Service> {
        const response = await this.replaceCoreV1NamespacedServiceStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified Node
     */
    async replaceCoreV1NodeRaw(requestParameters: ReplaceCoreV1NodeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1Node.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1Node.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1NodeToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeFromJSON(jsonValue));
    }

    /**
     * replace the specified Node
     */
    async replaceCoreV1Node(requestParameters: ReplaceCoreV1NodeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Node> {
        const response = await this.replaceCoreV1NodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified Node
     */
    async replaceCoreV1NodeStatusRaw(requestParameters: ReplaceCoreV1NodeStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NodeStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NodeStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1NodeToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Node
     */
    async replaceCoreV1NodeStatus(requestParameters: ReplaceCoreV1NodeStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1Node> {
        const response = await this.replaceCoreV1NodeStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified PersistentVolume
     */
    async replaceCoreV1PersistentVolumeRaw(requestParameters: ReplaceCoreV1PersistentVolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1PersistentVolume.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1PersistentVolume.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PersistentVolumeToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * replace the specified PersistentVolume
     */
    async replaceCoreV1PersistentVolume(requestParameters: ReplaceCoreV1PersistentVolumeRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolume> {
        const response = await this.replaceCoreV1PersistentVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified PersistentVolume
     */
    async replaceCoreV1PersistentVolumeStatusRaw(requestParameters: ReplaceCoreV1PersistentVolumeStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1PersistentVolumeStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1PersistentVolumeStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.fieldValidation !== undefined) {
            queryParameters['fieldValidation'] = requestParameters.fieldValidation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PersistentVolumeToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * replace status of the specified PersistentVolume
     */
    async replaceCoreV1PersistentVolumeStatus(requestParameters: ReplaceCoreV1PersistentVolumeStatusRequest, initOverrides?: RequestInit): Promise<IoK8sApiCoreV1PersistentVolume> {
        const response = await this.replaceCoreV1PersistentVolumeStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ConfigMap. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ConfigMapListForAllNamespacesRaw(requestParameters: WatchCoreV1ConfigMapListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/configmaps`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ConfigMap. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ConfigMapListForAllNamespaces(requestParameters: WatchCoreV1ConfigMapListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1ConfigMapListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Endpoints. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1EndpointsListForAllNamespacesRaw(requestParameters: WatchCoreV1EndpointsListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/endpoints`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Endpoints. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1EndpointsListForAllNamespaces(requestParameters: WatchCoreV1EndpointsListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1EndpointsListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Event. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1EventListForAllNamespacesRaw(requestParameters: WatchCoreV1EventListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/events`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Event. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1EventListForAllNamespaces(requestParameters: WatchCoreV1EventListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1EventListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of LimitRange. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1LimitRangeListForAllNamespacesRaw(requestParameters: WatchCoreV1LimitRangeListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/limitranges`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of LimitRange. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1LimitRangeListForAllNamespaces(requestParameters: WatchCoreV1LimitRangeListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1LimitRangeListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch changes to an object of kind Namespace. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespaceRaw(requestParameters: WatchCoreV1NamespaceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1Namespace.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind Namespace. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1Namespace(requestParameters: WatchCoreV1NamespaceRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Namespace. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespaceListRaw(requestParameters: WatchCoreV1NamespaceListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Namespace. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespaceList(requestParameters: WatchCoreV1NamespaceListRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespaceListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch changes to an object of kind ConfigMap. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedConfigMapRaw(requestParameters: WatchCoreV1NamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedConfigMap.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind ConfigMap. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedConfigMap(requestParameters: WatchCoreV1NamespacedConfigMapRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedConfigMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ConfigMap. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedConfigMapListRaw(requestParameters: WatchCoreV1NamespacedConfigMapListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedConfigMapList.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/configmaps`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ConfigMap. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedConfigMapList(requestParameters: WatchCoreV1NamespacedConfigMapListRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedConfigMapListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch changes to an object of kind Endpoints. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedEndpointsRaw(requestParameters: WatchCoreV1NamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedEndpoints.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind Endpoints. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedEndpoints(requestParameters: WatchCoreV1NamespacedEndpointsRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedEndpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Endpoints. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedEndpointsListRaw(requestParameters: WatchCoreV1NamespacedEndpointsListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedEndpointsList.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/endpoints`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Endpoints. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedEndpointsList(requestParameters: WatchCoreV1NamespacedEndpointsListRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedEndpointsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch changes to an object of kind Event. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedEventRaw(requestParameters: WatchCoreV1NamespacedEventRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedEvent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedEvent.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind Event. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedEvent(requestParameters: WatchCoreV1NamespacedEventRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Event. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedEventListRaw(requestParameters: WatchCoreV1NamespacedEventListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedEventList.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/events`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Event. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedEventList(requestParameters: WatchCoreV1NamespacedEventListRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedEventListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch changes to an object of kind LimitRange. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedLimitRangeRaw(requestParameters: WatchCoreV1NamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedLimitRange.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind LimitRange. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedLimitRange(requestParameters: WatchCoreV1NamespacedLimitRangeRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedLimitRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of LimitRange. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedLimitRangeListRaw(requestParameters: WatchCoreV1NamespacedLimitRangeListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedLimitRangeList.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/limitranges`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of LimitRange. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedLimitRangeList(requestParameters: WatchCoreV1NamespacedLimitRangeListRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedLimitRangeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch changes to an object of kind PersistentVolumeClaim. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters: WatchCoreV1NamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedPersistentVolumeClaim.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind PersistentVolumeClaim. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedPersistentVolumeClaim(requestParameters: WatchCoreV1NamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of PersistentVolumeClaim. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedPersistentVolumeClaimListRaw(requestParameters: WatchCoreV1NamespacedPersistentVolumeClaimListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedPersistentVolumeClaimList.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of PersistentVolumeClaim. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedPersistentVolumeClaimList(requestParameters: WatchCoreV1NamespacedPersistentVolumeClaimListRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedPersistentVolumeClaimListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch changes to an object of kind Pod. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedPodRaw(requestParameters: WatchCoreV1NamespacedPodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedPod.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedPod.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind Pod. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedPod(requestParameters: WatchCoreV1NamespacedPodRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Pod. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedPodListRaw(requestParameters: WatchCoreV1NamespacedPodListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedPodList.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/pods`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Pod. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedPodList(requestParameters: WatchCoreV1NamespacedPodListRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedPodListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch changes to an object of kind PodTemplate. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedPodTemplateRaw(requestParameters: WatchCoreV1NamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedPodTemplate.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind PodTemplate. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedPodTemplate(requestParameters: WatchCoreV1NamespacedPodTemplateRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedPodTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of PodTemplate. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedPodTemplateListRaw(requestParameters: WatchCoreV1NamespacedPodTemplateListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedPodTemplateList.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/podtemplates`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of PodTemplate. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedPodTemplateList(requestParameters: WatchCoreV1NamespacedPodTemplateListRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedPodTemplateListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch changes to an object of kind ReplicationController. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedReplicationControllerRaw(requestParameters: WatchCoreV1NamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedReplicationController.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind ReplicationController. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedReplicationController(requestParameters: WatchCoreV1NamespacedReplicationControllerRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedReplicationControllerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ReplicationController. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedReplicationControllerListRaw(requestParameters: WatchCoreV1NamespacedReplicationControllerListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedReplicationControllerList.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/replicationcontrollers`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ReplicationController. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedReplicationControllerList(requestParameters: WatchCoreV1NamespacedReplicationControllerListRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedReplicationControllerListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch changes to an object of kind ResourceQuota. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedResourceQuotaRaw(requestParameters: WatchCoreV1NamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedResourceQuota.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind ResourceQuota. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedResourceQuota(requestParameters: WatchCoreV1NamespacedResourceQuotaRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedResourceQuotaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ResourceQuota. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedResourceQuotaListRaw(requestParameters: WatchCoreV1NamespacedResourceQuotaListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedResourceQuotaList.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/resourcequotas`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ResourceQuota. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedResourceQuotaList(requestParameters: WatchCoreV1NamespacedResourceQuotaListRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedResourceQuotaListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch changes to an object of kind Secret. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedSecretRaw(requestParameters: WatchCoreV1NamespacedSecretRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedSecret.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind Secret. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedSecret(requestParameters: WatchCoreV1NamespacedSecretRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Secret. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedSecretListRaw(requestParameters: WatchCoreV1NamespacedSecretListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedSecretList.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/secrets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Secret. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedSecretList(requestParameters: WatchCoreV1NamespacedSecretListRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedSecretListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch changes to an object of kind Service. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedServiceRaw(requestParameters: WatchCoreV1NamespacedServiceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedService.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedService.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind Service. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedService(requestParameters: WatchCoreV1NamespacedServiceRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch changes to an object of kind ServiceAccount. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedServiceAccountRaw(requestParameters: WatchCoreV1NamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedServiceAccount.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind ServiceAccount. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedServiceAccount(requestParameters: WatchCoreV1NamespacedServiceAccountRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedServiceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ServiceAccount. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedServiceAccountListRaw(requestParameters: WatchCoreV1NamespacedServiceAccountListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedServiceAccountList.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/serviceaccounts`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ServiceAccount. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedServiceAccountList(requestParameters: WatchCoreV1NamespacedServiceAccountListRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedServiceAccountListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Service. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedServiceListRaw(requestParameters: WatchCoreV1NamespacedServiceListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedServiceList.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/services`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Service. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedServiceList(requestParameters: WatchCoreV1NamespacedServiceListRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedServiceListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch changes to an object of kind Node. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NodeRaw(requestParameters: WatchCoreV1NodeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1Node.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind Node. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1Node(requestParameters: WatchCoreV1NodeRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Node. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NodeListRaw(requestParameters: WatchCoreV1NodeListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/nodes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Node. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NodeList(requestParameters: WatchCoreV1NodeListRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NodeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch changes to an object of kind PersistentVolume. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1PersistentVolumeRaw(requestParameters: WatchCoreV1PersistentVolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1PersistentVolume.');
        }

        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind PersistentVolume. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1PersistentVolume(requestParameters: WatchCoreV1PersistentVolumeRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1PersistentVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of PersistentVolumeClaim. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PersistentVolumeClaimListForAllNamespacesRaw(requestParameters: WatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/persistentvolumeclaims`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of PersistentVolumeClaim. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PersistentVolumeClaimListForAllNamespaces(requestParameters: WatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1PersistentVolumeClaimListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of PersistentVolume. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PersistentVolumeListRaw(requestParameters: WatchCoreV1PersistentVolumeListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/persistentvolumes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of PersistentVolume. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PersistentVolumeList(requestParameters: WatchCoreV1PersistentVolumeListRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1PersistentVolumeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Pod. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PodListForAllNamespacesRaw(requestParameters: WatchCoreV1PodListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/pods`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Pod. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PodListForAllNamespaces(requestParameters: WatchCoreV1PodListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1PodListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of PodTemplate. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PodTemplateListForAllNamespacesRaw(requestParameters: WatchCoreV1PodTemplateListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/podtemplates`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of PodTemplate. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PodTemplateListForAllNamespaces(requestParameters: WatchCoreV1PodTemplateListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1PodTemplateListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ReplicationController. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ReplicationControllerListForAllNamespacesRaw(requestParameters: WatchCoreV1ReplicationControllerListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/replicationcontrollers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ReplicationController. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ReplicationControllerListForAllNamespaces(requestParameters: WatchCoreV1ReplicationControllerListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1ReplicationControllerListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ResourceQuota. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ResourceQuotaListForAllNamespacesRaw(requestParameters: WatchCoreV1ResourceQuotaListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/resourcequotas`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ResourceQuota. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ResourceQuotaListForAllNamespaces(requestParameters: WatchCoreV1ResourceQuotaListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1ResourceQuotaListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Secret. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1SecretListForAllNamespacesRaw(requestParameters: WatchCoreV1SecretListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/secrets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Secret. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1SecretListForAllNamespaces(requestParameters: WatchCoreV1SecretListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1SecretListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ServiceAccount. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ServiceAccountListForAllNamespacesRaw(requestParameters: WatchCoreV1ServiceAccountListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/serviceaccounts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ServiceAccount. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ServiceAccountListForAllNamespaces(requestParameters: WatchCoreV1ServiceAccountListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1ServiceAccountListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Service. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ServiceListForAllNamespacesRaw(requestParameters: WatchCoreV1ServiceListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.resourceVersionMatch !== undefined) {
            queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch;
        }

        if (requestParameters.sendInitialEvents !== undefined) {
            queryParameters['sendInitialEvents'] = requestParameters.sendInitialEvents;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/services`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Service. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ServiceListForAllNamespaces(requestParameters: WatchCoreV1ServiceListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1ServiceListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
