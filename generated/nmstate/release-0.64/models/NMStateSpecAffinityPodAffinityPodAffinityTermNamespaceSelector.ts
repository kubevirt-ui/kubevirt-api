/* tslint:disable */
/* eslint-disable */
/**
 * 
 * 
 *
 * 
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import {
    NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressions,
    NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressionsFromJSON,
    NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressionsFromJSONTyped,
    NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressionsToJSON,
} from './';

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 * @export
 * @interface NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelector
 */
export interface NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelector {
    /**
     * matchExpressions is a list of label selector requirements. The requirements are ANDed.
     * @type {Array<NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressions>}
     * @memberof NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelector
     */
    matchExpressions?: Array<NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressions>;
    /**
     * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
     * @type {{ [key: string]: string; }}
     * @memberof NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelector
     */
    matchLabels?: { [key: string]: string; };
}

export function NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelectorFromJSON(json: any): NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelector {
    return NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelectorFromJSONTyped(json, false);
}

export function NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelectorFromJSONTyped(json: any, ignoreDiscriminator: boolean): NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelector {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'matchExpressions': !exists(json, 'matchExpressions') ? undefined : ((json['matchExpressions'] as Array<any>).map(NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressionsFromJSON)),
        'matchLabels': !exists(json, 'matchLabels') ? undefined : json['matchLabels'],
    };
}

export function NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelectorToJSON(value?: NMStateSpecAffinityPodAffinityPodAffinityTermNamespaceSelector | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'matchExpressions': value.matchExpressions === undefined ? undefined : ((value.matchExpressions as Array<any>).map(NMStateSpecAffinityPodAffinityPodAffinityTermLabelSelectorMatchExpressionsToJSON)),
        'matchLabels': value.matchLabels,
    };
}

