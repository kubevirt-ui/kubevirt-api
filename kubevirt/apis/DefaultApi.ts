/* tslint:disable */
/* eslint-disable */
/**
 * KubeVirt API
 * This is KubeVirt API an add-on for Kubernetes.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: kubevirt-dev@googlegroups.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import {
  K8sIoApimachineryPkgApisMetaV1APIGroup,
  K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON,
  K8sIoApimachineryPkgApisMetaV1APIGroupList,
  K8sIoApimachineryPkgApisMetaV1APIGroupListFromJSON,
  K8sIoApimachineryPkgApisMetaV1APIResourceList,
  K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON,
  K8sIoApimachineryPkgApisMetaV1DeleteOptions,
  K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON,
  K8sIoApimachineryPkgApisMetaV1RootPaths,
  K8sIoApimachineryPkgApisMetaV1RootPathsFromJSON,
  K8sIoApimachineryPkgApisMetaV1Status,
  K8sIoApimachineryPkgApisMetaV1StatusFromJSON,
  K8sIoApimachineryPkgApisMetaV1WatchEvent,
  K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON,
  V1AddVolumeOptions,
  V1AddVolumeOptionsToJSON,
  V1FreezeUnfreezeTimeout,
  V1FreezeUnfreezeTimeoutToJSON,
  V1KubeVirt,
  V1KubeVirtFromJSON,
  V1KubeVirtList,
  V1KubeVirtListFromJSON,
  V1KubeVirtToJSON,
  V1MigrateOptions,
  V1MigrateOptionsToJSON,
  V1PauseOptions,
  V1PauseOptionsToJSON,
  V1RemoveVolumeOptions,
  V1RemoveVolumeOptionsToJSON,
  V1RestartOptions,
  V1RestartOptionsToJSON,
  V1StartOptions,
  V1StartOptionsToJSON,
  V1StopOptions,
  V1StopOptionsToJSON,
  V1UnpauseOptions,
  V1UnpauseOptionsToJSON,
  V1VirtualMachine,
  V1VirtualMachineFromJSON,
  V1VirtualMachineInstance,
  V1VirtualMachineInstanceFileSystemList,
  V1VirtualMachineInstanceFileSystemListFromJSON,
  V1VirtualMachineInstanceFromJSON,
  V1VirtualMachineInstanceGuestAgentInfo,
  V1VirtualMachineInstanceGuestAgentInfoFromJSON,
  V1VirtualMachineInstanceGuestOSUserList,
  V1VirtualMachineInstanceGuestOSUserListFromJSON,
  V1VirtualMachineInstanceList,
  V1VirtualMachineInstanceListFromJSON,
  V1VirtualMachineInstanceMigration,
  V1VirtualMachineInstanceMigrationFromJSON,
  V1VirtualMachineInstanceMigrationList,
  V1VirtualMachineInstanceMigrationListFromJSON,
  V1VirtualMachineInstanceMigrationToJSON,
  V1VirtualMachineInstancePreset,
  V1VirtualMachineInstancePresetFromJSON,
  V1VirtualMachineInstancePresetList,
  V1VirtualMachineInstancePresetListFromJSON,
  V1VirtualMachineInstancePresetToJSON,
  V1VirtualMachineInstanceReplicaSet,
  V1VirtualMachineInstanceReplicaSetFromJSON,
  V1VirtualMachineInstanceReplicaSetList,
  V1VirtualMachineInstanceReplicaSetListFromJSON,
  V1VirtualMachineInstanceReplicaSetToJSON,
  V1VirtualMachineInstanceToJSON,
  V1VirtualMachineList,
  V1VirtualMachineListFromJSON,
  V1VirtualMachineMemoryDumpRequest,
  V1VirtualMachineMemoryDumpRequestToJSON,
  V1VirtualMachineToJSON,
  V1alpha1MigrationPolicy,
  V1alpha1MigrationPolicyFromJSON,
  V1alpha1MigrationPolicyList,
  V1alpha1MigrationPolicyListFromJSON,
  V1alpha1MigrationPolicyToJSON,
  V1alpha1VirtualMachineClone,
  V1alpha1VirtualMachineCloneFromJSON,
  V1alpha1VirtualMachineCloneList,
  V1alpha1VirtualMachineCloneListFromJSON,
  V1alpha1VirtualMachineCloneToJSON,
  V1alpha1VirtualMachineClusterFlavor,
  V1alpha1VirtualMachineClusterFlavorFromJSON,
  V1alpha1VirtualMachineClusterFlavorList,
  V1alpha1VirtualMachineClusterFlavorListFromJSON,
  V1alpha1VirtualMachineClusterFlavorToJSON,
  V1alpha1VirtualMachineClusterPreference,
  V1alpha1VirtualMachineClusterPreferenceFromJSON,
  V1alpha1VirtualMachineClusterPreferenceList,
  V1alpha1VirtualMachineClusterPreferenceListFromJSON,
  V1alpha1VirtualMachineClusterPreferenceToJSON,
  V1alpha1VirtualMachineExport,
  V1alpha1VirtualMachineExportFromJSON,
  V1alpha1VirtualMachineExportList,
  V1alpha1VirtualMachineExportListFromJSON,
  V1alpha1VirtualMachineExportToJSON,
  V1alpha1VirtualMachineFlavor,
  V1alpha1VirtualMachineFlavorFromJSON,
  V1alpha1VirtualMachineFlavorList,
  V1alpha1VirtualMachineFlavorListFromJSON,
  V1alpha1VirtualMachineFlavorToJSON,
  V1alpha1VirtualMachinePool,
  V1alpha1VirtualMachinePoolFromJSON,
  V1alpha1VirtualMachinePoolList,
  V1alpha1VirtualMachinePoolListFromJSON,
  V1alpha1VirtualMachinePoolToJSON,
  V1alpha1VirtualMachinePreference,
  V1alpha1VirtualMachinePreferenceFromJSON,
  V1alpha1VirtualMachinePreferenceList,
  V1alpha1VirtualMachinePreferenceListFromJSON,
  V1alpha1VirtualMachinePreferenceToJSON,
  V1alpha1VirtualMachineRestore,
  V1alpha1VirtualMachineRestoreFromJSON,
  V1alpha1VirtualMachineRestoreList,
  V1alpha1VirtualMachineRestoreListFromJSON,
  V1alpha1VirtualMachineRestoreToJSON,
  V1alpha1VirtualMachineSnapshot,
  V1alpha1VirtualMachineSnapshotContent,
  V1alpha1VirtualMachineSnapshotContentFromJSON,
  V1alpha1VirtualMachineSnapshotContentList,
  V1alpha1VirtualMachineSnapshotContentListFromJSON,
  V1alpha1VirtualMachineSnapshotContentToJSON,
  V1alpha1VirtualMachineSnapshotFromJSON,
  V1alpha1VirtualMachineSnapshotList,
  V1alpha1VirtualMachineSnapshotListFromJSON,
  V1alpha1VirtualMachineSnapshotToJSON,
} from '../models';

export interface CreateMigrationPolicyRequest {
  body: V1alpha1MigrationPolicy;
}

export interface CreateNamespacedKubeVirtRequest {
  namespace: string;
  body: V1KubeVirt;
}

export interface CreateNamespacedVirtualMachineRequest {
  namespace: string;
  body: V1VirtualMachine;
}

export interface CreateNamespacedVirtualMachineExportRequest {
  namespace: string;
  body: V1alpha1VirtualMachineExport;
}

export interface CreateNamespacedVirtualMachineFlavorRequest {
  namespace: string;
  body: V1alpha1VirtualMachineFlavor;
}

export interface CreateNamespacedVirtualMachineInstanceRequest {
  namespace: string;
  body: V1VirtualMachineInstance;
}

export interface CreateNamespacedVirtualMachineInstanceMigrationRequest {
  namespace: string;
  body: V1VirtualMachineInstanceMigration;
}

export interface CreateNamespacedVirtualMachineInstancePresetRequest {
  namespace: string;
  body: V1VirtualMachineInstancePreset;
}

export interface CreateNamespacedVirtualMachineInstanceReplicaSetRequest {
  namespace: string;
  body: V1VirtualMachineInstanceReplicaSet;
}

export interface CreateNamespacedVirtualMachinePoolRequest {
  namespace: string;
  body: V1alpha1VirtualMachinePool;
}

export interface CreateNamespacedVirtualMachinePreferenceRequest {
  namespace: string;
  body: V1alpha1VirtualMachinePreference;
}

export interface CreateNamespacedVirtualMachineRestoreRequest {
  namespace: string;
  body: V1alpha1VirtualMachineRestore;
}

export interface CreateNamespacedVirtualMachineSnapshotRequest {
  namespace: string;
  body: V1alpha1VirtualMachineSnapshot;
}

export interface CreateNamespacedVirtualMachineSnapshotContentRequest {
  namespace: string;
  body: V1alpha1VirtualMachineSnapshotContent;
}

export interface CreateVirtualMachineCloneRequest {
  body: V1alpha1VirtualMachineClone;
}

export interface CreateVirtualMachineClusterFlavorRequest {
  body: V1alpha1VirtualMachineClusterFlavor;
}

export interface CreateVirtualMachineClusterPreferenceRequest {
  body: V1alpha1VirtualMachineClusterPreference;
}

export interface DeleteCollectionMigrationPolicyRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionNamespacedKubeVirtRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineExportRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineFlavorRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineInstanceRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineInstanceMigrationRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineInstancePresetRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineInstanceReplicaSetRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachinePoolRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachinePreferenceRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineRestoreRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineSnapshotRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineSnapshotContentRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionVirtualMachineCloneRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionVirtualMachineClusterFlavorRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteCollectionVirtualMachineClusterPreferenceRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface DeleteMigrationPolicyRequest {
  name: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteNamespacedKubeVirtRequest {
  name: string;
  namespace: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineRequest {
  name: string;
  namespace: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineExportRequest {
  name: string;
  namespace: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineFlavorRequest {
  name: string;
  namespace: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineInstanceRequest {
  name: string;
  namespace: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineInstanceMigrationRequest {
  name: string;
  namespace: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineInstancePresetRequest {
  name: string;
  namespace: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineInstanceReplicaSetRequest {
  name: string;
  namespace: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachinePoolRequest {
  name: string;
  namespace: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachinePreferenceRequest {
  name: string;
  namespace: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineRestoreRequest {
  name: string;
  namespace: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineSnapshotRequest {
  name: string;
  namespace: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineSnapshotContentRequest {
  name: string;
  namespace: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteVirtualMachineCloneRequest {
  name: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteVirtualMachineClusterFlavorRequest {
  name: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface DeleteVirtualMachineClusterPreferenceRequest {
  name: string;
  body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
  gracePeriodSeconds?: number;
  orphanDependents?: boolean;
  propagationPolicy?: string;
}

export interface ListKubeVirtForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListMigrationPolicyRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListNamespacedKubeVirtRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListNamespacedVirtualMachineRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListNamespacedVirtualMachineExportRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListNamespacedVirtualMachineFlavorRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListNamespacedVirtualMachineInstanceRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListNamespacedVirtualMachineInstanceMigrationRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListNamespacedVirtualMachineInstancePresetRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListNamespacedVirtualMachineInstanceReplicaSetRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListNamespacedVirtualMachinePoolRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListNamespacedVirtualMachinePreferenceRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListNamespacedVirtualMachineRestoreRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListNamespacedVirtualMachineSnapshotRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListNamespacedVirtualMachineSnapshotContentRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListVirtualMachineCloneRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListVirtualMachineClusterFlavorRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListVirtualMachineClusterPreferenceRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListVirtualMachineExportForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListVirtualMachineFlavorForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListVirtualMachineForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListVirtualMachineInstanceForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListVirtualMachineInstanceMigrationForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListVirtualMachineInstancePresetForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListVirtualMachineInstanceReplicaSetForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListVirtualMachinePoolForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListVirtualMachinePreferenceForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListVirtualMachineRestoreForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListVirtualMachineSnapshotContentForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface ListVirtualMachineSnapshotForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface PatchMigrationPolicyRequest {
  name: string;
  body: object;
}

export interface PatchNamespacedKubeVirtRequest {
  name: string;
  namespace: string;
  body: object;
}

export interface PatchNamespacedVirtualMachineRequest {
  name: string;
  namespace: string;
  body: object;
}

export interface PatchNamespacedVirtualMachineExportRequest {
  name: string;
  namespace: string;
  body: object;
}

export interface PatchNamespacedVirtualMachineFlavorRequest {
  name: string;
  namespace: string;
  body: object;
}

export interface PatchNamespacedVirtualMachineInstanceRequest {
  name: string;
  namespace: string;
  body: object;
}

export interface PatchNamespacedVirtualMachineInstanceMigrationRequest {
  name: string;
  namespace: string;
  body: object;
}

export interface PatchNamespacedVirtualMachineInstancePresetRequest {
  name: string;
  namespace: string;
  body: object;
}

export interface PatchNamespacedVirtualMachineInstanceReplicaSetRequest {
  name: string;
  namespace: string;
  body: object;
}

export interface PatchNamespacedVirtualMachinePoolRequest {
  name: string;
  namespace: string;
  body: object;
}

export interface PatchNamespacedVirtualMachinePreferenceRequest {
  name: string;
  namespace: string;
  body: object;
}

export interface PatchNamespacedVirtualMachineRestoreRequest {
  name: string;
  namespace: string;
  body: object;
}

export interface PatchNamespacedVirtualMachineSnapshotRequest {
  name: string;
  namespace: string;
  body: object;
}

export interface PatchNamespacedVirtualMachineSnapshotContentRequest {
  name: string;
  namespace: string;
  body: object;
}

export interface PatchVirtualMachineCloneRequest {
  name: string;
  body: object;
}

export interface PatchVirtualMachineClusterFlavorRequest {
  name: string;
  body: object;
}

export interface PatchVirtualMachineClusterPreferenceRequest {
  name: string;
  body: object;
}

export interface ReadMigrationPolicyRequest {
  name: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadNamespacedKubeVirtRequest {
  name: string;
  namespace: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadNamespacedVirtualMachineRequest {
  name: string;
  namespace: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadNamespacedVirtualMachineExportRequest {
  name: string;
  namespace: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadNamespacedVirtualMachineFlavorRequest {
  name: string;
  namespace: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadNamespacedVirtualMachineInstanceRequest {
  name: string;
  namespace: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadNamespacedVirtualMachineInstanceMigrationRequest {
  name: string;
  namespace: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadNamespacedVirtualMachineInstancePresetRequest {
  name: string;
  namespace: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadNamespacedVirtualMachineInstanceReplicaSetRequest {
  name: string;
  namespace: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadNamespacedVirtualMachinePoolRequest {
  name: string;
  namespace: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadNamespacedVirtualMachinePreferenceRequest {
  name: string;
  namespace: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadNamespacedVirtualMachineRestoreRequest {
  name: string;
  namespace: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadNamespacedVirtualMachineSnapshotRequest {
  name: string;
  namespace: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadNamespacedVirtualMachineSnapshotContentRequest {
  name: string;
  namespace: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadVirtualMachineCloneRequest {
  name: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadVirtualMachineClusterFlavorRequest {
  name: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReadVirtualMachineClusterPreferenceRequest {
  name: string;
  exact?: boolean;
  _export?: boolean;
}

export interface ReplaceMigrationPolicyRequest {
  name: string;
  body: V1alpha1MigrationPolicy;
}

export interface ReplaceNamespacedKubeVirtRequest {
  name: string;
  namespace: string;
  body: V1KubeVirt;
}

export interface ReplaceNamespacedVirtualMachineRequest {
  name: string;
  namespace: string;
  body: V1VirtualMachine;
}

export interface ReplaceNamespacedVirtualMachineExportRequest {
  name: string;
  namespace: string;
  body: V1alpha1VirtualMachineExport;
}

export interface ReplaceNamespacedVirtualMachineFlavorRequest {
  name: string;
  namespace: string;
  body: V1alpha1VirtualMachineFlavor;
}

export interface ReplaceNamespacedVirtualMachineInstanceRequest {
  name: string;
  namespace: string;
  body: V1VirtualMachineInstance;
}

export interface ReplaceNamespacedVirtualMachineInstanceMigrationRequest {
  name: string;
  namespace: string;
  body: V1VirtualMachineInstanceMigration;
}

export interface ReplaceNamespacedVirtualMachineInstancePresetRequest {
  name: string;
  namespace: string;
  body: V1VirtualMachineInstancePreset;
}

export interface ReplaceNamespacedVirtualMachineInstanceReplicaSetRequest {
  name: string;
  namespace: string;
  body: V1VirtualMachineInstanceReplicaSet;
}

export interface ReplaceNamespacedVirtualMachinePoolRequest {
  name: string;
  namespace: string;
  body: V1alpha1VirtualMachinePool;
}

export interface ReplaceNamespacedVirtualMachinePreferenceRequest {
  name: string;
  namespace: string;
  body: V1alpha1VirtualMachinePreference;
}

export interface ReplaceNamespacedVirtualMachineRestoreRequest {
  name: string;
  namespace: string;
  body: V1alpha1VirtualMachineRestore;
}

export interface ReplaceNamespacedVirtualMachineSnapshotRequest {
  name: string;
  namespace: string;
  body: V1alpha1VirtualMachineSnapshot;
}

export interface ReplaceNamespacedVirtualMachineSnapshotContentRequest {
  name: string;
  namespace: string;
  body: V1alpha1VirtualMachineSnapshotContent;
}

export interface ReplaceVirtualMachineCloneRequest {
  name: string;
  body: V1alpha1VirtualMachineClone;
}

export interface ReplaceVirtualMachineClusterFlavorRequest {
  name: string;
  body: V1alpha1VirtualMachineClusterFlavor;
}

export interface ReplaceVirtualMachineClusterPreferenceRequest {
  name: string;
  body: V1alpha1VirtualMachineClusterPreference;
}

export interface V1ConsoleRequest {
  name: string;
  namespace: string;
}

export interface V1FreezeRequest {
  name: string;
  namespace: string;
  body: V1FreezeUnfreezeTimeout;
}

export interface V1GuestosinfoRequest {
  name: string;
  namespace: string;
}

export interface V1MemoryDumpRequest {
  name: string;
  namespace: string;
  body: V1VirtualMachineMemoryDumpRequest;
}

export interface V1MigrateRequest {
  name: string;
  namespace: string;
  body: V1MigrateOptions;
}

export interface V1PauseRequest {
  name: string;
  namespace: string;
  body: V1PauseOptions;
}

export interface V1RemoveMemoryDumpRequest {
  name: string;
  namespace: string;
}

export interface V1RestartRequest {
  name: string;
  namespace: string;
  body?: V1RestartOptions;
}

export interface V1SoftRebootRequest {
  name: string;
  namespace: string;
}

export interface V1StartRequest {
  name: string;
  namespace: string;
  body: V1StartOptions;
}

export interface V1StopRequest {
  name: string;
  namespace: string;
  body?: V1StopOptions;
}

export interface V1TestRequest {
  name: string;
  namespace: string;
}

export interface V1UnfreezeRequest {
  name: string;
  namespace: string;
}

export interface V1UnpauseRequest {
  name: string;
  namespace: string;
  body: V1UnpauseOptions;
}

export interface V1VNCRequest {
  name: string;
  namespace: string;
}

export interface V1alpha3ConsoleRequest {
  name: string;
  namespace: string;
}

export interface V1alpha3FreezeRequest {
  name: string;
  namespace: string;
  body: V1FreezeUnfreezeTimeout;
}

export interface V1alpha3GuestosinfoRequest {
  name: string;
  namespace: string;
}

export interface V1alpha3MemoryDumpRequest {
  name: string;
  namespace: string;
  body: V1VirtualMachineMemoryDumpRequest;
}

export interface V1alpha3MigrateRequest {
  name: string;
  namespace: string;
  body: V1MigrateOptions;
}

export interface V1alpha3PauseRequest {
  name: string;
  namespace: string;
  body: V1PauseOptions;
}

export interface V1alpha3RemoveMemoryDumpRequest {
  name: string;
  namespace: string;
}

export interface V1alpha3RestartRequest {
  name: string;
  namespace: string;
  body?: V1RestartOptions;
}

export interface V1alpha3SoftRebootRequest {
  name: string;
  namespace: string;
}

export interface V1alpha3StartRequest {
  name: string;
  namespace: string;
  body: V1StartOptions;
}

export interface V1alpha3StopRequest {
  name: string;
  namespace: string;
  body?: V1StopOptions;
}

export interface V1alpha3TestRequest {
  name: string;
  namespace: string;
}

export interface V1alpha3UnfreezeRequest {
  name: string;
  namespace: string;
}

export interface V1alpha3UnpauseRequest {
  name: string;
  namespace: string;
  body: V1UnpauseOptions;
}

export interface V1alpha3VNCRequest {
  name: string;
  namespace: string;
}

export interface V1alpha3usbredirRequest {
  name: string;
  namespace: string;
}

export interface V1alpha3vmAddvolumeRequest {
  name: string;
  namespace: string;
  body: V1AddVolumeOptions;
}

export interface V1alpha3vmPortForwardRequest {
  name: string;
  namespace: string;
  port: string;
}

export interface V1alpha3vmPortForwardWithProtocolRequest {
  name: string;
  namespace: string;
  port: string;
  protocol: string;
}

export interface V1alpha3vmRemovevolumeRequest {
  name: string;
  namespace: string;
  body: V1RemoveVolumeOptions;
}

export interface V1alpha3vmiAddvolumeRequest {
  name: string;
  namespace: string;
  body: V1AddVolumeOptions;
}

export interface V1alpha3vmiPortForwardRequest {
  name: string;
  namespace: string;
  port: string;
}

export interface V1alpha3vmiPortForwardWithProtocolRequest {
  name: string;
  namespace: string;
  port: string;
  protocol: string;
}

export interface V1alpha3vmiRemovevolumeRequest {
  name: string;
  namespace: string;
  body: V1RemoveVolumeOptions;
}

export interface V1usbredirRequest {
  name: string;
  namespace: string;
}

export interface V1vmAddvolumeRequest {
  name: string;
  namespace: string;
  body: V1AddVolumeOptions;
}

export interface V1vmPortForwardRequest {
  name: string;
  namespace: string;
  port: string;
}

export interface V1vmPortForwardWithProtocolRequest {
  name: string;
  namespace: string;
  port: string;
  protocol: string;
}

export interface V1vmRemovevolumeRequest {
  name: string;
  namespace: string;
  body: V1RemoveVolumeOptions;
}

export interface V1vmiAddvolumeRequest {
  name: string;
  namespace: string;
  body: V1AddVolumeOptions;
}

export interface V1vmiPortForwardRequest {
  name: string;
  namespace: string;
  port: string;
}

export interface V1vmiPortForwardWithProtocolRequest {
  name: string;
  namespace: string;
  port: string;
  protocol: string;
}

export interface V1vmiRemovevolumeRequest {
  name: string;
  namespace: string;
  body: V1RemoveVolumeOptions;
}

export interface WatchKubeVirtListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchMigrationPolicyListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchNamespacedKubeVirtRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchNamespacedVirtualMachineRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchNamespacedVirtualMachineExportRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchNamespacedVirtualMachineFlavorRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchNamespacedVirtualMachineInstanceRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchNamespacedVirtualMachineInstanceMigrationRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchNamespacedVirtualMachineInstancePresetRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchNamespacedVirtualMachineInstanceReplicaSetRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchNamespacedVirtualMachinePoolRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchNamespacedVirtualMachinePreferenceRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchNamespacedVirtualMachineRestoreRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchNamespacedVirtualMachineSnapshotRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchNamespacedVirtualMachineSnapshotContentRequest {
  namespace: string;
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchVirtualMachineCloneListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchVirtualMachineClusterFlavorListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchVirtualMachineClusterPreferenceListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchVirtualMachineExportListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchVirtualMachineFlavorListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchVirtualMachineInstanceListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchVirtualMachineInstanceMigrationListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchVirtualMachineInstancePresetListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchVirtualMachineInstanceReplicaSetListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchVirtualMachineListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchVirtualMachinePoolListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchVirtualMachinePreferenceListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchVirtualMachineRestoreListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchVirtualMachineSnapshotContentListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

export interface WatchVirtualMachineSnapshotListForAllNamespacesRequest {
  _continue?: string;
  fieldSelector?: string;
  includeUninitialized?: boolean;
  labelSelector?: string;
  limit?: number;
  resourceVersion?: string;
  timeoutSeconds?: number;
  watch?: boolean;
}

/**
 *
 */
export class DefaultApi extends runtime.BaseAPI {
  /**
   * Create a MigrationPolicy object.
   */
  async createMigrationPolicyRaw(
    requestParameters: CreateMigrationPolicyRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1MigrationPolicy>> {
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createMigrationPolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1MigrationPolicyToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1MigrationPolicyFromJSON(jsonValue),
    );
  }

  /**
   * Create a MigrationPolicy object.
   */
  async createMigrationPolicy(
    requestParameters: CreateMigrationPolicyRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1MigrationPolicy> {
    const response = await this.createMigrationPolicyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Create a KubeVirt object.
   */
  async createNamespacedKubeVirtRaw(
    requestParameters: CreateNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1KubeVirt>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedKubeVirt.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedKubeVirt.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/kubevirt`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1KubeVirtToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => V1KubeVirtFromJSON(jsonValue));
  }

  /**
   * Create a KubeVirt object.
   */
  async createNamespacedKubeVirt(
    requestParameters: CreateNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<V1KubeVirt> {
    const response = await this.createNamespacedKubeVirtRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Create a VirtualMachine object.
   */
  async createNamespacedVirtualMachineRaw(
    requestParameters: CreateNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachine>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachine.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachine.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1VirtualMachineToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineFromJSON(jsonValue),
    );
  }

  /**
   * Create a VirtualMachine object.
   */
  async createNamespacedVirtualMachine(
    requestParameters: CreateNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachine> {
    const response = await this.createNamespacedVirtualMachineRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Create a VirtualMachineExport object.
   */
  async createNamespacedVirtualMachineExportRaw(
    requestParameters: CreateNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineExport>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineExport.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineExport.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/export.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineexports`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineExportToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineExportFromJSON(jsonValue),
    );
  }

  /**
   * Create a VirtualMachineExport object.
   */
  async createNamespacedVirtualMachineExport(
    requestParameters: CreateNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineExport> {
    const response = await this.createNamespacedVirtualMachineExportRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Create a VirtualMachineFlavor object.
   */
  async createNamespacedVirtualMachineFlavorRaw(
    requestParameters: CreateNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineFlavor>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineFlavor.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineFlavor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineflavors`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineFlavorToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineFlavorFromJSON(jsonValue),
    );
  }

  /**
   * Create a VirtualMachineFlavor object.
   */
  async createNamespacedVirtualMachineFlavor(
    requestParameters: CreateNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineFlavor> {
    const response = await this.createNamespacedVirtualMachineFlavorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Create a VirtualMachineInstance object.
   */
  async createNamespacedVirtualMachineInstanceRaw(
    requestParameters: CreateNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstance>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineInstance.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineInstance.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1VirtualMachineInstanceToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceFromJSON(jsonValue),
    );
  }

  /**
   * Create a VirtualMachineInstance object.
   */
  async createNamespacedVirtualMachineInstance(
    requestParameters: CreateNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstance> {
    const response = await this.createNamespacedVirtualMachineInstanceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Create a VirtualMachineInstanceMigration object.
   */
  async createNamespacedVirtualMachineInstanceMigrationRaw(
    requestParameters: CreateNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceMigration>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineInstanceMigration.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineInstanceMigration.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancemigrations`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1VirtualMachineInstanceMigrationToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceMigrationFromJSON(jsonValue),
    );
  }

  /**
   * Create a VirtualMachineInstanceMigration object.
   */
  async createNamespacedVirtualMachineInstanceMigration(
    requestParameters: CreateNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceMigration> {
    const response = await this.createNamespacedVirtualMachineInstanceMigrationRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Create a VirtualMachineInstancePreset object.
   */
  async createNamespacedVirtualMachineInstancePresetRaw(
    requestParameters: CreateNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstancePreset>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineInstancePreset.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineInstancePreset.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancepresets`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1VirtualMachineInstancePresetToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstancePresetFromJSON(jsonValue),
    );
  }

  /**
   * Create a VirtualMachineInstancePreset object.
   */
  async createNamespacedVirtualMachineInstancePreset(
    requestParameters: CreateNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstancePreset> {
    const response = await this.createNamespacedVirtualMachineInstancePresetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Create a VirtualMachineInstanceReplicaSet object.
   */
  async createNamespacedVirtualMachineInstanceReplicaSetRaw(
    requestParameters: CreateNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceReplicaSet>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineInstanceReplicaSet.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineInstanceReplicaSet.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancereplicasets`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1VirtualMachineInstanceReplicaSetToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceReplicaSetFromJSON(jsonValue),
    );
  }

  /**
   * Create a VirtualMachineInstanceReplicaSet object.
   */
  async createNamespacedVirtualMachineInstanceReplicaSet(
    requestParameters: CreateNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceReplicaSet> {
    const response = await this.createNamespacedVirtualMachineInstanceReplicaSetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Create a VirtualMachinePool object.
   */
  async createNamespacedVirtualMachinePoolRaw(
    requestParameters: CreateNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePool>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachinePool.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachinePool.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepools`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachinePoolToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachinePoolFromJSON(jsonValue),
    );
  }

  /**
   * Create a VirtualMachinePool object.
   */
  async createNamespacedVirtualMachinePool(
    requestParameters: CreateNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachinePool> {
    const response = await this.createNamespacedVirtualMachinePoolRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Create a VirtualMachinePreference object.
   */
  async createNamespacedVirtualMachinePreferenceRaw(
    requestParameters: CreateNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePreference>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachinePreference.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachinePreference.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepreferences`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachinePreferenceToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachinePreferenceFromJSON(jsonValue),
    );
  }

  /**
   * Create a VirtualMachinePreference object.
   */
  async createNamespacedVirtualMachinePreference(
    requestParameters: CreateNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachinePreference> {
    const response = await this.createNamespacedVirtualMachinePreferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Create a VirtualMachineRestore object.
   */
  async createNamespacedVirtualMachineRestoreRaw(
    requestParameters: CreateNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineRestore>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineRestore.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineRestore.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinerestores`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineRestoreToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineRestoreFromJSON(jsonValue),
    );
  }

  /**
   * Create a VirtualMachineRestore object.
   */
  async createNamespacedVirtualMachineRestore(
    requestParameters: CreateNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineRestore> {
    const response = await this.createNamespacedVirtualMachineRestoreRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Create a VirtualMachineSnapshot object.
   */
  async createNamespacedVirtualMachineSnapshotRaw(
    requestParameters: CreateNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineSnapshot>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineSnapshot.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineSnapshot.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshots`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineSnapshotToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineSnapshotFromJSON(jsonValue),
    );
  }

  /**
   * Create a VirtualMachineSnapshot object.
   */
  async createNamespacedVirtualMachineSnapshot(
    requestParameters: CreateNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineSnapshot> {
    const response = await this.createNamespacedVirtualMachineSnapshotRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Create a VirtualMachineSnapshotContent object.
   */
  async createNamespacedVirtualMachineSnapshotContentRaw(
    requestParameters: CreateNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineSnapshotContent>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineSnapshotContent.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineSnapshotContent.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshotcontents`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineSnapshotContentToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineSnapshotContentFromJSON(jsonValue),
    );
  }

  /**
   * Create a VirtualMachineSnapshotContent object.
   */
  async createNamespacedVirtualMachineSnapshotContent(
    requestParameters: CreateNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineSnapshotContent> {
    const response = await this.createNamespacedVirtualMachineSnapshotContentRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Create a VirtualMachineClone object.
   */
  async createVirtualMachineCloneRaw(
    requestParameters: CreateVirtualMachineCloneRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineClone>> {
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createVirtualMachineClone.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/clone.kubevirt.io/v1alpha1/virtualmachineclones`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineCloneToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineCloneFromJSON(jsonValue),
    );
  }

  /**
   * Create a VirtualMachineClone object.
   */
  async createVirtualMachineClone(
    requestParameters: CreateVirtualMachineCloneRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineClone> {
    const response = await this.createVirtualMachineCloneRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Create a VirtualMachineClusterFlavor object.
   */
  async createVirtualMachineClusterFlavorRaw(
    requestParameters: CreateVirtualMachineClusterFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineClusterFlavor>> {
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createVirtualMachineClusterFlavor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachineclusterflavors`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineClusterFlavorToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineClusterFlavorFromJSON(jsonValue),
    );
  }

  /**
   * Create a VirtualMachineClusterFlavor object.
   */
  async createVirtualMachineClusterFlavor(
    requestParameters: CreateVirtualMachineClusterFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineClusterFlavor> {
    const response = await this.createVirtualMachineClusterFlavorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Create a VirtualMachineClusterPreference object.
   */
  async createVirtualMachineClusterPreferenceRaw(
    requestParameters: CreateVirtualMachineClusterPreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineClusterPreference>> {
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling createVirtualMachineClusterPreference.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachineclusterpreferences`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineClusterPreferenceToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineClusterPreferenceFromJSON(jsonValue),
    );
  }

  /**
   * Create a VirtualMachineClusterPreference object.
   */
  async createVirtualMachineClusterPreference(
    requestParameters: CreateVirtualMachineClusterPreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineClusterPreference> {
    const response = await this.createVirtualMachineClusterPreferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of MigrationPolicy objects.
   */
  async deleteCollectionMigrationPolicyRaw(
    requestParameters: DeleteCollectionMigrationPolicyRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of MigrationPolicy objects.
   */
  async deleteCollectionMigrationPolicy(
    requestParameters: DeleteCollectionMigrationPolicyRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionMigrationPolicyRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of KubeVirt objects.
   */
  async deleteCollectionNamespacedKubeVirtRaw(
    requestParameters: DeleteCollectionNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/kubevirt`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of KubeVirt objects.
   */
  async deleteCollectionNamespacedKubeVirt(
    requestParameters: DeleteCollectionNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionNamespacedKubeVirtRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of VirtualMachine objects.
   */
  async deleteCollectionNamespacedVirtualMachineRaw(
    requestParameters: DeleteCollectionNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of VirtualMachine objects.
   */
  async deleteCollectionNamespacedVirtualMachine(
    requestParameters: DeleteCollectionNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionNamespacedVirtualMachineRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of VirtualMachineExport objects.
   */
  async deleteCollectionNamespacedVirtualMachineExportRaw(
    requestParameters: DeleteCollectionNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/export.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineexports`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of VirtualMachineExport objects.
   */
  async deleteCollectionNamespacedVirtualMachineExport(
    requestParameters: DeleteCollectionNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionNamespacedVirtualMachineExportRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of VirtualMachineFlavor objects.
   */
  async deleteCollectionNamespacedVirtualMachineFlavorRaw(
    requestParameters: DeleteCollectionNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineflavors`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of VirtualMachineFlavor objects.
   */
  async deleteCollectionNamespacedVirtualMachineFlavor(
    requestParameters: DeleteCollectionNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionNamespacedVirtualMachineFlavorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of VirtualMachineInstance objects.
   */
  async deleteCollectionNamespacedVirtualMachineInstanceRaw(
    requestParameters: DeleteCollectionNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of VirtualMachineInstance objects.
   */
  async deleteCollectionNamespacedVirtualMachineInstance(
    requestParameters: DeleteCollectionNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionNamespacedVirtualMachineInstanceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of VirtualMachineInstanceMigration objects.
   */
  async deleteCollectionNamespacedVirtualMachineInstanceMigrationRaw(
    requestParameters: DeleteCollectionNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancemigrations`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of VirtualMachineInstanceMigration objects.
   */
  async deleteCollectionNamespacedVirtualMachineInstanceMigration(
    requestParameters: DeleteCollectionNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionNamespacedVirtualMachineInstanceMigrationRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of VirtualMachineInstancePreset objects.
   */
  async deleteCollectionNamespacedVirtualMachineInstancePresetRaw(
    requestParameters: DeleteCollectionNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancepresets`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of VirtualMachineInstancePreset objects.
   */
  async deleteCollectionNamespacedVirtualMachineInstancePreset(
    requestParameters: DeleteCollectionNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionNamespacedVirtualMachineInstancePresetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of VirtualMachineInstanceReplicaSet objects.
   */
  async deleteCollectionNamespacedVirtualMachineInstanceReplicaSetRaw(
    requestParameters: DeleteCollectionNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancereplicasets`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of VirtualMachineInstanceReplicaSet objects.
   */
  async deleteCollectionNamespacedVirtualMachineInstanceReplicaSet(
    requestParameters: DeleteCollectionNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionNamespacedVirtualMachineInstanceReplicaSetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of VirtualMachinePool objects.
   */
  async deleteCollectionNamespacedVirtualMachinePoolRaw(
    requestParameters: DeleteCollectionNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepools`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of VirtualMachinePool objects.
   */
  async deleteCollectionNamespacedVirtualMachinePool(
    requestParameters: DeleteCollectionNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionNamespacedVirtualMachinePoolRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of VirtualMachinePreference objects.
   */
  async deleteCollectionNamespacedVirtualMachinePreferenceRaw(
    requestParameters: DeleteCollectionNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepreferences`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of VirtualMachinePreference objects.
   */
  async deleteCollectionNamespacedVirtualMachinePreference(
    requestParameters: DeleteCollectionNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionNamespacedVirtualMachinePreferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of VirtualMachineRestore objects.
   */
  async deleteCollectionNamespacedVirtualMachineRestoreRaw(
    requestParameters: DeleteCollectionNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinerestores`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of VirtualMachineRestore objects.
   */
  async deleteCollectionNamespacedVirtualMachineRestore(
    requestParameters: DeleteCollectionNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionNamespacedVirtualMachineRestoreRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of VirtualMachineSnapshot objects.
   */
  async deleteCollectionNamespacedVirtualMachineSnapshotRaw(
    requestParameters: DeleteCollectionNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshots`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of VirtualMachineSnapshot objects.
   */
  async deleteCollectionNamespacedVirtualMachineSnapshot(
    requestParameters: DeleteCollectionNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionNamespacedVirtualMachineSnapshotRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of VirtualMachineSnapshotContent objects.
   */
  async deleteCollectionNamespacedVirtualMachineSnapshotContentRaw(
    requestParameters: DeleteCollectionNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshotcontents`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of VirtualMachineSnapshotContent objects.
   */
  async deleteCollectionNamespacedVirtualMachineSnapshotContent(
    requestParameters: DeleteCollectionNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionNamespacedVirtualMachineSnapshotContentRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of VirtualMachineClone objects.
   */
  async deleteCollectionVirtualMachineCloneRaw(
    requestParameters: DeleteCollectionVirtualMachineCloneRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/clone.kubevirt.io/v1alpha1/virtualmachineclones`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of VirtualMachineClone objects.
   */
  async deleteCollectionVirtualMachineClone(
    requestParameters: DeleteCollectionVirtualMachineCloneRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionVirtualMachineCloneRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of VirtualMachineClusterFlavor objects.
   */
  async deleteCollectionVirtualMachineClusterFlavorRaw(
    requestParameters: DeleteCollectionVirtualMachineClusterFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachineclusterflavors`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of VirtualMachineClusterFlavor objects.
   */
  async deleteCollectionVirtualMachineClusterFlavor(
    requestParameters: DeleteCollectionVirtualMachineClusterFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionVirtualMachineClusterFlavorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a collection of VirtualMachineClusterPreference objects.
   */
  async deleteCollectionVirtualMachineClusterPreferenceRaw(
    requestParameters: DeleteCollectionVirtualMachineClusterPreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachineclusterpreferences`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a collection of VirtualMachineClusterPreference objects.
   */
  async deleteCollectionVirtualMachineClusterPreference(
    requestParameters: DeleteCollectionVirtualMachineClusterPreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteCollectionVirtualMachineClusterPreferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a MigrationPolicy object.
   */
  async deleteMigrationPolicyRaw(
    requestParameters: DeleteMigrationPolicyRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteMigrationPolicy.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteMigrationPolicy.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a MigrationPolicy object.
   */
  async deleteMigrationPolicy(
    requestParameters: DeleteMigrationPolicyRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteMigrationPolicyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Delete a KubeVirt object.
   */
  async deleteNamespacedKubeVirtRaw(
    requestParameters: DeleteNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedKubeVirt.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedKubeVirt.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteNamespacedKubeVirt.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/kubevirt/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a KubeVirt object.
   */
  async deleteNamespacedKubeVirt(
    requestParameters: DeleteNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteNamespacedKubeVirtRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Delete a VirtualMachine object.
   */
  async deleteNamespacedVirtualMachineRaw(
    requestParameters: DeleteNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachine.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachine.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachine.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a VirtualMachine object.
   */
  async deleteNamespacedVirtualMachine(
    requestParameters: DeleteNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteNamespacedVirtualMachineRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Delete a VirtualMachineExport object.
   */
  async deleteNamespacedVirtualMachineExportRaw(
    requestParameters: DeleteNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineExport.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineExport.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineExport.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/export.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineexports/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a VirtualMachineExport object.
   */
  async deleteNamespacedVirtualMachineExport(
    requestParameters: DeleteNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteNamespacedVirtualMachineExportRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a VirtualMachineFlavor object.
   */
  async deleteNamespacedVirtualMachineFlavorRaw(
    requestParameters: DeleteNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineFlavor.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineFlavor.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineFlavor.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineflavors/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a VirtualMachineFlavor object.
   */
  async deleteNamespacedVirtualMachineFlavor(
    requestParameters: DeleteNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteNamespacedVirtualMachineFlavorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a VirtualMachineInstance object.
   */
  async deleteNamespacedVirtualMachineInstanceRaw(
    requestParameters: DeleteNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineInstance.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineInstance.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineInstance.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a VirtualMachineInstance object.
   */
  async deleteNamespacedVirtualMachineInstance(
    requestParameters: DeleteNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteNamespacedVirtualMachineInstanceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a VirtualMachineInstanceMigration object.
   */
  async deleteNamespacedVirtualMachineInstanceMigrationRaw(
    requestParameters: DeleteNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineInstanceMigration.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineInstanceMigration.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineInstanceMigration.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancemigrations/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a VirtualMachineInstanceMigration object.
   */
  async deleteNamespacedVirtualMachineInstanceMigration(
    requestParameters: DeleteNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteNamespacedVirtualMachineInstanceMigrationRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a VirtualMachineInstancePreset object.
   */
  async deleteNamespacedVirtualMachineInstancePresetRaw(
    requestParameters: DeleteNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineInstancePreset.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineInstancePreset.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineInstancePreset.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancepresets/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a VirtualMachineInstancePreset object.
   */
  async deleteNamespacedVirtualMachineInstancePreset(
    requestParameters: DeleteNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteNamespacedVirtualMachineInstancePresetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a VirtualMachineInstanceReplicaSet object.
   */
  async deleteNamespacedVirtualMachineInstanceReplicaSetRaw(
    requestParameters: DeleteNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineInstanceReplicaSet.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineInstanceReplicaSet.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineInstanceReplicaSet.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancereplicasets/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a VirtualMachineInstanceReplicaSet object.
   */
  async deleteNamespacedVirtualMachineInstanceReplicaSet(
    requestParameters: DeleteNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteNamespacedVirtualMachineInstanceReplicaSetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a VirtualMachinePool object.
   */
  async deleteNamespacedVirtualMachinePoolRaw(
    requestParameters: DeleteNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachinePool.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachinePool.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachinePool.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepools/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a VirtualMachinePool object.
   */
  async deleteNamespacedVirtualMachinePool(
    requestParameters: DeleteNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteNamespacedVirtualMachinePoolRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a VirtualMachinePreference object.
   */
  async deleteNamespacedVirtualMachinePreferenceRaw(
    requestParameters: DeleteNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachinePreference.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachinePreference.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachinePreference.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepreferences/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a VirtualMachinePreference object.
   */
  async deleteNamespacedVirtualMachinePreference(
    requestParameters: DeleteNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteNamespacedVirtualMachinePreferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a VirtualMachineRestore object.
   */
  async deleteNamespacedVirtualMachineRestoreRaw(
    requestParameters: DeleteNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineRestore.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineRestore.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineRestore.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinerestores/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a VirtualMachineRestore object.
   */
  async deleteNamespacedVirtualMachineRestore(
    requestParameters: DeleteNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteNamespacedVirtualMachineRestoreRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a VirtualMachineSnapshot object.
   */
  async deleteNamespacedVirtualMachineSnapshotRaw(
    requestParameters: DeleteNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineSnapshot.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineSnapshot.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineSnapshot.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshots/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a VirtualMachineSnapshot object.
   */
  async deleteNamespacedVirtualMachineSnapshot(
    requestParameters: DeleteNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteNamespacedVirtualMachineSnapshotRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a VirtualMachineSnapshotContent object.
   */
  async deleteNamespacedVirtualMachineSnapshotContentRaw(
    requestParameters: DeleteNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineSnapshotContent.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineSnapshotContent.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineSnapshotContent.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshotcontents/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a VirtualMachineSnapshotContent object.
   */
  async deleteNamespacedVirtualMachineSnapshotContent(
    requestParameters: DeleteNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteNamespacedVirtualMachineSnapshotContentRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a VirtualMachineClone object.
   */
  async deleteVirtualMachineCloneRaw(
    requestParameters: DeleteVirtualMachineCloneRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteVirtualMachineClone.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteVirtualMachineClone.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/clone.kubevirt.io/v1alpha1/virtualmachineclones/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a VirtualMachineClone object.
   */
  async deleteVirtualMachineClone(
    requestParameters: DeleteVirtualMachineCloneRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteVirtualMachineCloneRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Delete a VirtualMachineClusterFlavor object.
   */
  async deleteVirtualMachineClusterFlavorRaw(
    requestParameters: DeleteVirtualMachineClusterFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteVirtualMachineClusterFlavor.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteVirtualMachineClusterFlavor.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachineclusterflavors/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a VirtualMachineClusterFlavor object.
   */
  async deleteVirtualMachineClusterFlavor(
    requestParameters: DeleteVirtualMachineClusterFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteVirtualMachineClusterFlavorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a VirtualMachineClusterPreference object.
   */
  async deleteVirtualMachineClusterPreferenceRaw(
    requestParameters: DeleteVirtualMachineClusterPreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling deleteVirtualMachineClusterPreference.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling deleteVirtualMachineClusterPreference.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
    }

    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents;
    }

    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachineclusterpreferences/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue),
    );
  }

  /**
   * Delete a VirtualMachineClusterPreference object.
   */
  async deleteVirtualMachineClusterPreference(
    requestParameters: DeleteVirtualMachineClusterPreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
    const response = await this.deleteVirtualMachineClusterPreferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Health endpoint
   */
  async func1Raw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/healthz`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Health endpoint
   */
  async func1(initOverrides?: RequestInit): Promise<void> {
    await this.func1Raw(initOverrides);
  }

  /**
   */
  async func7Raw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/openapi/v2`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async func7(initOverrides?: RequestInit): Promise<void> {
    await this.func7Raw(initOverrides);
  }

  /**
   * Get a KubeVirt API group
   */
  async getAPIGroupCloneKubevirtIoRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/clone.kubevirt.io/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue),
    );
  }

  /**
   * Get a KubeVirt API group
   */
  async getAPIGroupCloneKubevirtIo(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
    const response = await this.getAPIGroupCloneKubevirtIoRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get a KubeVirt API group
   */
  async getAPIGroupExportKubevirtIoRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/export.kubevirt.io/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue),
    );
  }

  /**
   * Get a KubeVirt API group
   */
  async getAPIGroupExportKubevirtIo(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
    const response = await this.getAPIGroupExportKubevirtIoRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get a KubeVirt API group
   */
  async getAPIGroupFlavorKubevirtIoRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue),
    );
  }

  /**
   * Get a KubeVirt API group
   */
  async getAPIGroupFlavorKubevirtIo(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
    const response = await this.getAPIGroupFlavorKubevirtIoRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get a KubeVirt API group
   */
  async getAPIGroupKubevirtIoRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue),
    );
  }

  /**
   * Get a KubeVirt API group
   */
  async getAPIGroupKubevirtIo(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
    const response = await this.getAPIGroupKubevirtIoRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get a KubeVirt API GroupList
   */
  async getAPIGroupListRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroupList>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIGroupListFromJSON(jsonValue),
    );
  }

  /**
   * Get a KubeVirt API GroupList
   */
  async getAPIGroupList(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIGroupList> {
    const response = await this.getAPIGroupListRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get a KubeVirt API group
   */
  async getAPIGroupMigrationsKubevirtIoRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/migrations.kubevirt.io/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue),
    );
  }

  /**
   * Get a KubeVirt API group
   */
  async getAPIGroupMigrationsKubevirtIo(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
    const response = await this.getAPIGroupMigrationsKubevirtIoRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get a KubeVirt API group
   */
  async getAPIGroupPoolKubevirtIoRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/pool.kubevirt.io/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue),
    );
  }

  /**
   * Get a KubeVirt API group
   */
  async getAPIGroupPoolKubevirtIo(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
    const response = await this.getAPIGroupPoolKubevirtIoRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get a KubeVirt API group
   */
  async getAPIGroupSnapshotKubevirtIoRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue),
    );
  }

  /**
   * Get a KubeVirt API group
   */
  async getAPIGroupSnapshotKubevirtIo(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
    const response = await this.getAPIGroupSnapshotKubevirtIoRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get KubeVirt API Resources
   */
  async getAPIResourcesCloneKubevirtIoV1alpha1Raw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/clone.kubevirt.io/v1alpha1/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue),
    );
  }

  /**
   * Get KubeVirt API Resources
   */
  async getAPIResourcesCloneKubevirtIoV1alpha1(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
    const response = await this.getAPIResourcesCloneKubevirtIoV1alpha1Raw(initOverrides);
    return await response.value();
  }

  /**
   * Get KubeVirt API Resources
   */
  async getAPIResourcesExportKubevirtIoV1alpha1Raw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/export.kubevirt.io/v1alpha1/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue),
    );
  }

  /**
   * Get KubeVirt API Resources
   */
  async getAPIResourcesExportKubevirtIoV1alpha1(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
    const response = await this.getAPIResourcesExportKubevirtIoV1alpha1Raw(initOverrides);
    return await response.value();
  }

  /**
   * Get KubeVirt API Resources
   */
  async getAPIResourcesFlavorKubevirtIoV1alpha1Raw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue),
    );
  }

  /**
   * Get KubeVirt API Resources
   */
  async getAPIResourcesFlavorKubevirtIoV1alpha1(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
    const response = await this.getAPIResourcesFlavorKubevirtIoV1alpha1Raw(initOverrides);
    return await response.value();
  }

  /**
   * Get KubeVirt API Resources
   */
  async getAPIResourcesKubevirtIoV1Raw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue),
    );
  }

  /**
   * Get KubeVirt API Resources
   */
  async getAPIResourcesKubevirtIoV1(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
    const response = await this.getAPIResourcesKubevirtIoV1Raw(initOverrides);
    return await response.value();
  }

  /**
   * Get KubeVirt API Resources
   */
  async getAPIResourcesMigrationsKubevirtIoV1alpha1Raw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/migrations.kubevirt.io/v1alpha1/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue),
    );
  }

  /**
   * Get KubeVirt API Resources
   */
  async getAPIResourcesMigrationsKubevirtIoV1alpha1(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
    const response = await this.getAPIResourcesMigrationsKubevirtIoV1alpha1Raw(initOverrides);
    return await response.value();
  }

  /**
   * Get KubeVirt API Resources
   */
  async getAPIResourcesPoolKubevirtIoV1alpha1Raw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/pool.kubevirt.io/v1alpha1/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue),
    );
  }

  /**
   * Get KubeVirt API Resources
   */
  async getAPIResourcesPoolKubevirtIoV1alpha1(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
    const response = await this.getAPIResourcesPoolKubevirtIoV1alpha1Raw(initOverrides);
    return await response.value();
  }

  /**
   * Get KubeVirt API Resources
   */
  async getAPIResourcesSnapshotKubevirtIoV1alpha1Raw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue),
    );
  }

  /**
   * Get KubeVirt API Resources
   */
  async getAPIResourcesSnapshotKubevirtIoV1alpha1(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
    const response = await this.getAPIResourcesSnapshotKubevirtIoV1alpha1Raw(initOverrides);
    return await response.value();
  }

  /**
   * Get KubeVirt API root paths
   */
  async getRootPathsRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1RootPaths>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1RootPathsFromJSON(jsonValue),
    );
  }

  /**
   * Get KubeVirt API root paths
   */
  async getRootPaths(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1RootPaths> {
    const response = await this.getRootPathsRaw(initOverrides);
    return await response.value();
  }

  /**
   * dump profiler results endpoint
   */
  async handleDumpProfilerRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/dump-profiler`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * dump profiler results endpoint
   */
  async handleDumpProfiler(initOverrides?: RequestInit): Promise<void> {
    await this.handleDumpProfilerRaw(initOverrides);
  }

  /**
   * start profiler endpoint
   */
  async handleStartProfilerRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/start-profiler`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * start profiler endpoint
   */
  async handleStartProfiler(initOverrides?: RequestInit): Promise<void> {
    await this.handleStartProfilerRaw(initOverrides);
  }

  /**
   * stop profiler endpoint
   */
  async handleStopProfilerRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/stop-profiler`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * stop profiler endpoint
   */
  async handleStopProfiler(initOverrides?: RequestInit): Promise<void> {
    await this.handleStopProfilerRaw(initOverrides);
  }

  /**
   * Get a list of all KubeVirt objects.
   */
  async listKubeVirtForAllNamespacesRaw(
    requestParameters: ListKubeVirtForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1KubeVirtList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/kubevirt`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => V1KubeVirtListFromJSON(jsonValue));
  }

  /**
   * Get a list of all KubeVirt objects.
   */
  async listKubeVirtForAllNamespaces(
    requestParameters: ListKubeVirtForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<V1KubeVirtList> {
    const response = await this.listKubeVirtForAllNamespacesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get a list of MigrationPolicy objects.
   */
  async listMigrationPolicyRaw(
    requestParameters: ListMigrationPolicyRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1MigrationPolicyList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1MigrationPolicyListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of MigrationPolicy objects.
   */
  async listMigrationPolicy(
    requestParameters: ListMigrationPolicyRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1MigrationPolicyList> {
    const response = await this.listMigrationPolicyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get a list of KubeVirt objects.
   */
  async listNamespacedKubeVirtRaw(
    requestParameters: ListNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1KubeVirtList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedKubeVirt.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/kubevirt`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => V1KubeVirtListFromJSON(jsonValue));
  }

  /**
   * Get a list of KubeVirt objects.
   */
  async listNamespacedKubeVirt(
    requestParameters: ListNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<V1KubeVirtList> {
    const response = await this.listNamespacedKubeVirtRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get a list of VirtualMachine objects.
   */
  async listNamespacedVirtualMachineRaw(
    requestParameters: ListNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachine.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of VirtualMachine objects.
   */
  async listNamespacedVirtualMachine(
    requestParameters: ListNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineList> {
    const response = await this.listNamespacedVirtualMachineRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get a list of VirtualMachineExport objects.
   */
  async listNamespacedVirtualMachineExportRaw(
    requestParameters: ListNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineExportList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineExport.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/export.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineexports`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineExportListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of VirtualMachineExport objects.
   */
  async listNamespacedVirtualMachineExport(
    requestParameters: ListNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineExportList> {
    const response = await this.listNamespacedVirtualMachineExportRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of VirtualMachineFlavor objects.
   */
  async listNamespacedVirtualMachineFlavorRaw(
    requestParameters: ListNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineFlavorList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineFlavor.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineflavors`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineFlavorListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of VirtualMachineFlavor objects.
   */
  async listNamespacedVirtualMachineFlavor(
    requestParameters: ListNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineFlavorList> {
    const response = await this.listNamespacedVirtualMachineFlavorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of VirtualMachineInstance objects.
   */
  async listNamespacedVirtualMachineInstanceRaw(
    requestParameters: ListNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineInstance.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of VirtualMachineInstance objects.
   */
  async listNamespacedVirtualMachineInstance(
    requestParameters: ListNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceList> {
    const response = await this.listNamespacedVirtualMachineInstanceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of VirtualMachineInstanceMigration objects.
   */
  async listNamespacedVirtualMachineInstanceMigrationRaw(
    requestParameters: ListNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceMigrationList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineInstanceMigration.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancemigrations`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceMigrationListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of VirtualMachineInstanceMigration objects.
   */
  async listNamespacedVirtualMachineInstanceMigration(
    requestParameters: ListNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceMigrationList> {
    const response = await this.listNamespacedVirtualMachineInstanceMigrationRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of VirtualMachineInstancePreset objects.
   */
  async listNamespacedVirtualMachineInstancePresetRaw(
    requestParameters: ListNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstancePresetList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineInstancePreset.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancepresets`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstancePresetListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of VirtualMachineInstancePreset objects.
   */
  async listNamespacedVirtualMachineInstancePreset(
    requestParameters: ListNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstancePresetList> {
    const response = await this.listNamespacedVirtualMachineInstancePresetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of VirtualMachineInstanceReplicaSet objects.
   */
  async listNamespacedVirtualMachineInstanceReplicaSetRaw(
    requestParameters: ListNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceReplicaSetList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineInstanceReplicaSet.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancereplicasets`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceReplicaSetListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of VirtualMachineInstanceReplicaSet objects.
   */
  async listNamespacedVirtualMachineInstanceReplicaSet(
    requestParameters: ListNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceReplicaSetList> {
    const response = await this.listNamespacedVirtualMachineInstanceReplicaSetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of VirtualMachinePool objects.
   */
  async listNamespacedVirtualMachinePoolRaw(
    requestParameters: ListNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePoolList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachinePool.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepools`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachinePoolListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of VirtualMachinePool objects.
   */
  async listNamespacedVirtualMachinePool(
    requestParameters: ListNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachinePoolList> {
    const response = await this.listNamespacedVirtualMachinePoolRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of VirtualMachinePreference objects.
   */
  async listNamespacedVirtualMachinePreferenceRaw(
    requestParameters: ListNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePreferenceList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachinePreference.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepreferences`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachinePreferenceListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of VirtualMachinePreference objects.
   */
  async listNamespacedVirtualMachinePreference(
    requestParameters: ListNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachinePreferenceList> {
    const response = await this.listNamespacedVirtualMachinePreferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of VirtualMachineRestore objects.
   */
  async listNamespacedVirtualMachineRestoreRaw(
    requestParameters: ListNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineRestoreList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineRestore.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinerestores`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineRestoreListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of VirtualMachineRestore objects.
   */
  async listNamespacedVirtualMachineRestore(
    requestParameters: ListNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineRestoreList> {
    const response = await this.listNamespacedVirtualMachineRestoreRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of VirtualMachineSnapshot objects.
   */
  async listNamespacedVirtualMachineSnapshotRaw(
    requestParameters: ListNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineSnapshotList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineSnapshot.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshots`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineSnapshotListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of VirtualMachineSnapshot objects.
   */
  async listNamespacedVirtualMachineSnapshot(
    requestParameters: ListNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineSnapshotList> {
    const response = await this.listNamespacedVirtualMachineSnapshotRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of VirtualMachineSnapshotContent objects.
   */
  async listNamespacedVirtualMachineSnapshotContentRaw(
    requestParameters: ListNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineSnapshotContentList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineSnapshotContent.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshotcontents`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineSnapshotContentListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of VirtualMachineSnapshotContent objects.
   */
  async listNamespacedVirtualMachineSnapshotContent(
    requestParameters: ListNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineSnapshotContentList> {
    const response = await this.listNamespacedVirtualMachineSnapshotContentRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of VirtualMachineClone objects.
   */
  async listVirtualMachineCloneRaw(
    requestParameters: ListVirtualMachineCloneRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineCloneList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/clone.kubevirt.io/v1alpha1/virtualmachineclones`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineCloneListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of VirtualMachineClone objects.
   */
  async listVirtualMachineClone(
    requestParameters: ListVirtualMachineCloneRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineCloneList> {
    const response = await this.listVirtualMachineCloneRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get a list of VirtualMachineClusterFlavor objects.
   */
  async listVirtualMachineClusterFlavorRaw(
    requestParameters: ListVirtualMachineClusterFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineClusterFlavorList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachineclusterflavors`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineClusterFlavorListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of VirtualMachineClusterFlavor objects.
   */
  async listVirtualMachineClusterFlavor(
    requestParameters: ListVirtualMachineClusterFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineClusterFlavorList> {
    const response = await this.listVirtualMachineClusterFlavorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of VirtualMachineClusterPreference objects.
   */
  async listVirtualMachineClusterPreferenceRaw(
    requestParameters: ListVirtualMachineClusterPreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineClusterPreferenceList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachineclusterpreferences`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineClusterPreferenceListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of VirtualMachineClusterPreference objects.
   */
  async listVirtualMachineClusterPreference(
    requestParameters: ListVirtualMachineClusterPreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineClusterPreferenceList> {
    const response = await this.listVirtualMachineClusterPreferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of all VirtualMachineExport objects.
   */
  async listVirtualMachineExportForAllNamespacesRaw(
    requestParameters: ListVirtualMachineExportForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineExportList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/export.kubevirt.io/v1alpha1/virtualmachineexports`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineExportListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of all VirtualMachineExport objects.
   */
  async listVirtualMachineExportForAllNamespaces(
    requestParameters: ListVirtualMachineExportForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineExportList> {
    const response = await this.listVirtualMachineExportForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of all VirtualMachineFlavor objects.
   */
  async listVirtualMachineFlavorForAllNamespacesRaw(
    requestParameters: ListVirtualMachineFlavorForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineFlavorList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachineflavors`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineFlavorListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of all VirtualMachineFlavor objects.
   */
  async listVirtualMachineFlavorForAllNamespaces(
    requestParameters: ListVirtualMachineFlavorForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineFlavorList> {
    const response = await this.listVirtualMachineFlavorForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of all VirtualMachine objects.
   */
  async listVirtualMachineForAllNamespacesRaw(
    requestParameters: ListVirtualMachineForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/virtualmachines`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of all VirtualMachine objects.
   */
  async listVirtualMachineForAllNamespaces(
    requestParameters: ListVirtualMachineForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineList> {
    const response = await this.listVirtualMachineForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of all VirtualMachineInstance objects.
   */
  async listVirtualMachineInstanceForAllNamespacesRaw(
    requestParameters: ListVirtualMachineInstanceForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/virtualmachineinstances`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of all VirtualMachineInstance objects.
   */
  async listVirtualMachineInstanceForAllNamespaces(
    requestParameters: ListVirtualMachineInstanceForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceList> {
    const response = await this.listVirtualMachineInstanceForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of all VirtualMachineInstanceMigration objects.
   */
  async listVirtualMachineInstanceMigrationForAllNamespacesRaw(
    requestParameters: ListVirtualMachineInstanceMigrationForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceMigrationList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/virtualmachineinstancemigrations`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceMigrationListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of all VirtualMachineInstanceMigration objects.
   */
  async listVirtualMachineInstanceMigrationForAllNamespaces(
    requestParameters: ListVirtualMachineInstanceMigrationForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceMigrationList> {
    const response = await this.listVirtualMachineInstanceMigrationForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of all VirtualMachineInstancePreset objects.
   */
  async listVirtualMachineInstancePresetForAllNamespacesRaw(
    requestParameters: ListVirtualMachineInstancePresetForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstancePresetList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/virtualmachineinstancepresets`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstancePresetListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of all VirtualMachineInstancePreset objects.
   */
  async listVirtualMachineInstancePresetForAllNamespaces(
    requestParameters: ListVirtualMachineInstancePresetForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstancePresetList> {
    const response = await this.listVirtualMachineInstancePresetForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of all VirtualMachineInstanceReplicaSet objects.
   */
  async listVirtualMachineInstanceReplicaSetForAllNamespacesRaw(
    requestParameters: ListVirtualMachineInstanceReplicaSetForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceReplicaSetList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/virtualmachineinstancereplicasets`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceReplicaSetListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of all VirtualMachineInstanceReplicaSet objects.
   */
  async listVirtualMachineInstanceReplicaSetForAllNamespaces(
    requestParameters: ListVirtualMachineInstanceReplicaSetForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceReplicaSetList> {
    const response = await this.listVirtualMachineInstanceReplicaSetForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of all VirtualMachinePool objects.
   */
  async listVirtualMachinePoolForAllNamespacesRaw(
    requestParameters: ListVirtualMachinePoolForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePoolList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/pool.kubevirt.io/v1alpha1/virtualmachinepools`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachinePoolListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of all VirtualMachinePool objects.
   */
  async listVirtualMachinePoolForAllNamespaces(
    requestParameters: ListVirtualMachinePoolForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachinePoolList> {
    const response = await this.listVirtualMachinePoolForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of all VirtualMachinePreference objects.
   */
  async listVirtualMachinePreferenceForAllNamespacesRaw(
    requestParameters: ListVirtualMachinePreferenceForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePreferenceList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachinepreferences`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachinePreferenceListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of all VirtualMachinePreference objects.
   */
  async listVirtualMachinePreferenceForAllNamespaces(
    requestParameters: ListVirtualMachinePreferenceForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachinePreferenceList> {
    const response = await this.listVirtualMachinePreferenceForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of all VirtualMachineRestore objects.
   */
  async listVirtualMachineRestoreForAllNamespacesRaw(
    requestParameters: ListVirtualMachineRestoreForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineRestoreList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/virtualmachinerestores`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineRestoreListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of all VirtualMachineRestore objects.
   */
  async listVirtualMachineRestoreForAllNamespaces(
    requestParameters: ListVirtualMachineRestoreForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineRestoreList> {
    const response = await this.listVirtualMachineRestoreForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of all VirtualMachineSnapshotContent objects.
   */
  async listVirtualMachineSnapshotContentForAllNamespacesRaw(
    requestParameters: ListVirtualMachineSnapshotContentForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineSnapshotContentList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/virtualmachinesnapshotcontents`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineSnapshotContentListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of all VirtualMachineSnapshotContent objects.
   */
  async listVirtualMachineSnapshotContentForAllNamespaces(
    requestParameters: ListVirtualMachineSnapshotContentForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineSnapshotContentList> {
    const response = await this.listVirtualMachineSnapshotContentForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a list of all VirtualMachineSnapshot objects.
   */
  async listVirtualMachineSnapshotForAllNamespacesRaw(
    requestParameters: ListVirtualMachineSnapshotForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineSnapshotList>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/virtualmachinesnapshots`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineSnapshotListFromJSON(jsonValue),
    );
  }

  /**
   * Get a list of all VirtualMachineSnapshot objects.
   */
  async listVirtualMachineSnapshotForAllNamespaces(
    requestParameters: ListVirtualMachineSnapshotForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineSnapshotList> {
    const response = await this.listVirtualMachineSnapshotForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Patch a MigrationPolicy object.
   */
  async patchMigrationPolicyRaw(
    requestParameters: PatchMigrationPolicyRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1MigrationPolicy>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchMigrationPolicy.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchMigrationPolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1MigrationPolicyFromJSON(jsonValue),
    );
  }

  /**
   * Patch a MigrationPolicy object.
   */
  async patchMigrationPolicy(
    requestParameters: PatchMigrationPolicyRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1MigrationPolicy> {
    const response = await this.patchMigrationPolicyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Patch a KubeVirt object.
   */
  async patchNamespacedKubeVirtRaw(
    requestParameters: PatchNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1KubeVirt>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedKubeVirt.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedKubeVirt.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedKubeVirt.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/kubevirt/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => V1KubeVirtFromJSON(jsonValue));
  }

  /**
   * Patch a KubeVirt object.
   */
  async patchNamespacedKubeVirt(
    requestParameters: PatchNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<V1KubeVirt> {
    const response = await this.patchNamespacedKubeVirtRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Patch a VirtualMachine object.
   */
  async patchNamespacedVirtualMachineRaw(
    requestParameters: PatchNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachine>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachine.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachine.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachine.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineFromJSON(jsonValue),
    );
  }

  /**
   * Patch a VirtualMachine object.
   */
  async patchNamespacedVirtualMachine(
    requestParameters: PatchNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachine> {
    const response = await this.patchNamespacedVirtualMachineRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Patch a VirtualMachineExport object.
   */
  async patchNamespacedVirtualMachineExportRaw(
    requestParameters: PatchNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineExport>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineExport.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineExport.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineExport.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/export.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineexports/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineExportFromJSON(jsonValue),
    );
  }

  /**
   * Patch a VirtualMachineExport object.
   */
  async patchNamespacedVirtualMachineExport(
    requestParameters: PatchNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineExport> {
    const response = await this.patchNamespacedVirtualMachineExportRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Patch a VirtualMachineFlavor object.
   */
  async patchNamespacedVirtualMachineFlavorRaw(
    requestParameters: PatchNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineFlavor>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineFlavor.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineFlavor.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineFlavor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineflavors/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineFlavorFromJSON(jsonValue),
    );
  }

  /**
   * Patch a VirtualMachineFlavor object.
   */
  async patchNamespacedVirtualMachineFlavor(
    requestParameters: PatchNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineFlavor> {
    const response = await this.patchNamespacedVirtualMachineFlavorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Patch a VirtualMachineInstance object.
   */
  async patchNamespacedVirtualMachineInstanceRaw(
    requestParameters: PatchNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstance>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineInstance.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineInstance.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineInstance.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceFromJSON(jsonValue),
    );
  }

  /**
   * Patch a VirtualMachineInstance object.
   */
  async patchNamespacedVirtualMachineInstance(
    requestParameters: PatchNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstance> {
    const response = await this.patchNamespacedVirtualMachineInstanceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Patch a VirtualMachineInstanceMigration object.
   */
  async patchNamespacedVirtualMachineInstanceMigrationRaw(
    requestParameters: PatchNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceMigration>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineInstanceMigration.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineInstanceMigration.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineInstanceMigration.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancemigrations/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceMigrationFromJSON(jsonValue),
    );
  }

  /**
   * Patch a VirtualMachineInstanceMigration object.
   */
  async patchNamespacedVirtualMachineInstanceMigration(
    requestParameters: PatchNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceMigration> {
    const response = await this.patchNamespacedVirtualMachineInstanceMigrationRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Patch a VirtualMachineInstancePreset object.
   */
  async patchNamespacedVirtualMachineInstancePresetRaw(
    requestParameters: PatchNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstancePreset>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineInstancePreset.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineInstancePreset.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineInstancePreset.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancepresets/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstancePresetFromJSON(jsonValue),
    );
  }

  /**
   * Patch a VirtualMachineInstancePreset object.
   */
  async patchNamespacedVirtualMachineInstancePreset(
    requestParameters: PatchNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstancePreset> {
    const response = await this.patchNamespacedVirtualMachineInstancePresetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Patch a VirtualMachineInstanceReplicaSet object.
   */
  async patchNamespacedVirtualMachineInstanceReplicaSetRaw(
    requestParameters: PatchNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceReplicaSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineInstanceReplicaSet.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineInstanceReplicaSet.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineInstanceReplicaSet.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancereplicasets/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceReplicaSetFromJSON(jsonValue),
    );
  }

  /**
   * Patch a VirtualMachineInstanceReplicaSet object.
   */
  async patchNamespacedVirtualMachineInstanceReplicaSet(
    requestParameters: PatchNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceReplicaSet> {
    const response = await this.patchNamespacedVirtualMachineInstanceReplicaSetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Patch a VirtualMachinePool object.
   */
  async patchNamespacedVirtualMachinePoolRaw(
    requestParameters: PatchNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePool>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachinePool.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachinePool.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachinePool.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepools/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachinePoolFromJSON(jsonValue),
    );
  }

  /**
   * Patch a VirtualMachinePool object.
   */
  async patchNamespacedVirtualMachinePool(
    requestParameters: PatchNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachinePool> {
    const response = await this.patchNamespacedVirtualMachinePoolRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Patch a VirtualMachinePreference object.
   */
  async patchNamespacedVirtualMachinePreferenceRaw(
    requestParameters: PatchNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePreference>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachinePreference.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachinePreference.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachinePreference.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepreferences/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachinePreferenceFromJSON(jsonValue),
    );
  }

  /**
   * Patch a VirtualMachinePreference object.
   */
  async patchNamespacedVirtualMachinePreference(
    requestParameters: PatchNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachinePreference> {
    const response = await this.patchNamespacedVirtualMachinePreferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Patch a VirtualMachineRestore object.
   */
  async patchNamespacedVirtualMachineRestoreRaw(
    requestParameters: PatchNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineRestore>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineRestore.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineRestore.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineRestore.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinerestores/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineRestoreFromJSON(jsonValue),
    );
  }

  /**
   * Patch a VirtualMachineRestore object.
   */
  async patchNamespacedVirtualMachineRestore(
    requestParameters: PatchNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineRestore> {
    const response = await this.patchNamespacedVirtualMachineRestoreRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Patch a VirtualMachineSnapshot object.
   */
  async patchNamespacedVirtualMachineSnapshotRaw(
    requestParameters: PatchNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineSnapshot>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineSnapshot.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineSnapshot.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineSnapshot.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshots/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineSnapshotFromJSON(jsonValue),
    );
  }

  /**
   * Patch a VirtualMachineSnapshot object.
   */
  async patchNamespacedVirtualMachineSnapshot(
    requestParameters: PatchNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineSnapshot> {
    const response = await this.patchNamespacedVirtualMachineSnapshotRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Patch a VirtualMachineSnapshotContent object.
   */
  async patchNamespacedVirtualMachineSnapshotContentRaw(
    requestParameters: PatchNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineSnapshotContent>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineSnapshotContent.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineSnapshotContent.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineSnapshotContent.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshotcontents/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineSnapshotContentFromJSON(jsonValue),
    );
  }

  /**
   * Patch a VirtualMachineSnapshotContent object.
   */
  async patchNamespacedVirtualMachineSnapshotContent(
    requestParameters: PatchNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineSnapshotContent> {
    const response = await this.patchNamespacedVirtualMachineSnapshotContentRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Patch a VirtualMachineClone object.
   */
  async patchVirtualMachineCloneRaw(
    requestParameters: PatchVirtualMachineCloneRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineClone>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchVirtualMachineClone.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchVirtualMachineClone.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/clone.kubevirt.io/v1alpha1/virtualmachineclones/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineCloneFromJSON(jsonValue),
    );
  }

  /**
   * Patch a VirtualMachineClone object.
   */
  async patchVirtualMachineClone(
    requestParameters: PatchVirtualMachineCloneRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineClone> {
    const response = await this.patchVirtualMachineCloneRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Patch a VirtualMachineClusterFlavor object.
   */
  async patchVirtualMachineClusterFlavorRaw(
    requestParameters: PatchVirtualMachineClusterFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineClusterFlavor>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchVirtualMachineClusterFlavor.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchVirtualMachineClusterFlavor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachineclusterflavors/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineClusterFlavorFromJSON(jsonValue),
    );
  }

  /**
   * Patch a VirtualMachineClusterFlavor object.
   */
  async patchVirtualMachineClusterFlavor(
    requestParameters: PatchVirtualMachineClusterFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineClusterFlavor> {
    const response = await this.patchVirtualMachineClusterFlavorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Patch a VirtualMachineClusterPreference object.
   */
  async patchVirtualMachineClusterPreferenceRaw(
    requestParameters: PatchVirtualMachineClusterPreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineClusterPreference>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling patchVirtualMachineClusterPreference.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling patchVirtualMachineClusterPreference.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json-patch+json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachineclusterpreferences/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineClusterPreferenceFromJSON(jsonValue),
    );
  }

  /**
   * Patch a VirtualMachineClusterPreference object.
   */
  async patchVirtualMachineClusterPreference(
    requestParameters: PatchVirtualMachineClusterPreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineClusterPreference> {
    const response = await this.patchVirtualMachineClusterPreferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a MigrationPolicy object.
   */
  async readMigrationPolicyRaw(
    requestParameters: ReadMigrationPolicyRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1MigrationPolicy>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readMigrationPolicy.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1MigrationPolicyFromJSON(jsonValue),
    );
  }

  /**
   * Get a MigrationPolicy object.
   */
  async readMigrationPolicy(
    requestParameters: ReadMigrationPolicyRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1MigrationPolicy> {
    const response = await this.readMigrationPolicyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get a KubeVirt object.
   */
  async readNamespacedKubeVirtRaw(
    requestParameters: ReadNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1KubeVirt>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedKubeVirt.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedKubeVirt.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/kubevirt/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => V1KubeVirtFromJSON(jsonValue));
  }

  /**
   * Get a KubeVirt object.
   */
  async readNamespacedKubeVirt(
    requestParameters: ReadNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<V1KubeVirt> {
    const response = await this.readNamespacedKubeVirtRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get a VirtualMachine object.
   */
  async readNamespacedVirtualMachineRaw(
    requestParameters: ReadNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachine>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachine.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachine.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineFromJSON(jsonValue),
    );
  }

  /**
   * Get a VirtualMachine object.
   */
  async readNamespacedVirtualMachine(
    requestParameters: ReadNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachine> {
    const response = await this.readNamespacedVirtualMachineRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get a VirtualMachineExport object.
   */
  async readNamespacedVirtualMachineExportRaw(
    requestParameters: ReadNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineExport>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineExport.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineExport.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/export.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineexports/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineExportFromJSON(jsonValue),
    );
  }

  /**
   * Get a VirtualMachineExport object.
   */
  async readNamespacedVirtualMachineExport(
    requestParameters: ReadNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineExport> {
    const response = await this.readNamespacedVirtualMachineExportRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a VirtualMachineFlavor object.
   */
  async readNamespacedVirtualMachineFlavorRaw(
    requestParameters: ReadNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineFlavor>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineFlavor.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineFlavor.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineflavors/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineFlavorFromJSON(jsonValue),
    );
  }

  /**
   * Get a VirtualMachineFlavor object.
   */
  async readNamespacedVirtualMachineFlavor(
    requestParameters: ReadNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineFlavor> {
    const response = await this.readNamespacedVirtualMachineFlavorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a VirtualMachineInstance object.
   */
  async readNamespacedVirtualMachineInstanceRaw(
    requestParameters: ReadNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstance>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineInstance.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineInstance.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceFromJSON(jsonValue),
    );
  }

  /**
   * Get a VirtualMachineInstance object.
   */
  async readNamespacedVirtualMachineInstance(
    requestParameters: ReadNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstance> {
    const response = await this.readNamespacedVirtualMachineInstanceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a VirtualMachineInstanceMigration object.
   */
  async readNamespacedVirtualMachineInstanceMigrationRaw(
    requestParameters: ReadNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceMigration>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineInstanceMigration.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineInstanceMigration.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancemigrations/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceMigrationFromJSON(jsonValue),
    );
  }

  /**
   * Get a VirtualMachineInstanceMigration object.
   */
  async readNamespacedVirtualMachineInstanceMigration(
    requestParameters: ReadNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceMigration> {
    const response = await this.readNamespacedVirtualMachineInstanceMigrationRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a VirtualMachineInstancePreset object.
   */
  async readNamespacedVirtualMachineInstancePresetRaw(
    requestParameters: ReadNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstancePreset>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineInstancePreset.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineInstancePreset.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancepresets/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstancePresetFromJSON(jsonValue),
    );
  }

  /**
   * Get a VirtualMachineInstancePreset object.
   */
  async readNamespacedVirtualMachineInstancePreset(
    requestParameters: ReadNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstancePreset> {
    const response = await this.readNamespacedVirtualMachineInstancePresetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a VirtualMachineInstanceReplicaSet object.
   */
  async readNamespacedVirtualMachineInstanceReplicaSetRaw(
    requestParameters: ReadNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceReplicaSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineInstanceReplicaSet.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineInstanceReplicaSet.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancereplicasets/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceReplicaSetFromJSON(jsonValue),
    );
  }

  /**
   * Get a VirtualMachineInstanceReplicaSet object.
   */
  async readNamespacedVirtualMachineInstanceReplicaSet(
    requestParameters: ReadNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceReplicaSet> {
    const response = await this.readNamespacedVirtualMachineInstanceReplicaSetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a VirtualMachinePool object.
   */
  async readNamespacedVirtualMachinePoolRaw(
    requestParameters: ReadNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePool>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachinePool.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachinePool.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepools/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachinePoolFromJSON(jsonValue),
    );
  }

  /**
   * Get a VirtualMachinePool object.
   */
  async readNamespacedVirtualMachinePool(
    requestParameters: ReadNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachinePool> {
    const response = await this.readNamespacedVirtualMachinePoolRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a VirtualMachinePreference object.
   */
  async readNamespacedVirtualMachinePreferenceRaw(
    requestParameters: ReadNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePreference>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachinePreference.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachinePreference.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepreferences/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachinePreferenceFromJSON(jsonValue),
    );
  }

  /**
   * Get a VirtualMachinePreference object.
   */
  async readNamespacedVirtualMachinePreference(
    requestParameters: ReadNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachinePreference> {
    const response = await this.readNamespacedVirtualMachinePreferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a VirtualMachineRestore object.
   */
  async readNamespacedVirtualMachineRestoreRaw(
    requestParameters: ReadNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineRestore>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineRestore.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineRestore.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinerestores/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineRestoreFromJSON(jsonValue),
    );
  }

  /**
   * Get a VirtualMachineRestore object.
   */
  async readNamespacedVirtualMachineRestore(
    requestParameters: ReadNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineRestore> {
    const response = await this.readNamespacedVirtualMachineRestoreRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a VirtualMachineSnapshot object.
   */
  async readNamespacedVirtualMachineSnapshotRaw(
    requestParameters: ReadNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineSnapshot>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineSnapshot.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineSnapshot.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshots/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineSnapshotFromJSON(jsonValue),
    );
  }

  /**
   * Get a VirtualMachineSnapshot object.
   */
  async readNamespacedVirtualMachineSnapshot(
    requestParameters: ReadNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineSnapshot> {
    const response = await this.readNamespacedVirtualMachineSnapshotRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a VirtualMachineSnapshotContent object.
   */
  async readNamespacedVirtualMachineSnapshotContentRaw(
    requestParameters: ReadNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineSnapshotContent>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineSnapshotContent.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineSnapshotContent.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshotcontents/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineSnapshotContentFromJSON(jsonValue),
    );
  }

  /**
   * Get a VirtualMachineSnapshotContent object.
   */
  async readNamespacedVirtualMachineSnapshotContent(
    requestParameters: ReadNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineSnapshotContent> {
    const response = await this.readNamespacedVirtualMachineSnapshotContentRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a VirtualMachineClone object.
   */
  async readVirtualMachineCloneRaw(
    requestParameters: ReadVirtualMachineCloneRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineClone>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readVirtualMachineClone.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/clone.kubevirt.io/v1alpha1/virtualmachineclones/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineCloneFromJSON(jsonValue),
    );
  }

  /**
   * Get a VirtualMachineClone object.
   */
  async readVirtualMachineClone(
    requestParameters: ReadVirtualMachineCloneRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineClone> {
    const response = await this.readVirtualMachineCloneRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get a VirtualMachineClusterFlavor object.
   */
  async readVirtualMachineClusterFlavorRaw(
    requestParameters: ReadVirtualMachineClusterFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineClusterFlavor>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readVirtualMachineClusterFlavor.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachineclusterflavors/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineClusterFlavorFromJSON(jsonValue),
    );
  }

  /**
   * Get a VirtualMachineClusterFlavor object.
   */
  async readVirtualMachineClusterFlavor(
    requestParameters: ReadVirtualMachineClusterFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineClusterFlavor> {
    const response = await this.readVirtualMachineClusterFlavorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a VirtualMachineClusterPreference object.
   */
  async readVirtualMachineClusterPreferenceRaw(
    requestParameters: ReadVirtualMachineClusterPreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineClusterPreference>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling readVirtualMachineClusterPreference.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact;
    }

    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachineclusterpreferences/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineClusterPreferenceFromJSON(jsonValue),
    );
  }

  /**
   * Get a VirtualMachineClusterPreference object.
   */
  async readVirtualMachineClusterPreference(
    requestParameters: ReadVirtualMachineClusterPreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineClusterPreference> {
    const response = await this.readVirtualMachineClusterPreferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Update a MigrationPolicy object.
   */
  async replaceMigrationPolicyRaw(
    requestParameters: ReplaceMigrationPolicyRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1MigrationPolicy>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceMigrationPolicy.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceMigrationPolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1MigrationPolicyToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1MigrationPolicyFromJSON(jsonValue),
    );
  }

  /**
   * Update a MigrationPolicy object.
   */
  async replaceMigrationPolicy(
    requestParameters: ReplaceMigrationPolicyRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1MigrationPolicy> {
    const response = await this.replaceMigrationPolicyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Update a KubeVirt object.
   */
  async replaceNamespacedKubeVirtRaw(
    requestParameters: ReplaceNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1KubeVirt>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedKubeVirt.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedKubeVirt.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedKubeVirt.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/kubevirt/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1KubeVirtToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => V1KubeVirtFromJSON(jsonValue));
  }

  /**
   * Update a KubeVirt object.
   */
  async replaceNamespacedKubeVirt(
    requestParameters: ReplaceNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<V1KubeVirt> {
    const response = await this.replaceNamespacedKubeVirtRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Update a VirtualMachine object.
   */
  async replaceNamespacedVirtualMachineRaw(
    requestParameters: ReplaceNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachine>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachine.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachine.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachine.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1VirtualMachineToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineFromJSON(jsonValue),
    );
  }

  /**
   * Update a VirtualMachine object.
   */
  async replaceNamespacedVirtualMachine(
    requestParameters: ReplaceNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachine> {
    const response = await this.replaceNamespacedVirtualMachineRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Update a VirtualMachineExport object.
   */
  async replaceNamespacedVirtualMachineExportRaw(
    requestParameters: ReplaceNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineExport>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineExport.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineExport.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineExport.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/export.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineexports/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineExportToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineExportFromJSON(jsonValue),
    );
  }

  /**
   * Update a VirtualMachineExport object.
   */
  async replaceNamespacedVirtualMachineExport(
    requestParameters: ReplaceNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineExport> {
    const response = await this.replaceNamespacedVirtualMachineExportRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Update a VirtualMachineFlavor object.
   */
  async replaceNamespacedVirtualMachineFlavorRaw(
    requestParameters: ReplaceNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineFlavor>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineFlavor.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineFlavor.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineFlavor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineflavors/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineFlavorToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineFlavorFromJSON(jsonValue),
    );
  }

  /**
   * Update a VirtualMachineFlavor object.
   */
  async replaceNamespacedVirtualMachineFlavor(
    requestParameters: ReplaceNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineFlavor> {
    const response = await this.replaceNamespacedVirtualMachineFlavorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Update a VirtualMachineInstance object.
   */
  async replaceNamespacedVirtualMachineInstanceRaw(
    requestParameters: ReplaceNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstance>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineInstance.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineInstance.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineInstance.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1VirtualMachineInstanceToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceFromJSON(jsonValue),
    );
  }

  /**
   * Update a VirtualMachineInstance object.
   */
  async replaceNamespacedVirtualMachineInstance(
    requestParameters: ReplaceNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstance> {
    const response = await this.replaceNamespacedVirtualMachineInstanceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Update a VirtualMachineInstanceMigration object.
   */
  async replaceNamespacedVirtualMachineInstanceMigrationRaw(
    requestParameters: ReplaceNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceMigration>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineInstanceMigration.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineInstanceMigration.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineInstanceMigration.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancemigrations/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1VirtualMachineInstanceMigrationToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceMigrationFromJSON(jsonValue),
    );
  }

  /**
   * Update a VirtualMachineInstanceMigration object.
   */
  async replaceNamespacedVirtualMachineInstanceMigration(
    requestParameters: ReplaceNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceMigration> {
    const response = await this.replaceNamespacedVirtualMachineInstanceMigrationRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Update a VirtualMachineInstancePreset object.
   */
  async replaceNamespacedVirtualMachineInstancePresetRaw(
    requestParameters: ReplaceNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstancePreset>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineInstancePreset.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineInstancePreset.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineInstancePreset.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancepresets/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1VirtualMachineInstancePresetToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstancePresetFromJSON(jsonValue),
    );
  }

  /**
   * Update a VirtualMachineInstancePreset object.
   */
  async replaceNamespacedVirtualMachineInstancePreset(
    requestParameters: ReplaceNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstancePreset> {
    const response = await this.replaceNamespacedVirtualMachineInstancePresetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Update a VirtualMachineInstanceReplicaSet object.
   */
  async replaceNamespacedVirtualMachineInstanceReplicaSetRaw(
    requestParameters: ReplaceNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceReplicaSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineInstanceReplicaSet.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineInstanceReplicaSet.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineInstanceReplicaSet.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancereplicasets/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1VirtualMachineInstanceReplicaSetToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceReplicaSetFromJSON(jsonValue),
    );
  }

  /**
   * Update a VirtualMachineInstanceReplicaSet object.
   */
  async replaceNamespacedVirtualMachineInstanceReplicaSet(
    requestParameters: ReplaceNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceReplicaSet> {
    const response = await this.replaceNamespacedVirtualMachineInstanceReplicaSetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Update a VirtualMachinePool object.
   */
  async replaceNamespacedVirtualMachinePoolRaw(
    requestParameters: ReplaceNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePool>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachinePool.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachinePool.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachinePool.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepools/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachinePoolToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachinePoolFromJSON(jsonValue),
    );
  }

  /**
   * Update a VirtualMachinePool object.
   */
  async replaceNamespacedVirtualMachinePool(
    requestParameters: ReplaceNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachinePool> {
    const response = await this.replaceNamespacedVirtualMachinePoolRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Update a VirtualMachinePreference object.
   */
  async replaceNamespacedVirtualMachinePreferenceRaw(
    requestParameters: ReplaceNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePreference>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachinePreference.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachinePreference.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachinePreference.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepreferences/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachinePreferenceToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachinePreferenceFromJSON(jsonValue),
    );
  }

  /**
   * Update a VirtualMachinePreference object.
   */
  async replaceNamespacedVirtualMachinePreference(
    requestParameters: ReplaceNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachinePreference> {
    const response = await this.replaceNamespacedVirtualMachinePreferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Update a VirtualMachineRestore object.
   */
  async replaceNamespacedVirtualMachineRestoreRaw(
    requestParameters: ReplaceNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineRestore>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineRestore.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineRestore.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineRestore.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinerestores/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineRestoreToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineRestoreFromJSON(jsonValue),
    );
  }

  /**
   * Update a VirtualMachineRestore object.
   */
  async replaceNamespacedVirtualMachineRestore(
    requestParameters: ReplaceNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineRestore> {
    const response = await this.replaceNamespacedVirtualMachineRestoreRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Update a VirtualMachineSnapshot object.
   */
  async replaceNamespacedVirtualMachineSnapshotRaw(
    requestParameters: ReplaceNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineSnapshot>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineSnapshot.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineSnapshot.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineSnapshot.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshots/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineSnapshotToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineSnapshotFromJSON(jsonValue),
    );
  }

  /**
   * Update a VirtualMachineSnapshot object.
   */
  async replaceNamespacedVirtualMachineSnapshot(
    requestParameters: ReplaceNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineSnapshot> {
    const response = await this.replaceNamespacedVirtualMachineSnapshotRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Update a VirtualMachineSnapshotContent object.
   */
  async replaceNamespacedVirtualMachineSnapshotContentRaw(
    requestParameters: ReplaceNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineSnapshotContent>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineSnapshotContent.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineSnapshotContent.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineSnapshotContent.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshotcontents/{name:[a-z0-9][a-z0-9\-]*}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineSnapshotContentToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineSnapshotContentFromJSON(jsonValue),
    );
  }

  /**
   * Update a VirtualMachineSnapshotContent object.
   */
  async replaceNamespacedVirtualMachineSnapshotContent(
    requestParameters: ReplaceNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineSnapshotContent> {
    const response = await this.replaceNamespacedVirtualMachineSnapshotContentRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Update a VirtualMachineClone object.
   */
  async replaceVirtualMachineCloneRaw(
    requestParameters: ReplaceVirtualMachineCloneRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineClone>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceVirtualMachineClone.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceVirtualMachineClone.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/clone.kubevirt.io/v1alpha1/virtualmachineclones/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineCloneToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineCloneFromJSON(jsonValue),
    );
  }

  /**
   * Update a VirtualMachineClone object.
   */
  async replaceVirtualMachineClone(
    requestParameters: ReplaceVirtualMachineCloneRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineClone> {
    const response = await this.replaceVirtualMachineCloneRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Update a VirtualMachineClusterFlavor object.
   */
  async replaceVirtualMachineClusterFlavorRaw(
    requestParameters: ReplaceVirtualMachineClusterFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineClusterFlavor>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceVirtualMachineClusterFlavor.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceVirtualMachineClusterFlavor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachineclusterflavors/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineClusterFlavorToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineClusterFlavorFromJSON(jsonValue),
    );
  }

  /**
   * Update a VirtualMachineClusterFlavor object.
   */
  async replaceVirtualMachineClusterFlavor(
    requestParameters: ReplaceVirtualMachineClusterFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineClusterFlavor> {
    const response = await this.replaceVirtualMachineClusterFlavorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Update a VirtualMachineClusterPreference object.
   */
  async replaceVirtualMachineClusterPreferenceRaw(
    requestParameters: ReplaceVirtualMachineClusterPreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1alpha1VirtualMachineClusterPreference>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling replaceVirtualMachineClusterPreference.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling replaceVirtualMachineClusterPreference.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/virtualmachineclusterpreferences/{name:[a-z0-9][a-z0-9\-]*}`.replace(
          `{${'name'}}`,
          encodeURIComponent(String(requestParameters.name)),
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1alpha1VirtualMachineClusterPreferenceToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1alpha1VirtualMachineClusterPreferenceFromJSON(jsonValue),
    );
  }

  /**
   * Update a VirtualMachineClusterPreference object.
   */
  async replaceVirtualMachineClusterPreference(
    requestParameters: ReplaceVirtualMachineClusterPreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<V1alpha1VirtualMachineClusterPreference> {
    const response = await this.replaceVirtualMachineClusterPreferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Health endpoint
   */
  async v1CheckHealthRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/healthz`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Health endpoint
   */
  async v1CheckHealth(initOverrides?: RequestInit): Promise<string> {
    const response = await this.v1CheckHealthRaw(initOverrides);
    return await response.value();
  }

  /**
   * Open a websocket connection to a serial console on the specified VirtualMachineInstance.
   */
  async v1ConsoleRaw(
    requestParameters: V1ConsoleRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1Console.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1Console.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/console`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Open a websocket connection to a serial console on the specified VirtualMachineInstance.
   */
  async v1Console(requestParameters: V1ConsoleRequest, initOverrides?: RequestInit): Promise<void> {
    await this.v1ConsoleRaw(requestParameters, initOverrides);
  }

  /**
   * Get list of active filesystems on guest machine via guest agent
   */
  async v1FilesystemlistRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceFileSystemList>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/filesystemlist`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceFileSystemListFromJSON(jsonValue),
    );
  }

  /**
   * Get list of active filesystems on guest machine via guest agent
   */
  async v1Filesystemlist(
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceFileSystemList> {
    const response = await this.v1FilesystemlistRaw(initOverrides);
    return await response.value();
  }

  /**
   * Freeze a VirtualMachineInstance object.
   */
  async v1FreezeRaw(
    requestParameters: V1FreezeRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1Freeze.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1Freeze.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1Freeze.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/freeze`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1FreezeUnfreezeTimeoutToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Freeze a VirtualMachineInstance object.
   */
  async v1Freeze(requestParameters: V1FreezeRequest, initOverrides?: RequestInit): Promise<string> {
    const response = await this.v1FreezeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   */
  async v1GuestfsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/guestfs`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   */
  async v1Guestfs(initOverrides?: RequestInit): Promise<string> {
    const response = await this.v1GuestfsRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get guest agent os information
   */
  async v1GuestosinfoRaw(
    requestParameters: V1GuestosinfoRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceGuestAgentInfo>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1Guestosinfo.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1Guestosinfo.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/guestosinfo`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceGuestAgentInfoFromJSON(jsonValue),
    );
  }

  /**
   * Get guest agent os information
   */
  async v1Guestosinfo(
    requestParameters: V1GuestosinfoRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceGuestAgentInfo> {
    const response = await this.v1GuestosinfoRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Dumps a VirtualMachineInstance memory.
   */
  async v1MemoryDumpRaw(
    requestParameters: V1MemoryDumpRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1MemoryDump.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1MemoryDump.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1MemoryDump.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/memorydump`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1VirtualMachineMemoryDumpRequestToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Dumps a VirtualMachineInstance memory.
   */
  async v1MemoryDump(
    requestParameters: V1MemoryDumpRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1MemoryDumpRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Migrate a running VirtualMachine to another node.
   */
  async v1MigrateRaw(
    requestParameters: V1MigrateRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1Migrate.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1Migrate.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1Migrate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/migrate`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1MigrateOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Migrate a running VirtualMachine to another node.
   */
  async v1Migrate(
    requestParameters: V1MigrateRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1MigrateRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Pause a VirtualMachineInstance object.
   */
  async v1PauseRaw(
    requestParameters: V1PauseRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1Pause.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1Pause.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1Pause.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/pause`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1PauseOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Pause a VirtualMachineInstance object.
   */
  async v1Pause(requestParameters: V1PauseRequest, initOverrides?: RequestInit): Promise<string> {
    const response = await this.v1PauseRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Remove memory dump association.
   */
  async v1RemoveMemoryDumpRaw(
    requestParameters: V1RemoveMemoryDumpRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1RemoveMemoryDump.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1RemoveMemoryDump.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/removememorydump`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Remove memory dump association.
   */
  async v1RemoveMemoryDump(
    requestParameters: V1RemoveMemoryDumpRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1RemoveMemoryDumpRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Restart a VirtualMachine object.
   */
  async v1RestartRaw(
    requestParameters: V1RestartRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1Restart.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1Restart.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/restart`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1RestartOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Restart a VirtualMachine object.
   */
  async v1Restart(
    requestParameters: V1RestartRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1RestartRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Soft reboot a VirtualMachineInstance object.
   */
  async v1SoftRebootRaw(
    requestParameters: V1SoftRebootRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1SoftReboot.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1SoftReboot.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/softreboot`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Soft reboot a VirtualMachineInstance object.
   */
  async v1SoftReboot(
    requestParameters: V1SoftRebootRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1SoftRebootRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Start a VirtualMachine object.
   */
  async v1StartRaw(
    requestParameters: V1StartRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1Start.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1Start.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1Start.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/start`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1StartOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Start a VirtualMachine object.
   */
  async v1Start(requestParameters: V1StartRequest, initOverrides?: RequestInit): Promise<string> {
    const response = await this.v1StartRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Stop a VirtualMachine object.
   */
  async v1StopRaw(
    requestParameters: V1StopRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1Stop.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1Stop.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/stop`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1StopOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Stop a VirtualMachine object.
   */
  async v1Stop(requestParameters: V1StopRequest, initOverrides?: RequestInit): Promise<string> {
    const response = await this.v1StopRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Test endpoint verifying apiserver connectivity.
   */
  async v1TestRaw(
    requestParameters: V1TestRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1Test.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1Test.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/test`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Test endpoint verifying apiserver connectivity.
   */
  async v1Test(requestParameters: V1TestRequest, initOverrides?: RequestInit): Promise<void> {
    await this.v1TestRaw(requestParameters, initOverrides);
  }

  /**
   * Unfreeze a VirtualMachineInstance object.
   */
  async v1UnfreezeRaw(
    requestParameters: V1UnfreezeRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1Unfreeze.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1Unfreeze.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/unfreeze`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Unfreeze a VirtualMachineInstance object.
   */
  async v1Unfreeze(
    requestParameters: V1UnfreezeRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1UnfreezeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Unpause a VirtualMachineInstance object.
   */
  async v1UnpauseRaw(
    requestParameters: V1UnpauseRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1Unpause.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1Unpause.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1Unpause.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/unpause`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1UnpauseOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Unpause a VirtualMachineInstance object.
   */
  async v1Unpause(
    requestParameters: V1UnpauseRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1UnpauseRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get list of active users via guest agent
   */
  async v1UserlistRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceGuestOSUserList>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/userlist`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceGuestOSUserListFromJSON(jsonValue),
    );
  }

  /**
   * Get list of active users via guest agent
   */
  async v1Userlist(initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceGuestOSUserList> {
    const response = await this.v1UserlistRaw(initOverrides);
    return await response.value();
  }

  /**
   * Open a websocket connection to connect to VNC on the specified VirtualMachineInstance.
   */
  async v1VNCRaw(
    requestParameters: V1VNCRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1VNC.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1VNC.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/vnc`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Open a websocket connection to connect to VNC on the specified VirtualMachineInstance.
   */
  async v1VNC(requestParameters: V1VNCRequest, initOverrides?: RequestInit): Promise<void> {
    await this.v1VNCRaw(requestParameters, initOverrides);
  }

  /**
   */
  async v1VersionRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/version`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async v1Version(initOverrides?: RequestInit): Promise<void> {
    await this.v1VersionRaw(initOverrides);
  }

  /**
   * Health endpoint
   */
  async v1alpha3CheckHealthRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/healthz`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Health endpoint
   */
  async v1alpha3CheckHealth(initOverrides?: RequestInit): Promise<string> {
    const response = await this.v1alpha3CheckHealthRaw(initOverrides);
    return await response.value();
  }

  /**
   * Open a websocket connection to a serial console on the specified VirtualMachineInstance.
   */
  async v1alpha3ConsoleRaw(
    requestParameters: V1alpha3ConsoleRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3Console.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Console.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/console`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Open a websocket connection to a serial console on the specified VirtualMachineInstance.
   */
  async v1alpha3Console(
    requestParameters: V1alpha3ConsoleRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.v1alpha3ConsoleRaw(requestParameters, initOverrides);
  }

  /**
   * Get list of active filesystems on guest machine via guest agent
   */
  async v1alpha3FilesystemlistRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceFileSystemList>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/filesystemlist`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceFileSystemListFromJSON(jsonValue),
    );
  }

  /**
   * Get list of active filesystems on guest machine via guest agent
   */
  async v1alpha3Filesystemlist(
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceFileSystemList> {
    const response = await this.v1alpha3FilesystemlistRaw(initOverrides);
    return await response.value();
  }

  /**
   * Freeze a VirtualMachineInstance object.
   */
  async v1alpha3FreezeRaw(
    requestParameters: V1alpha3FreezeRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3Freeze.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Freeze.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1alpha3Freeze.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/freeze`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1FreezeUnfreezeTimeoutToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Freeze a VirtualMachineInstance object.
   */
  async v1alpha3Freeze(
    requestParameters: V1alpha3FreezeRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1alpha3FreezeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get a KubeVirt API Group
   */
  async v1alpha3GetSubAPIGroupRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue),
    );
  }

  /**
   * Get a KubeVirt API Group
   */
  async v1alpha3GetSubAPIGroup(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
    const response = await this.v1alpha3GetSubAPIGroupRaw(initOverrides);
    return await response.value();
  }

  /**
   */
  async v1alpha3GuestfsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/guestfs`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   */
  async v1alpha3Guestfs(initOverrides?: RequestInit): Promise<string> {
    const response = await this.v1alpha3GuestfsRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get guest agent os information
   */
  async v1alpha3GuestosinfoRaw(
    requestParameters: V1alpha3GuestosinfoRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceGuestAgentInfo>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3Guestosinfo.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Guestosinfo.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/guestosinfo`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceGuestAgentInfoFromJSON(jsonValue),
    );
  }

  /**
   * Get guest agent os information
   */
  async v1alpha3Guestosinfo(
    requestParameters: V1alpha3GuestosinfoRequest,
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceGuestAgentInfo> {
    const response = await this.v1alpha3GuestosinfoRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Dumps a VirtualMachineInstance memory.
   */
  async v1alpha3MemoryDumpRaw(
    requestParameters: V1alpha3MemoryDumpRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3MemoryDump.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3MemoryDump.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1alpha3MemoryDump.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/memorydump`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1VirtualMachineMemoryDumpRequestToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Dumps a VirtualMachineInstance memory.
   */
  async v1alpha3MemoryDump(
    requestParameters: V1alpha3MemoryDumpRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1alpha3MemoryDumpRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Migrate a running VirtualMachine to another node.
   */
  async v1alpha3MigrateRaw(
    requestParameters: V1alpha3MigrateRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3Migrate.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Migrate.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1alpha3Migrate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/migrate`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1MigrateOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Migrate a running VirtualMachine to another node.
   */
  async v1alpha3Migrate(
    requestParameters: V1alpha3MigrateRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1alpha3MigrateRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Pause a VirtualMachineInstance object.
   */
  async v1alpha3PauseRaw(
    requestParameters: V1alpha3PauseRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3Pause.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Pause.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1alpha3Pause.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/pause`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1PauseOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Pause a VirtualMachineInstance object.
   */
  async v1alpha3Pause(
    requestParameters: V1alpha3PauseRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1alpha3PauseRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Remove memory dump association.
   */
  async v1alpha3RemoveMemoryDumpRaw(
    requestParameters: V1alpha3RemoveMemoryDumpRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3RemoveMemoryDump.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3RemoveMemoryDump.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/removememorydump`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Remove memory dump association.
   */
  async v1alpha3RemoveMemoryDump(
    requestParameters: V1alpha3RemoveMemoryDumpRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1alpha3RemoveMemoryDumpRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Restart a VirtualMachine object.
   */
  async v1alpha3RestartRaw(
    requestParameters: V1alpha3RestartRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3Restart.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Restart.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/restart`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1RestartOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Restart a VirtualMachine object.
   */
  async v1alpha3Restart(
    requestParameters: V1alpha3RestartRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1alpha3RestartRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Soft reboot a VirtualMachineInstance object.
   */
  async v1alpha3SoftRebootRaw(
    requestParameters: V1alpha3SoftRebootRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3SoftReboot.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3SoftReboot.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/softreboot`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Soft reboot a VirtualMachineInstance object.
   */
  async v1alpha3SoftReboot(
    requestParameters: V1alpha3SoftRebootRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1alpha3SoftRebootRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Start a VirtualMachine object.
   */
  async v1alpha3StartRaw(
    requestParameters: V1alpha3StartRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3Start.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Start.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1alpha3Start.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/start`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1StartOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Start a VirtualMachine object.
   */
  async v1alpha3Start(
    requestParameters: V1alpha3StartRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1alpha3StartRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Stop a VirtualMachine object.
   */
  async v1alpha3StopRaw(
    requestParameters: V1alpha3StopRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3Stop.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Stop.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/stop`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1StopOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Stop a VirtualMachine object.
   */
  async v1alpha3Stop(
    requestParameters: V1alpha3StopRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1alpha3StopRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Test endpoint verifying apiserver connectivity.
   */
  async v1alpha3TestRaw(
    requestParameters: V1alpha3TestRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3Test.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Test.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/test`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Test endpoint verifying apiserver connectivity.
   */
  async v1alpha3Test(
    requestParameters: V1alpha3TestRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.v1alpha3TestRaw(requestParameters, initOverrides);
  }

  /**
   * Unfreeze a VirtualMachineInstance object.
   */
  async v1alpha3UnfreezeRaw(
    requestParameters: V1alpha3UnfreezeRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3Unfreeze.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Unfreeze.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/unfreeze`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Unfreeze a VirtualMachineInstance object.
   */
  async v1alpha3Unfreeze(
    requestParameters: V1alpha3UnfreezeRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1alpha3UnfreezeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Unpause a VirtualMachineInstance object.
   */
  async v1alpha3UnpauseRaw(
    requestParameters: V1alpha3UnpauseRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3Unpause.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Unpause.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1alpha3Unpause.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/unpause`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1UnpauseOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Unpause a VirtualMachineInstance object.
   */
  async v1alpha3Unpause(
    requestParameters: V1alpha3UnpauseRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1alpha3UnpauseRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get list of active users via guest agent
   */
  async v1alpha3UserlistRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<V1VirtualMachineInstanceGuestOSUserList>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/userlist`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      V1VirtualMachineInstanceGuestOSUserListFromJSON(jsonValue),
    );
  }

  /**
   * Get list of active users via guest agent
   */
  async v1alpha3Userlist(
    initOverrides?: RequestInit,
  ): Promise<V1VirtualMachineInstanceGuestOSUserList> {
    const response = await this.v1alpha3UserlistRaw(initOverrides);
    return await response.value();
  }

  /**
   * Open a websocket connection to connect to VNC on the specified VirtualMachineInstance.
   */
  async v1alpha3VNCRaw(
    requestParameters: V1alpha3VNCRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3VNC.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3VNC.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/vnc`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Open a websocket connection to connect to VNC on the specified VirtualMachineInstance.
   */
  async v1alpha3VNC(
    requestParameters: V1alpha3VNCRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.v1alpha3VNCRaw(requestParameters, initOverrides);
  }

  /**
   */
  async v1alpha3VersionRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/version`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async v1alpha3Version(initOverrides?: RequestInit): Promise<void> {
    await this.v1alpha3VersionRaw(initOverrides);
  }

  /**
   */
  async v1alpha3dumpClusterProfilerRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/dump-cluster-profiler`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async v1alpha3dumpClusterProfiler(initOverrides?: RequestInit): Promise<void> {
    await this.v1alpha3dumpClusterProfilerRaw(initOverrides);
  }

  /**
   * Get a KubeVirt API resources
   */
  async v1alpha3getAPISubResourcesRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue),
    );
  }

  /**
   * Get a KubeVirt API resources
   */
  async v1alpha3getAPISubResources(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
    const response = await this.v1alpha3getAPISubResourcesRaw(initOverrides);
    return await response.value();
  }

  /**
   */
  async v1alpha3startClusterProfilerRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/start-cluster-profiler`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async v1alpha3startClusterProfiler(initOverrides?: RequestInit): Promise<void> {
    await this.v1alpha3startClusterProfilerRaw(initOverrides);
  }

  /**
   */
  async v1alpha3stopClusterProfilerRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/stop-cluster-profiler`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async v1alpha3stopClusterProfiler(initOverrides?: RequestInit): Promise<void> {
    await this.v1alpha3stopClusterProfilerRaw(initOverrides);
  }

  /**
   * Open a websocket connection to connect to USB device on the specified VirtualMachineInstance.
   */
  async v1alpha3usbredirRaw(
    requestParameters: V1alpha3usbredirRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3usbredir.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3usbredir.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/usbredir`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Open a websocket connection to connect to USB device on the specified VirtualMachineInstance.
   */
  async v1alpha3usbredir(
    requestParameters: V1alpha3usbredirRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.v1alpha3usbredirRaw(requestParameters, initOverrides);
  }

  /**
   * Add a volume and disk to a running Virtual Machine.
   */
  async v1alpha3vmAddvolumeRaw(
    requestParameters: V1alpha3vmAddvolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3vmAddvolume.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmAddvolume.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1alpha3vmAddvolume.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/addvolume`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1AddVolumeOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Add a volume and disk to a running Virtual Machine.
   */
  async v1alpha3vmAddvolume(
    requestParameters: V1alpha3vmAddvolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1alpha3vmAddvolumeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Open a websocket connection forwarding traffic to the running VMI for the specified VirtualMachine and port.
   */
  async v1alpha3vmPortForwardRaw(
    requestParameters: V1alpha3vmPortForwardRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3vmPortForward.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmPortForward.',
      );
    }

    if (requestParameters.port === null || requestParameters.port === undefined) {
      throw new runtime.RequiredError(
        'port',
        'Required parameter requestParameters.port was null or undefined when calling v1alpha3vmPortForward.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/portforward/{port:[0-9]+}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
          .replace(`{${'port'}}`, encodeURIComponent(String(requestParameters.port))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Open a websocket connection forwarding traffic to the running VMI for the specified VirtualMachine and port.
   */
  async v1alpha3vmPortForward(
    requestParameters: V1alpha3vmPortForwardRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.v1alpha3vmPortForwardRaw(requestParameters, initOverrides);
  }

  /**
   * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachine and port.
   */
  async v1alpha3vmPortForwardWithProtocolRaw(
    requestParameters: V1alpha3vmPortForwardWithProtocolRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3vmPortForwardWithProtocol.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmPortForwardWithProtocol.',
      );
    }

    if (requestParameters.port === null || requestParameters.port === undefined) {
      throw new runtime.RequiredError(
        'port',
        'Required parameter requestParameters.port was null or undefined when calling v1alpha3vmPortForwardWithProtocol.',
      );
    }

    if (requestParameters.protocol === null || requestParameters.protocol === undefined) {
      throw new runtime.RequiredError(
        'protocol',
        'Required parameter requestParameters.protocol was null or undefined when calling v1alpha3vmPortForwardWithProtocol.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/portforward/{port:[0-9]+}/{protocol:tcp|udp}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
          .replace(`{${'port'}}`, encodeURIComponent(String(requestParameters.port)))
          .replace(`{${'protocol'}}`, encodeURIComponent(String(requestParameters.protocol))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachine and port.
   */
  async v1alpha3vmPortForwardWithProtocol(
    requestParameters: V1alpha3vmPortForwardWithProtocolRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.v1alpha3vmPortForwardWithProtocolRaw(requestParameters, initOverrides);
  }

  /**
   * Removes a volume and disk from a running Virtual Machine.
   */
  async v1alpha3vmRemovevolumeRaw(
    requestParameters: V1alpha3vmRemovevolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3vmRemovevolume.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmRemovevolume.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1alpha3vmRemovevolume.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/removevolume`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1RemoveVolumeOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Removes a volume and disk from a running Virtual Machine.
   */
  async v1alpha3vmRemovevolume(
    requestParameters: V1alpha3vmRemovevolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1alpha3vmRemovevolumeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Add a volume and disk to a running Virtual Machine Instance
   */
  async v1alpha3vmiAddvolumeRaw(
    requestParameters: V1alpha3vmiAddvolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3vmiAddvolume.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmiAddvolume.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1alpha3vmiAddvolume.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/addvolume`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1AddVolumeOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Add a volume and disk to a running Virtual Machine Instance
   */
  async v1alpha3vmiAddvolume(
    requestParameters: V1alpha3vmiAddvolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1alpha3vmiAddvolumeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port.
   */
  async v1alpha3vmiPortForwardRaw(
    requestParameters: V1alpha3vmiPortForwardRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3vmiPortForward.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmiPortForward.',
      );
    }

    if (requestParameters.port === null || requestParameters.port === undefined) {
      throw new runtime.RequiredError(
        'port',
        'Required parameter requestParameters.port was null or undefined when calling v1alpha3vmiPortForward.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/portforward/{port:[0-9]+}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
          .replace(`{${'port'}}`, encodeURIComponent(String(requestParameters.port))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port.
   */
  async v1alpha3vmiPortForward(
    requestParameters: V1alpha3vmiPortForwardRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.v1alpha3vmiPortForwardRaw(requestParameters, initOverrides);
  }

  /**
   * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachineInstance and port.
   */
  async v1alpha3vmiPortForwardWithProtocolRaw(
    requestParameters: V1alpha3vmiPortForwardWithProtocolRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3vmiPortForwardWithProtocol.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmiPortForwardWithProtocol.',
      );
    }

    if (requestParameters.port === null || requestParameters.port === undefined) {
      throw new runtime.RequiredError(
        'port',
        'Required parameter requestParameters.port was null or undefined when calling v1alpha3vmiPortForwardWithProtocol.',
      );
    }

    if (requestParameters.protocol === null || requestParameters.protocol === undefined) {
      throw new runtime.RequiredError(
        'protocol',
        'Required parameter requestParameters.protocol was null or undefined when calling v1alpha3vmiPortForwardWithProtocol.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/portforward/{port:[0-9]+}/{protocol:tcp|udp}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
          .replace(`{${'port'}}`, encodeURIComponent(String(requestParameters.port)))
          .replace(`{${'protocol'}}`, encodeURIComponent(String(requestParameters.protocol))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachineInstance and port.
   */
  async v1alpha3vmiPortForwardWithProtocol(
    requestParameters: V1alpha3vmiPortForwardWithProtocolRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.v1alpha3vmiPortForwardWithProtocolRaw(requestParameters, initOverrides);
  }

  /**
   * Removes a volume and disk from a running Virtual Machine Instance
   */
  async v1alpha3vmiRemovevolumeRaw(
    requestParameters: V1alpha3vmiRemovevolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1alpha3vmiRemovevolume.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmiRemovevolume.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1alpha3vmiRemovevolume.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/removevolume`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1RemoveVolumeOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Removes a volume and disk from a running Virtual Machine Instance
   */
  async v1alpha3vmiRemovevolume(
    requestParameters: V1alpha3vmiRemovevolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1alpha3vmiRemovevolumeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   */
  async v1dumpClusterProfilerRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/dump-cluster-profiler`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async v1dumpClusterProfiler(initOverrides?: RequestInit): Promise<void> {
    await this.v1dumpClusterProfilerRaw(initOverrides);
  }

  /**
   * Get a KubeVirt API resources
   */
  async v1getAPISubResourcesRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue),
    );
  }

  /**
   * Get a KubeVirt API resources
   */
  async v1getAPISubResources(
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
    const response = await this.v1getAPISubResourcesRaw(initOverrides);
    return await response.value();
  }

  /**
   */
  async v1startClusterProfilerRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/start-cluster-profiler`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async v1startClusterProfiler(initOverrides?: RequestInit): Promise<void> {
    await this.v1startClusterProfilerRaw(initOverrides);
  }

  /**
   */
  async v1stopClusterProfilerRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/stop-cluster-profiler`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async v1stopClusterProfiler(initOverrides?: RequestInit): Promise<void> {
    await this.v1stopClusterProfilerRaw(initOverrides);
  }

  /**
   * Open a websocket connection to connect to USB device on the specified VirtualMachineInstance.
   */
  async v1usbredirRaw(
    requestParameters: V1usbredirRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1usbredir.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1usbredir.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/usbredir`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Open a websocket connection to connect to USB device on the specified VirtualMachineInstance.
   */
  async v1usbredir(
    requestParameters: V1usbredirRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.v1usbredirRaw(requestParameters, initOverrides);
  }

  /**
   * Add a volume and disk to a running Virtual Machine.
   */
  async v1vmAddvolumeRaw(
    requestParameters: V1vmAddvolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1vmAddvolume.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1vmAddvolume.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1vmAddvolume.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/addvolume`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1AddVolumeOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Add a volume and disk to a running Virtual Machine.
   */
  async v1vmAddvolume(
    requestParameters: V1vmAddvolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1vmAddvolumeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Open a websocket connection forwarding traffic to the running VMI for the specified VirtualMachine and port.
   */
  async v1vmPortForwardRaw(
    requestParameters: V1vmPortForwardRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1vmPortForward.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1vmPortForward.',
      );
    }

    if (requestParameters.port === null || requestParameters.port === undefined) {
      throw new runtime.RequiredError(
        'port',
        'Required parameter requestParameters.port was null or undefined when calling v1vmPortForward.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/portforward/{port:[0-9]+}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
          .replace(`{${'port'}}`, encodeURIComponent(String(requestParameters.port))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Open a websocket connection forwarding traffic to the running VMI for the specified VirtualMachine and port.
   */
  async v1vmPortForward(
    requestParameters: V1vmPortForwardRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.v1vmPortForwardRaw(requestParameters, initOverrides);
  }

  /**
   * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachine and port.
   */
  async v1vmPortForwardWithProtocolRaw(
    requestParameters: V1vmPortForwardWithProtocolRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1vmPortForwardWithProtocol.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1vmPortForwardWithProtocol.',
      );
    }

    if (requestParameters.port === null || requestParameters.port === undefined) {
      throw new runtime.RequiredError(
        'port',
        'Required parameter requestParameters.port was null or undefined when calling v1vmPortForwardWithProtocol.',
      );
    }

    if (requestParameters.protocol === null || requestParameters.protocol === undefined) {
      throw new runtime.RequiredError(
        'protocol',
        'Required parameter requestParameters.protocol was null or undefined when calling v1vmPortForwardWithProtocol.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/portforward/{port:[0-9]+}/{protocol:tcp|udp}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
          .replace(`{${'port'}}`, encodeURIComponent(String(requestParameters.port)))
          .replace(`{${'protocol'}}`, encodeURIComponent(String(requestParameters.protocol))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachine and port.
   */
  async v1vmPortForwardWithProtocol(
    requestParameters: V1vmPortForwardWithProtocolRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.v1vmPortForwardWithProtocolRaw(requestParameters, initOverrides);
  }

  /**
   * Removes a volume and disk from a running Virtual Machine.
   */
  async v1vmRemovevolumeRaw(
    requestParameters: V1vmRemovevolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1vmRemovevolume.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1vmRemovevolume.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1vmRemovevolume.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines/{name:[a-z0-9][a-z0-9\-]*}/removevolume`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1RemoveVolumeOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Removes a volume and disk from a running Virtual Machine.
   */
  async v1vmRemovevolume(
    requestParameters: V1vmRemovevolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1vmRemovevolumeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Add a volume and disk to a running Virtual Machine Instance
   */
  async v1vmiAddvolumeRaw(
    requestParameters: V1vmiAddvolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1vmiAddvolume.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1vmiAddvolume.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1vmiAddvolume.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/addvolume`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1AddVolumeOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Add a volume and disk to a running Virtual Machine Instance
   */
  async v1vmiAddvolume(
    requestParameters: V1vmiAddvolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1vmiAddvolumeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port.
   */
  async v1vmiPortForwardRaw(
    requestParameters: V1vmiPortForwardRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1vmiPortForward.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1vmiPortForward.',
      );
    }

    if (requestParameters.port === null || requestParameters.port === undefined) {
      throw new runtime.RequiredError(
        'port',
        'Required parameter requestParameters.port was null or undefined when calling v1vmiPortForward.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/portforward/{port:[0-9]+}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
          .replace(`{${'port'}}`, encodeURIComponent(String(requestParameters.port))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port.
   */
  async v1vmiPortForward(
    requestParameters: V1vmiPortForwardRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.v1vmiPortForwardRaw(requestParameters, initOverrides);
  }

  /**
   * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachineInstance and port.
   */
  async v1vmiPortForwardWithProtocolRaw(
    requestParameters: V1vmiPortForwardWithProtocolRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1vmiPortForwardWithProtocol.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1vmiPortForwardWithProtocol.',
      );
    }

    if (requestParameters.port === null || requestParameters.port === undefined) {
      throw new runtime.RequiredError(
        'port',
        'Required parameter requestParameters.port was null or undefined when calling v1vmiPortForwardWithProtocol.',
      );
    }

    if (requestParameters.protocol === null || requestParameters.protocol === undefined) {
      throw new runtime.RequiredError(
        'protocol',
        'Required parameter requestParameters.protocol was null or undefined when calling v1vmiPortForwardWithProtocol.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/portforward/{port:[0-9]+}/{protocol:tcp|udp}`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
          .replace(`{${'port'}}`, encodeURIComponent(String(requestParameters.port)))
          .replace(`{${'protocol'}}`, encodeURIComponent(String(requestParameters.protocol))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachineInstance and port.
   */
  async v1vmiPortForwardWithProtocol(
    requestParameters: V1vmiPortForwardWithProtocolRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.v1vmiPortForwardWithProtocolRaw(requestParameters, initOverrides);
  }

  /**
   * Removes a volume and disk from a running Virtual Machine Instance
   */
  async v1vmiRemovevolumeRaw(
    requestParameters: V1vmiRemovevolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling v1vmiRemovevolume.',
      );
    }

    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling v1vmiRemovevolume.',
      );
    }

    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter requestParameters.body was null or undefined when calling v1vmiRemovevolume.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances/{name:[a-z0-9][a-z0-9\-]*}/removevolume`
          .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
          .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: V1RemoveVolumeOptionsToJSON(requestParameters.body),
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Removes a volume and disk from a running Virtual Machine Instance
   */
  async v1vmiRemovevolume(
    requestParameters: V1vmiRemovevolumeRequest,
    initOverrides?: RequestInit,
  ): Promise<string> {
    const response = await this.v1vmiRemovevolumeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Watch a KubeVirtList object.
   */
  async watchKubeVirtListForAllNamespacesRaw(
    requestParameters: WatchKubeVirtListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/watch/kubevirt`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a KubeVirtList object.
   */
  async watchKubeVirtListForAllNamespaces(
    requestParameters: WatchKubeVirtListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchKubeVirtListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a MigrationPolicyList object.
   */
  async watchMigrationPolicyListForAllNamespacesRaw(
    requestParameters: WatchMigrationPolicyListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/migrations.kubevirt.io/v1alpha1/watch/migrationpolicies`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a MigrationPolicyList object.
   */
  async watchMigrationPolicyListForAllNamespaces(
    requestParameters: WatchMigrationPolicyListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchMigrationPolicyListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a KubeVirt object.
   */
  async watchNamespacedKubeVirtRaw(
    requestParameters: WatchNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedKubeVirt.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/watch/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/kubevirt`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a KubeVirt object.
   */
  async watchNamespacedKubeVirt(
    requestParameters: WatchNamespacedKubeVirtRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchNamespacedKubeVirtRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Watch a VirtualMachine object.
   */
  async watchNamespacedVirtualMachineRaw(
    requestParameters: WatchNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachine.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/watch/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachines`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachine object.
   */
  async watchNamespacedVirtualMachine(
    requestParameters: WatchNamespacedVirtualMachineRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchNamespacedVirtualMachineRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Watch a VirtualMachineExport object.
   */
  async watchNamespacedVirtualMachineExportRaw(
    requestParameters: WatchNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineExport.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/export.kubevirt.io/v1alpha1/watch/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineexports`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineExport object.
   */
  async watchNamespacedVirtualMachineExport(
    requestParameters: WatchNamespacedVirtualMachineExportRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchNamespacedVirtualMachineExportRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineFlavor object.
   */
  async watchNamespacedVirtualMachineFlavorRaw(
    requestParameters: WatchNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineFlavor.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/watch/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineflavors`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineFlavor object.
   */
  async watchNamespacedVirtualMachineFlavor(
    requestParameters: WatchNamespacedVirtualMachineFlavorRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchNamespacedVirtualMachineFlavorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineInstance object.
   */
  async watchNamespacedVirtualMachineInstanceRaw(
    requestParameters: WatchNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineInstance.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/watch/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstances`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineInstance object.
   */
  async watchNamespacedVirtualMachineInstance(
    requestParameters: WatchNamespacedVirtualMachineInstanceRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchNamespacedVirtualMachineInstanceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineInstanceMigration object.
   */
  async watchNamespacedVirtualMachineInstanceMigrationRaw(
    requestParameters: WatchNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineInstanceMigration.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/watch/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancemigrations`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineInstanceMigration object.
   */
  async watchNamespacedVirtualMachineInstanceMigration(
    requestParameters: WatchNamespacedVirtualMachineInstanceMigrationRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchNamespacedVirtualMachineInstanceMigrationRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineInstancePreset object.
   */
  async watchNamespacedVirtualMachineInstancePresetRaw(
    requestParameters: WatchNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineInstancePreset.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/watch/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancepresets`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineInstancePreset object.
   */
  async watchNamespacedVirtualMachineInstancePreset(
    requestParameters: WatchNamespacedVirtualMachineInstancePresetRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchNamespacedVirtualMachineInstancePresetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineInstanceReplicaSet object.
   */
  async watchNamespacedVirtualMachineInstanceReplicaSetRaw(
    requestParameters: WatchNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineInstanceReplicaSet.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/watch/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachineinstancereplicasets`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineInstanceReplicaSet object.
   */
  async watchNamespacedVirtualMachineInstanceReplicaSet(
    requestParameters: WatchNamespacedVirtualMachineInstanceReplicaSetRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchNamespacedVirtualMachineInstanceReplicaSetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachinePool object.
   */
  async watchNamespacedVirtualMachinePoolRaw(
    requestParameters: WatchNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachinePool.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/pool.kubevirt.io/v1alpha1/watch/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepools`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachinePool object.
   */
  async watchNamespacedVirtualMachinePool(
    requestParameters: WatchNamespacedVirtualMachinePoolRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchNamespacedVirtualMachinePoolRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachinePreference object.
   */
  async watchNamespacedVirtualMachinePreferenceRaw(
    requestParameters: WatchNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachinePreference.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/watch/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinepreferences`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachinePreference object.
   */
  async watchNamespacedVirtualMachinePreference(
    requestParameters: WatchNamespacedVirtualMachinePreferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchNamespacedVirtualMachinePreferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineRestore object.
   */
  async watchNamespacedVirtualMachineRestoreRaw(
    requestParameters: WatchNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineRestore.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/watch/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinerestores`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineRestore object.
   */
  async watchNamespacedVirtualMachineRestore(
    requestParameters: WatchNamespacedVirtualMachineRestoreRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchNamespacedVirtualMachineRestoreRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineSnapshot object.
   */
  async watchNamespacedVirtualMachineSnapshotRaw(
    requestParameters: WatchNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineSnapshot.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/watch/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshots`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineSnapshot object.
   */
  async watchNamespacedVirtualMachineSnapshot(
    requestParameters: WatchNamespacedVirtualMachineSnapshotRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchNamespacedVirtualMachineSnapshotRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineSnapshotContent object.
   */
  async watchNamespacedVirtualMachineSnapshotContentRaw(
    requestParameters: WatchNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new runtime.RequiredError(
        'namespace',
        'Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineSnapshotContent.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/watch/namespaces/{namespace:[a-z0-9][a-z0-9\-]*}/virtualmachinesnapshotcontents`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineSnapshotContent object.
   */
  async watchNamespacedVirtualMachineSnapshotContent(
    requestParameters: WatchNamespacedVirtualMachineSnapshotContentRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchNamespacedVirtualMachineSnapshotContentRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineCloneList object.
   */
  async watchVirtualMachineCloneListForAllNamespacesRaw(
    requestParameters: WatchVirtualMachineCloneListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/clone.kubevirt.io/v1alpha1/watch/virtualmachineclones`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineCloneList object.
   */
  async watchVirtualMachineCloneListForAllNamespaces(
    requestParameters: WatchVirtualMachineCloneListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchVirtualMachineCloneListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineClusterFlavorList object.
   */
  async watchVirtualMachineClusterFlavorListForAllNamespacesRaw(
    requestParameters: WatchVirtualMachineClusterFlavorListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/watch/virtualmachineclusterflavors`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineClusterFlavorList object.
   */
  async watchVirtualMachineClusterFlavorListForAllNamespaces(
    requestParameters: WatchVirtualMachineClusterFlavorListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchVirtualMachineClusterFlavorListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineClusterPreferenceList object.
   */
  async watchVirtualMachineClusterPreferenceListForAllNamespacesRaw(
    requestParameters: WatchVirtualMachineClusterPreferenceListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/watch/virtualmachineclusterpreferences`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineClusterPreferenceList object.
   */
  async watchVirtualMachineClusterPreferenceListForAllNamespaces(
    requestParameters: WatchVirtualMachineClusterPreferenceListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchVirtualMachineClusterPreferenceListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineExportList object.
   */
  async watchVirtualMachineExportListForAllNamespacesRaw(
    requestParameters: WatchVirtualMachineExportListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/export.kubevirt.io/v1alpha1/watch/virtualmachineexports`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineExportList object.
   */
  async watchVirtualMachineExportListForAllNamespaces(
    requestParameters: WatchVirtualMachineExportListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchVirtualMachineExportListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineFlavorList object.
   */
  async watchVirtualMachineFlavorListForAllNamespacesRaw(
    requestParameters: WatchVirtualMachineFlavorListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/watch/virtualmachineflavors`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineFlavorList object.
   */
  async watchVirtualMachineFlavorListForAllNamespaces(
    requestParameters: WatchVirtualMachineFlavorListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchVirtualMachineFlavorListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineInstanceList object.
   */
  async watchVirtualMachineInstanceListForAllNamespacesRaw(
    requestParameters: WatchVirtualMachineInstanceListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/watch/virtualmachineinstances`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineInstanceList object.
   */
  async watchVirtualMachineInstanceListForAllNamespaces(
    requestParameters: WatchVirtualMachineInstanceListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchVirtualMachineInstanceListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineInstanceMigrationList object.
   */
  async watchVirtualMachineInstanceMigrationListForAllNamespacesRaw(
    requestParameters: WatchVirtualMachineInstanceMigrationListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/watch/virtualmachineinstancemigrations`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineInstanceMigrationList object.
   */
  async watchVirtualMachineInstanceMigrationListForAllNamespaces(
    requestParameters: WatchVirtualMachineInstanceMigrationListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchVirtualMachineInstanceMigrationListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineInstancePresetList object.
   */
  async watchVirtualMachineInstancePresetListForAllNamespacesRaw(
    requestParameters: WatchVirtualMachineInstancePresetListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/watch/virtualmachineinstancepresets`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineInstancePresetList object.
   */
  async watchVirtualMachineInstancePresetListForAllNamespaces(
    requestParameters: WatchVirtualMachineInstancePresetListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchVirtualMachineInstancePresetListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineInstanceReplicaSetList object.
   */
  async watchVirtualMachineInstanceReplicaSetListForAllNamespacesRaw(
    requestParameters: WatchVirtualMachineInstanceReplicaSetListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/watch/virtualmachineinstancereplicasets`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineInstanceReplicaSetList object.
   */
  async watchVirtualMachineInstanceReplicaSetListForAllNamespaces(
    requestParameters: WatchVirtualMachineInstanceReplicaSetListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchVirtualMachineInstanceReplicaSetListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineList object.
   */
  async watchVirtualMachineListForAllNamespacesRaw(
    requestParameters: WatchVirtualMachineListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/kubevirt.io/v1/watch/virtualmachines`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineList object.
   */
  async watchVirtualMachineListForAllNamespaces(
    requestParameters: WatchVirtualMachineListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchVirtualMachineListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachinePoolList object.
   */
  async watchVirtualMachinePoolListForAllNamespacesRaw(
    requestParameters: WatchVirtualMachinePoolListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/pool.kubevirt.io/v1alpha1/watch/virtualmachinepools`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachinePoolList object.
   */
  async watchVirtualMachinePoolListForAllNamespaces(
    requestParameters: WatchVirtualMachinePoolListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchVirtualMachinePoolListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachinePreferenceList object.
   */
  async watchVirtualMachinePreferenceListForAllNamespacesRaw(
    requestParameters: WatchVirtualMachinePreferenceListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/flavor.kubevirt.io/v1alpha1/watch/virtualmachinepreferences`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachinePreferenceList object.
   */
  async watchVirtualMachinePreferenceListForAllNamespaces(
    requestParameters: WatchVirtualMachinePreferenceListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchVirtualMachinePreferenceListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineRestoreList object.
   */
  async watchVirtualMachineRestoreListForAllNamespacesRaw(
    requestParameters: WatchVirtualMachineRestoreListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/watch/virtualmachinerestores`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineRestoreList object.
   */
  async watchVirtualMachineRestoreListForAllNamespaces(
    requestParameters: WatchVirtualMachineRestoreListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchVirtualMachineRestoreListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineSnapshotContentList object.
   */
  async watchVirtualMachineSnapshotContentListForAllNamespacesRaw(
    requestParameters: WatchVirtualMachineSnapshotContentListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/watch/virtualmachinesnapshotcontents`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineSnapshotContentList object.
   */
  async watchVirtualMachineSnapshotContentListForAllNamespaces(
    requestParameters: WatchVirtualMachineSnapshotContentListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchVirtualMachineSnapshotContentListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Watch a VirtualMachineSnapshotList object.
   */
  async watchVirtualMachineSnapshotListForAllNamespacesRaw(
    requestParameters: WatchVirtualMachineSnapshotListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
    const queryParameters: any = {};

    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue;
    }

    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector;
    }

    if (requestParameters.includeUninitialized !== undefined) {
      queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
    }

    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion;
    }

    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
    }

    if (requestParameters.watch !== undefined) {
      queryParameters['watch'] = requestParameters.watch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/apis/snapshot.kubevirt.io/v1alpha1/watch/virtualmachinesnapshots`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue),
    );
  }

  /**
   * Watch a VirtualMachineSnapshotList object.
   */
  async watchVirtualMachineSnapshotListForAllNamespaces(
    requestParameters: WatchVirtualMachineSnapshotListForAllNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
    const response = await this.watchVirtualMachineSnapshotListForAllNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }
}
