/* tslint:disable */
/* eslint-disable */
/**
 * KubeVirt API
 * This is KubeVirt API an add-on for Kubernetes.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: kubevirt-dev@googlegroups.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import {
    V1DHCPOptions,
    V1DHCPOptionsFromJSON,
    V1DHCPOptionsFromJSONTyped,
    V1DHCPOptionsToJSON,
    V1Port,
    V1PortFromJSON,
    V1PortFromJSONTyped,
    V1PortToJSON,
} from './';

/**
 * 
 * @export
 * @interface V1Interface
 */
export interface V1Interface {
    /**
     * BootOrder is an integer value > 0, used to determine ordering of boot devices. Lower values take precedence. Each interface or disk that has a boot order must have a unique value. Interfaces without a boot order are not tried.
     * @type {number}
     * @memberof V1Interface
     */
    bootOrder?: number;
    /**
     * InterfaceBridge connects to a given network via a linux bridge.
     * @type {object}
     * @memberof V1Interface
     */
    bridge?: object;
    /**
     * 
     * @type {V1DHCPOptions}
     * @memberof V1Interface
     */
    dhcpOptions?: V1DHCPOptions;
    /**
     * Interface MAC address. For example: de:ad:00:00:be:af or DE-AD-00-00-BE-AF.
     * @type {string}
     * @memberof V1Interface
     */
    macAddress?: string;
    /**
     * InterfaceMacvtap connects to a given network by extending the Kubernetes node's L2 networks via a macvtap interface.
     * @type {object}
     * @memberof V1Interface
     */
    macvtap?: object;
    /**
     * InterfaceMasquerade connects to a given network using netfilter rules to nat the traffic.
     * @type {object}
     * @memberof V1Interface
     */
    masquerade?: object;
    /**
     * Interface model. One of: e1000, e1000e, ne2k_pci, pcnet, rtl8139, virtio. Defaults to virtio.
     * @type {string}
     * @memberof V1Interface
     */
    model?: string;
    /**
     * Logical name of the interface as well as a reference to the associated networks. Must match the Name of a Network.
     * @type {string}
     * @memberof V1Interface
     */
    name: string;
    /**
     * If specified, the virtual network interface will be placed on the guests pci address with the specified PCI address. For example: 0000:81:01.10
     * @type {string}
     * @memberof V1Interface
     */
    pciAddress?: string;
    /**
     * List of ports to be forwarded to the virtual machine.
     * @type {Array<V1Port>}
     * @memberof V1Interface
     */
    ports?: Array<V1Port>;
    /**
     * InterfaceSlirp connects to a given network using QEMU user networking mode.
     * @type {object}
     * @memberof V1Interface
     */
    slirp?: object;
    /**
     * InterfaceSRIOV connects to a given network by passing-through an SR-IOV PCI device via vfio.
     * @type {object}
     * @memberof V1Interface
     */
    sriov?: object;
    /**
     * If specified, the virtual network interface address and its tag will be provided to the guest via config drive
     * @type {string}
     * @memberof V1Interface
     */
    tag?: string;
}

export function V1InterfaceFromJSON(json: any): V1Interface {
    return V1InterfaceFromJSONTyped(json, false);
}

export function V1InterfaceFromJSONTyped(json: any, ignoreDiscriminator: boolean): V1Interface {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'bootOrder': !exists(json, 'bootOrder') ? undefined : json['bootOrder'],
        'bridge': !exists(json, 'bridge') ? undefined : json['bridge'],
        'dhcpOptions': !exists(json, 'dhcpOptions') ? undefined : V1DHCPOptionsFromJSON(json['dhcpOptions']),
        'macAddress': !exists(json, 'macAddress') ? undefined : json['macAddress'],
        'macvtap': !exists(json, 'macvtap') ? undefined : json['macvtap'],
        'masquerade': !exists(json, 'masquerade') ? undefined : json['masquerade'],
        'model': !exists(json, 'model') ? undefined : json['model'],
        'name': json['name'],
        'pciAddress': !exists(json, 'pciAddress') ? undefined : json['pciAddress'],
        'ports': !exists(json, 'ports') ? undefined : ((json['ports'] as Array<any>).map(V1PortFromJSON)),
        'slirp': !exists(json, 'slirp') ? undefined : json['slirp'],
        'sriov': !exists(json, 'sriov') ? undefined : json['sriov'],
        'tag': !exists(json, 'tag') ? undefined : json['tag'],
    };
}

export function V1InterfaceToJSON(value?: V1Interface | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'bootOrder': value.bootOrder,
        'bridge': value.bridge,
        'dhcpOptions': V1DHCPOptionsToJSON(value.dhcpOptions),
        'macAddress': value.macAddress,
        'macvtap': value.macvtap,
        'masquerade': value.masquerade,
        'model': value.model,
        'name': value.name,
        'pciAddress': value.pciAddress,
        'ports': value.ports === undefined ? undefined : ((value.ports as Array<any>).map(V1PortToJSON)),
        'slirp': value.slirp,
        'sriov': value.sriov,
        'tag': value.tag,
    };
}

