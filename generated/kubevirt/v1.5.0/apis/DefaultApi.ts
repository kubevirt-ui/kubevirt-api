/* tslint:disable */
/* eslint-disable */
/**
 * KubeVirt API
 * This is KubeVirt API an add-on for Kubernetes.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: kubevirt-dev@googlegroups.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    K8sIoApimachineryPkgApisMetaV1APIGroup,
    K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON,
    K8sIoApimachineryPkgApisMetaV1APIGroupToJSON,
    K8sIoApimachineryPkgApisMetaV1APIGroupList,
    K8sIoApimachineryPkgApisMetaV1APIGroupListFromJSON,
    K8sIoApimachineryPkgApisMetaV1APIGroupListToJSON,
    K8sIoApimachineryPkgApisMetaV1APIResourceList,
    K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON,
    K8sIoApimachineryPkgApisMetaV1APIResourceListToJSON,
    K8sIoApimachineryPkgApisMetaV1DeleteOptions,
    K8sIoApimachineryPkgApisMetaV1DeleteOptionsFromJSON,
    K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON,
    K8sIoApimachineryPkgApisMetaV1RootPaths,
    K8sIoApimachineryPkgApisMetaV1RootPathsFromJSON,
    K8sIoApimachineryPkgApisMetaV1RootPathsToJSON,
    K8sIoApimachineryPkgApisMetaV1Status,
    K8sIoApimachineryPkgApisMetaV1StatusFromJSON,
    K8sIoApimachineryPkgApisMetaV1StatusToJSON,
    K8sIoApimachineryPkgApisMetaV1WatchEvent,
    K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON,
    K8sIoApimachineryPkgApisMetaV1WatchEventToJSON,
    V1AddVolumeOptions,
    V1AddVolumeOptionsFromJSON,
    V1AddVolumeOptionsToJSON,
    V1FreezeUnfreezeTimeout,
    V1FreezeUnfreezeTimeoutFromJSON,
    V1FreezeUnfreezeTimeoutToJSON,
    V1KubeVirt,
    V1KubeVirtFromJSON,
    V1KubeVirtToJSON,
    V1KubeVirtList,
    V1KubeVirtListFromJSON,
    V1KubeVirtListToJSON,
    V1MigrateOptions,
    V1MigrateOptionsFromJSON,
    V1MigrateOptionsToJSON,
    V1PauseOptions,
    V1PauseOptionsFromJSON,
    V1PauseOptionsToJSON,
    V1RemoveVolumeOptions,
    V1RemoveVolumeOptionsFromJSON,
    V1RemoveVolumeOptionsToJSON,
    V1RestartOptions,
    V1RestartOptionsFromJSON,
    V1RestartOptionsToJSON,
    V1SEVMeasurementInfo,
    V1SEVMeasurementInfoFromJSON,
    V1SEVMeasurementInfoToJSON,
    V1SEVPlatformInfo,
    V1SEVPlatformInfoFromJSON,
    V1SEVPlatformInfoToJSON,
    V1SEVSecretOptions,
    V1SEVSecretOptionsFromJSON,
    V1SEVSecretOptionsToJSON,
    V1SEVSessionOptions,
    V1SEVSessionOptionsFromJSON,
    V1SEVSessionOptionsToJSON,
    V1StartOptions,
    V1StartOptionsFromJSON,
    V1StartOptionsToJSON,
    V1StopOptions,
    V1StopOptionsFromJSON,
    V1StopOptionsToJSON,
    V1UnpauseOptions,
    V1UnpauseOptionsFromJSON,
    V1UnpauseOptionsToJSON,
    V1VirtualMachine,
    V1VirtualMachineFromJSON,
    V1VirtualMachineToJSON,
    V1VirtualMachineInstance,
    V1VirtualMachineInstanceFromJSON,
    V1VirtualMachineInstanceToJSON,
    V1VirtualMachineInstanceFileSystemList,
    V1VirtualMachineInstanceFileSystemListFromJSON,
    V1VirtualMachineInstanceFileSystemListToJSON,
    V1VirtualMachineInstanceGuestAgentInfo,
    V1VirtualMachineInstanceGuestAgentInfoFromJSON,
    V1VirtualMachineInstanceGuestAgentInfoToJSON,
    V1VirtualMachineInstanceGuestOSUserList,
    V1VirtualMachineInstanceGuestOSUserListFromJSON,
    V1VirtualMachineInstanceGuestOSUserListToJSON,
    V1VirtualMachineInstanceList,
    V1VirtualMachineInstanceListFromJSON,
    V1VirtualMachineInstanceListToJSON,
    V1VirtualMachineInstanceMigration,
    V1VirtualMachineInstanceMigrationFromJSON,
    V1VirtualMachineInstanceMigrationToJSON,
    V1VirtualMachineInstanceMigrationList,
    V1VirtualMachineInstanceMigrationListFromJSON,
    V1VirtualMachineInstanceMigrationListToJSON,
    V1VirtualMachineInstancePreset,
    V1VirtualMachineInstancePresetFromJSON,
    V1VirtualMachineInstancePresetToJSON,
    V1VirtualMachineInstancePresetList,
    V1VirtualMachineInstancePresetListFromJSON,
    V1VirtualMachineInstancePresetListToJSON,
    V1VirtualMachineInstanceReplicaSet,
    V1VirtualMachineInstanceReplicaSetFromJSON,
    V1VirtualMachineInstanceReplicaSetToJSON,
    V1VirtualMachineInstanceReplicaSetList,
    V1VirtualMachineInstanceReplicaSetListFromJSON,
    V1VirtualMachineInstanceReplicaSetListToJSON,
    V1VirtualMachineList,
    V1VirtualMachineListFromJSON,
    V1VirtualMachineListToJSON,
    V1VirtualMachineMemoryDumpRequest,
    V1VirtualMachineMemoryDumpRequestFromJSON,
    V1VirtualMachineMemoryDumpRequestToJSON,
    V1alpha1MigrationPolicy,
    V1alpha1MigrationPolicyFromJSON,
    V1alpha1MigrationPolicyToJSON,
    V1alpha1MigrationPolicyList,
    V1alpha1MigrationPolicyListFromJSON,
    V1alpha1MigrationPolicyListToJSON,
    V1alpha1VirtualMachinePool,
    V1alpha1VirtualMachinePoolFromJSON,
    V1alpha1VirtualMachinePoolToJSON,
    V1alpha1VirtualMachinePoolList,
    V1alpha1VirtualMachinePoolListFromJSON,
    V1alpha1VirtualMachinePoolListToJSON,
    V1beta1VirtualMachineClone,
    V1beta1VirtualMachineCloneFromJSON,
    V1beta1VirtualMachineCloneToJSON,
    V1beta1VirtualMachineCloneList,
    V1beta1VirtualMachineCloneListFromJSON,
    V1beta1VirtualMachineCloneListToJSON,
    V1beta1VirtualMachineClusterInstancetype,
    V1beta1VirtualMachineClusterInstancetypeFromJSON,
    V1beta1VirtualMachineClusterInstancetypeToJSON,
    V1beta1VirtualMachineClusterInstancetypeList,
    V1beta1VirtualMachineClusterInstancetypeListFromJSON,
    V1beta1VirtualMachineClusterInstancetypeListToJSON,
    V1beta1VirtualMachineClusterPreference,
    V1beta1VirtualMachineClusterPreferenceFromJSON,
    V1beta1VirtualMachineClusterPreferenceToJSON,
    V1beta1VirtualMachineClusterPreferenceList,
    V1beta1VirtualMachineClusterPreferenceListFromJSON,
    V1beta1VirtualMachineClusterPreferenceListToJSON,
    V1beta1VirtualMachineExport,
    V1beta1VirtualMachineExportFromJSON,
    V1beta1VirtualMachineExportToJSON,
    V1beta1VirtualMachineExportList,
    V1beta1VirtualMachineExportListFromJSON,
    V1beta1VirtualMachineExportListToJSON,
    V1beta1VirtualMachineInstancetype,
    V1beta1VirtualMachineInstancetypeFromJSON,
    V1beta1VirtualMachineInstancetypeToJSON,
    V1beta1VirtualMachineInstancetypeList,
    V1beta1VirtualMachineInstancetypeListFromJSON,
    V1beta1VirtualMachineInstancetypeListToJSON,
    V1beta1VirtualMachinePreference,
    V1beta1VirtualMachinePreferenceFromJSON,
    V1beta1VirtualMachinePreferenceToJSON,
    V1beta1VirtualMachinePreferenceList,
    V1beta1VirtualMachinePreferenceListFromJSON,
    V1beta1VirtualMachinePreferenceListToJSON,
    V1beta1VirtualMachineRestore,
    V1beta1VirtualMachineRestoreFromJSON,
    V1beta1VirtualMachineRestoreToJSON,
    V1beta1VirtualMachineRestoreList,
    V1beta1VirtualMachineRestoreListFromJSON,
    V1beta1VirtualMachineRestoreListToJSON,
    V1beta1VirtualMachineSnapshot,
    V1beta1VirtualMachineSnapshotFromJSON,
    V1beta1VirtualMachineSnapshotToJSON,
    V1beta1VirtualMachineSnapshotContent,
    V1beta1VirtualMachineSnapshotContentFromJSON,
    V1beta1VirtualMachineSnapshotContentToJSON,
    V1beta1VirtualMachineSnapshotContentList,
    V1beta1VirtualMachineSnapshotContentListFromJSON,
    V1beta1VirtualMachineSnapshotContentListToJSON,
    V1beta1VirtualMachineSnapshotList,
    V1beta1VirtualMachineSnapshotListFromJSON,
    V1beta1VirtualMachineSnapshotListToJSON,
} from '../models';

export interface CreateMigrationPolicyRequest {
    body: V1alpha1MigrationPolicy;
}

export interface CreateNamespacedKubeVirtRequest {
    namespace: string;
    body: V1KubeVirt;
}

export interface CreateNamespacedVirtualMachineRequest {
    namespace: string;
    body: V1VirtualMachine;
}

export interface CreateNamespacedVirtualMachineExportRequest {
    namespace: string;
    body: V1beta1VirtualMachineExport;
}

export interface CreateNamespacedVirtualMachineInstanceRequest {
    namespace: string;
    body: V1VirtualMachineInstance;
}

export interface CreateNamespacedVirtualMachineInstanceMigrationRequest {
    namespace: string;
    body: V1VirtualMachineInstanceMigration;
}

export interface CreateNamespacedVirtualMachineInstancePresetRequest {
    namespace: string;
    body: V1VirtualMachineInstancePreset;
}

export interface CreateNamespacedVirtualMachineInstanceReplicaSetRequest {
    namespace: string;
    body: V1VirtualMachineInstanceReplicaSet;
}

export interface CreateNamespacedVirtualMachineInstancetypeRequest {
    namespace: string;
    body: V1beta1VirtualMachineInstancetype;
}

export interface CreateNamespacedVirtualMachinePoolRequest {
    namespace: string;
    body: V1alpha1VirtualMachinePool;
}

export interface CreateNamespacedVirtualMachinePreferenceRequest {
    namespace: string;
    body: V1beta1VirtualMachinePreference;
}

export interface CreateNamespacedVirtualMachineRestoreRequest {
    namespace: string;
    body: V1beta1VirtualMachineRestore;
}

export interface CreateNamespacedVirtualMachineSnapshotRequest {
    namespace: string;
    body: V1beta1VirtualMachineSnapshot;
}

export interface CreateNamespacedVirtualMachineSnapshotContentRequest {
    namespace: string;
    body: V1beta1VirtualMachineSnapshotContent;
}

export interface CreateVirtualMachineCloneRequest {
    body: V1beta1VirtualMachineClone;
}

export interface CreateVirtualMachineClusterInstancetypeRequest {
    body: V1beta1VirtualMachineClusterInstancetype;
}

export interface CreateVirtualMachineClusterPreferenceRequest {
    body: V1beta1VirtualMachineClusterPreference;
}

export interface DeleteCollectionMigrationPolicyRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionNamespacedKubeVirtRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineExportRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineInstanceRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineInstanceMigrationRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineInstancePresetRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineInstanceReplicaSetRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineInstancetypeRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachinePoolRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachinePreferenceRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineRestoreRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineSnapshotRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionNamespacedVirtualMachineSnapshotContentRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionVirtualMachineCloneRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionVirtualMachineClusterInstancetypeRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteCollectionVirtualMachineClusterPreferenceRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface DeleteMigrationPolicyRequest {
    name: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteNamespacedKubeVirtRequest {
    name: string;
    namespace: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineRequest {
    name: string;
    namespace: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineExportRequest {
    name: string;
    namespace: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineInstanceRequest {
    name: string;
    namespace: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineInstanceMigrationRequest {
    name: string;
    namespace: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineInstancePresetRequest {
    name: string;
    namespace: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineInstanceReplicaSetRequest {
    name: string;
    namespace: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineInstancetypeRequest {
    name: string;
    namespace: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachinePoolRequest {
    name: string;
    namespace: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachinePreferenceRequest {
    name: string;
    namespace: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineRestoreRequest {
    name: string;
    namespace: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineSnapshotRequest {
    name: string;
    namespace: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteNamespacedVirtualMachineSnapshotContentRequest {
    name: string;
    namespace: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteVirtualMachineCloneRequest {
    name: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteVirtualMachineClusterInstancetypeRequest {
    name: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface DeleteVirtualMachineClusterPreferenceRequest {
    name: string;
    body: K8sIoApimachineryPkgApisMetaV1DeleteOptions;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
}

export interface ListKubeVirtForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListMigrationPolicyRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedKubeVirtRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedVirtualMachineRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedVirtualMachineExportRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedVirtualMachineInstanceRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedVirtualMachineInstanceMigrationRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedVirtualMachineInstancePresetRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedVirtualMachineInstanceReplicaSetRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedVirtualMachineInstancetypeRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedVirtualMachinePoolRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedVirtualMachinePreferenceRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedVirtualMachineRestoreRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedVirtualMachineSnapshotRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedVirtualMachineSnapshotContentRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListVirtualMachineCloneRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListVirtualMachineClusterInstancetypeRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListVirtualMachineClusterPreferenceRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListVirtualMachineExportForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListVirtualMachineForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListVirtualMachineInstanceForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListVirtualMachineInstanceMigrationForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListVirtualMachineInstancePresetForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListVirtualMachineInstanceReplicaSetForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListVirtualMachineInstancetypeForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListVirtualMachinePoolForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListVirtualMachinePreferenceForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListVirtualMachineRestoreForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListVirtualMachineSnapshotContentForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListVirtualMachineSnapshotForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface PatchMigrationPolicyRequest {
    name: string;
    body: object;
}

export interface PatchNamespacedKubeVirtRequest {
    name: string;
    namespace: string;
    body: object;
}

export interface PatchNamespacedVirtualMachineRequest {
    name: string;
    namespace: string;
    body: object;
}

export interface PatchNamespacedVirtualMachineExportRequest {
    name: string;
    namespace: string;
    body: object;
}

export interface PatchNamespacedVirtualMachineInstanceRequest {
    name: string;
    namespace: string;
    body: object;
}

export interface PatchNamespacedVirtualMachineInstanceMigrationRequest {
    name: string;
    namespace: string;
    body: object;
}

export interface PatchNamespacedVirtualMachineInstancePresetRequest {
    name: string;
    namespace: string;
    body: object;
}

export interface PatchNamespacedVirtualMachineInstanceReplicaSetRequest {
    name: string;
    namespace: string;
    body: object;
}

export interface PatchNamespacedVirtualMachineInstancetypeRequest {
    name: string;
    namespace: string;
    body: object;
}

export interface PatchNamespacedVirtualMachinePoolRequest {
    name: string;
    namespace: string;
    body: object;
}

export interface PatchNamespacedVirtualMachinePreferenceRequest {
    name: string;
    namespace: string;
    body: object;
}

export interface PatchNamespacedVirtualMachineRestoreRequest {
    name: string;
    namespace: string;
    body: object;
}

export interface PatchNamespacedVirtualMachineSnapshotRequest {
    name: string;
    namespace: string;
    body: object;
}

export interface PatchNamespacedVirtualMachineSnapshotContentRequest {
    name: string;
    namespace: string;
    body: object;
}

export interface PatchVirtualMachineCloneRequest {
    name: string;
    body: object;
}

export interface PatchVirtualMachineClusterInstancetypeRequest {
    name: string;
    body: object;
}

export interface PatchVirtualMachineClusterPreferenceRequest {
    name: string;
    body: object;
}

export interface ReadMigrationPolicyRequest {
    name: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedKubeVirtRequest {
    name: string;
    namespace: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedVirtualMachineRequest {
    name: string;
    namespace: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedVirtualMachineExportRequest {
    name: string;
    namespace: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedVirtualMachineInstanceRequest {
    name: string;
    namespace: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedVirtualMachineInstanceMigrationRequest {
    name: string;
    namespace: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedVirtualMachineInstancePresetRequest {
    name: string;
    namespace: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedVirtualMachineInstanceReplicaSetRequest {
    name: string;
    namespace: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedVirtualMachineInstancetypeRequest {
    name: string;
    namespace: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedVirtualMachinePoolRequest {
    name: string;
    namespace: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedVirtualMachinePreferenceRequest {
    name: string;
    namespace: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedVirtualMachineRestoreRequest {
    name: string;
    namespace: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedVirtualMachineSnapshotRequest {
    name: string;
    namespace: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedVirtualMachineSnapshotContentRequest {
    name: string;
    namespace: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadVirtualMachineCloneRequest {
    name: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadVirtualMachineClusterInstancetypeRequest {
    name: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadVirtualMachineClusterPreferenceRequest {
    name: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReplaceMigrationPolicyRequest {
    name: string;
    body: V1alpha1MigrationPolicy;
}

export interface ReplaceNamespacedKubeVirtRequest {
    name: string;
    namespace: string;
    body: V1KubeVirt;
}

export interface ReplaceNamespacedVirtualMachineRequest {
    name: string;
    namespace: string;
    body: V1VirtualMachine;
}

export interface ReplaceNamespacedVirtualMachineExportRequest {
    name: string;
    namespace: string;
    body: V1beta1VirtualMachineExport;
}

export interface ReplaceNamespacedVirtualMachineInstanceRequest {
    name: string;
    namespace: string;
    body: V1VirtualMachineInstance;
}

export interface ReplaceNamespacedVirtualMachineInstanceMigrationRequest {
    name: string;
    namespace: string;
    body: V1VirtualMachineInstanceMigration;
}

export interface ReplaceNamespacedVirtualMachineInstancePresetRequest {
    name: string;
    namespace: string;
    body: V1VirtualMachineInstancePreset;
}

export interface ReplaceNamespacedVirtualMachineInstanceReplicaSetRequest {
    name: string;
    namespace: string;
    body: V1VirtualMachineInstanceReplicaSet;
}

export interface ReplaceNamespacedVirtualMachineInstancetypeRequest {
    name: string;
    namespace: string;
    body: V1beta1VirtualMachineInstancetype;
}

export interface ReplaceNamespacedVirtualMachinePoolRequest {
    name: string;
    namespace: string;
    body: V1alpha1VirtualMachinePool;
}

export interface ReplaceNamespacedVirtualMachinePreferenceRequest {
    name: string;
    namespace: string;
    body: V1beta1VirtualMachinePreference;
}

export interface ReplaceNamespacedVirtualMachineRestoreRequest {
    name: string;
    namespace: string;
    body: V1beta1VirtualMachineRestore;
}

export interface ReplaceNamespacedVirtualMachineSnapshotRequest {
    name: string;
    namespace: string;
    body: V1beta1VirtualMachineSnapshot;
}

export interface ReplaceNamespacedVirtualMachineSnapshotContentRequest {
    name: string;
    namespace: string;
    body: V1beta1VirtualMachineSnapshotContent;
}

export interface ReplaceVirtualMachineCloneRequest {
    name: string;
    body: V1beta1VirtualMachineClone;
}

export interface ReplaceVirtualMachineClusterInstancetypeRequest {
    name: string;
    body: V1beta1VirtualMachineClusterInstancetype;
}

export interface ReplaceVirtualMachineClusterPreferenceRequest {
    name: string;
    body: V1beta1VirtualMachineClusterPreference;
}

export interface V1ConsoleRequest {
    name: string;
    namespace: string;
}

export interface V1ExpandSpecRequest {
    namespace: string;
}

export interface V1FilesystemlistRequest {
    name: string;
    namespace: string;
}

export interface V1FreezeRequest {
    name: string;
    namespace: string;
    body: V1FreezeUnfreezeTimeout;
}

export interface V1GuestosinfoRequest {
    name: string;
    namespace: string;
}

export interface V1MemoryDumpRequest {
    name: string;
    namespace: string;
    body: V1VirtualMachineMemoryDumpRequest;
}

export interface V1MigrateRequest {
    name: string;
    namespace: string;
    body: V1MigrateOptions;
}

export interface V1PauseRequest {
    name: string;
    namespace: string;
    body: V1PauseOptions;
}

export interface V1RemoveMemoryDumpRequest {
    name: string;
    namespace: string;
}

export interface V1ResetRequest {
    name: string;
    namespace: string;
}

export interface V1RestartRequest {
    name: string;
    namespace: string;
    body?: V1RestartOptions;
}

export interface V1SEVFetchCertChainRequest {
    name: string;
    namespace: string;
}

export interface V1SEVInjectLaunchSecretRequest {
    name: string;
    namespace: string;
    body: V1SEVSecretOptions;
}

export interface V1SEVQueryLaunchMeasurementRequest {
    name: string;
    namespace: string;
}

export interface V1SEVSetupSessionRequest {
    name: string;
    namespace: string;
    body: V1SEVSessionOptions;
}

export interface V1SoftRebootRequest {
    name: string;
    namespace: string;
}

export interface V1StartRequest {
    name: string;
    namespace: string;
    body: V1StartOptions;
}

export interface V1StopRequest {
    name: string;
    namespace: string;
    body?: V1StopOptions;
}

export interface V1UnfreezeRequest {
    name: string;
    namespace: string;
}

export interface V1UnpauseRequest {
    name: string;
    namespace: string;
    body: V1UnpauseOptions;
}

export interface V1UserlistRequest {
    name: string;
    namespace: string;
}

export interface V1VNCRequest {
    name: string;
    namespace: string;
}

export interface V1VNCScreenshotRequest {
    name: string;
    namespace: string;
    moveCursor?: boolean;
}

export interface V1VSOCKRequest {
    name: string;
    namespace: string;
    port: number;
    tls?: boolean;
}

export interface V1alpha3ConsoleRequest {
    name: string;
    namespace: string;
}

export interface V1alpha3ExpandSpecRequest {
    namespace: string;
}

export interface V1alpha3FilesystemlistRequest {
    name: string;
    namespace: string;
}

export interface V1alpha3FreezeRequest {
    name: string;
    namespace: string;
    body: V1FreezeUnfreezeTimeout;
}

export interface V1alpha3GuestosinfoRequest {
    name: string;
    namespace: string;
}

export interface V1alpha3MemoryDumpRequest {
    name: string;
    namespace: string;
    body: V1VirtualMachineMemoryDumpRequest;
}

export interface V1alpha3MigrateRequest {
    name: string;
    namespace: string;
    body: V1MigrateOptions;
}

export interface V1alpha3PauseRequest {
    name: string;
    namespace: string;
    body: V1PauseOptions;
}

export interface V1alpha3RemoveMemoryDumpRequest {
    name: string;
    namespace: string;
}

export interface V1alpha3ResetRequest {
    name: string;
    namespace: string;
}

export interface V1alpha3RestartRequest {
    name: string;
    namespace: string;
    body?: V1RestartOptions;
}

export interface V1alpha3SEVFetchCertChainRequest {
    name: string;
    namespace: string;
}

export interface V1alpha3SEVInjectLaunchSecretRequest {
    name: string;
    namespace: string;
    body: V1SEVSecretOptions;
}

export interface V1alpha3SEVQueryLaunchMeasurementRequest {
    name: string;
    namespace: string;
}

export interface V1alpha3SEVSetupSessionRequest {
    name: string;
    namespace: string;
    body: V1SEVSessionOptions;
}

export interface V1alpha3SoftRebootRequest {
    name: string;
    namespace: string;
}

export interface V1alpha3StartRequest {
    name: string;
    namespace: string;
    body: V1StartOptions;
}

export interface V1alpha3StopRequest {
    name: string;
    namespace: string;
    body?: V1StopOptions;
}

export interface V1alpha3UnfreezeRequest {
    name: string;
    namespace: string;
}

export interface V1alpha3UnpauseRequest {
    name: string;
    namespace: string;
    body: V1UnpauseOptions;
}

export interface V1alpha3UserlistRequest {
    name: string;
    namespace: string;
}

export interface V1alpha3VNCRequest {
    name: string;
    namespace: string;
}

export interface V1alpha3VNCScreenshotRequest {
    name: string;
    namespace: string;
    moveCursor?: boolean;
}

export interface V1alpha3VSOCKRequest {
    name: string;
    namespace: string;
    port: number;
    tls?: boolean;
}

export interface V1alpha3usbredirRequest {
    name: string;
    namespace: string;
}

export interface V1alpha3vmAddvolumeRequest {
    name: string;
    namespace: string;
    body: V1AddVolumeOptions;
}

export interface V1alpha3vmExpandSpecRequest {
    name: string;
    namespace: string;
}

export interface V1alpha3vmPortForwardRequest {
    name: string;
    namespace: string;
    port: string;
}

export interface V1alpha3vmPortForwardWithProtocolRequest {
    name: string;
    namespace: string;
    port: string;
    protocol: string;
}

export interface V1alpha3vmRemovevolumeRequest {
    name: string;
    namespace: string;
    body: V1RemoveVolumeOptions;
}

export interface V1alpha3vmiAddvolumeRequest {
    name: string;
    namespace: string;
    body: V1AddVolumeOptions;
}

export interface V1alpha3vmiPortForwardRequest {
    name: string;
    namespace: string;
    port: string;
}

export interface V1alpha3vmiPortForwardWithProtocolRequest {
    name: string;
    namespace: string;
    port: string;
    protocol: string;
}

export interface V1alpha3vmiRemovevolumeRequest {
    name: string;
    namespace: string;
    body: V1RemoveVolumeOptions;
}

export interface V1usbredirRequest {
    name: string;
    namespace: string;
}

export interface V1vmAddvolumeRequest {
    name: string;
    namespace: string;
    body: V1AddVolumeOptions;
}

export interface V1vmExpandSpecRequest {
    name: string;
    namespace: string;
}

export interface V1vmPortForwardRequest {
    name: string;
    namespace: string;
    port: string;
}

export interface V1vmPortForwardWithProtocolRequest {
    name: string;
    namespace: string;
    port: string;
    protocol: string;
}

export interface V1vmRemovevolumeRequest {
    name: string;
    namespace: string;
    body: V1RemoveVolumeOptions;
}

export interface V1vmiAddvolumeRequest {
    name: string;
    namespace: string;
    body: V1AddVolumeOptions;
}

export interface V1vmiPortForwardRequest {
    name: string;
    namespace: string;
    port: string;
}

export interface V1vmiPortForwardWithProtocolRequest {
    name: string;
    namespace: string;
    port: string;
    protocol: string;
}

export interface V1vmiRemovevolumeRequest {
    name: string;
    namespace: string;
    body: V1RemoveVolumeOptions;
}

export interface WatchKubeVirtListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchMigrationPolicyListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchNamespacedKubeVirtRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchNamespacedVirtualMachineRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchNamespacedVirtualMachineExportRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchNamespacedVirtualMachineInstanceRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchNamespacedVirtualMachineInstanceMigrationRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchNamespacedVirtualMachineInstancePresetRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchNamespacedVirtualMachineInstanceReplicaSetRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchNamespacedVirtualMachineInstancetypeRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchNamespacedVirtualMachinePoolRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchNamespacedVirtualMachinePreferenceRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchNamespacedVirtualMachineRestoreRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchNamespacedVirtualMachineSnapshotRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchNamespacedVirtualMachineSnapshotContentRequest {
    namespace: string;
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchVirtualMachineCloneListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchVirtualMachineClusterInstancetypeListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchVirtualMachineClusterPreferenceListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchVirtualMachineExportListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchVirtualMachineInstanceListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchVirtualMachineInstanceMigrationListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchVirtualMachineInstancePresetListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchVirtualMachineInstanceReplicaSetListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchVirtualMachineInstancetypeListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchVirtualMachineListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchVirtualMachinePoolListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchVirtualMachinePreferenceListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchVirtualMachineRestoreListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchVirtualMachineSnapshotContentListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchVirtualMachineSnapshotListForAllNamespacesRequest {
    _continue?: string;
    fieldSelector?: string;
    includeUninitialized?: boolean;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Create a MigrationPolicy object.
     */
    async createMigrationPolicyRaw(requestParameters: CreateMigrationPolicyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1alpha1MigrationPolicy>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createMigrationPolicy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1alpha1MigrationPolicyToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1alpha1MigrationPolicyFromJSON(jsonValue));
    }

    /**
     * Create a MigrationPolicy object.
     */
    async createMigrationPolicy(requestParameters: CreateMigrationPolicyRequest, initOverrides?: RequestInit): Promise<V1alpha1MigrationPolicy> {
        const response = await this.createMigrationPolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a KubeVirt object.
     */
    async createNamespacedKubeVirtRaw(requestParameters: CreateNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1KubeVirt>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedKubeVirt.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedKubeVirt.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1KubeVirtToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1KubeVirtFromJSON(jsonValue));
    }

    /**
     * Create a KubeVirt object.
     */
    async createNamespacedKubeVirt(requestParameters: CreateNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<V1KubeVirt> {
        const response = await this.createNamespacedKubeVirtRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a VirtualMachine object.
     */
    async createNamespacedVirtualMachineRaw(requestParameters: CreateNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachine>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachine.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachine.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1VirtualMachineToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineFromJSON(jsonValue));
    }

    /**
     * Create a VirtualMachine object.
     */
    async createNamespacedVirtualMachine(requestParameters: CreateNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<V1VirtualMachine> {
        const response = await this.createNamespacedVirtualMachineRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a VirtualMachineExport object.
     */
    async createNamespacedVirtualMachineExportRaw(requestParameters: CreateNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineExport>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineExport.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineExport.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineExportToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineExportFromJSON(jsonValue));
    }

    /**
     * Create a VirtualMachineExport object.
     */
    async createNamespacedVirtualMachineExport(requestParameters: CreateNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineExport> {
        const response = await this.createNamespacedVirtualMachineExportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a VirtualMachineInstance object.
     */
    async createNamespacedVirtualMachineInstanceRaw(requestParameters: CreateNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstance>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineInstance.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineInstance.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1VirtualMachineInstanceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceFromJSON(jsonValue));
    }

    /**
     * Create a VirtualMachineInstance object.
     */
    async createNamespacedVirtualMachineInstance(requestParameters: CreateNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstance> {
        const response = await this.createNamespacedVirtualMachineInstanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a VirtualMachineInstanceMigration object.
     */
    async createNamespacedVirtualMachineInstanceMigrationRaw(requestParameters: CreateNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceMigration>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineInstanceMigration.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineInstanceMigration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1VirtualMachineInstanceMigrationToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceMigrationFromJSON(jsonValue));
    }

    /**
     * Create a VirtualMachineInstanceMigration object.
     */
    async createNamespacedVirtualMachineInstanceMigration(requestParameters: CreateNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceMigration> {
        const response = await this.createNamespacedVirtualMachineInstanceMigrationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a VirtualMachineInstancePreset object.
     */
    async createNamespacedVirtualMachineInstancePresetRaw(requestParameters: CreateNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstancePreset>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineInstancePreset.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineInstancePreset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1VirtualMachineInstancePresetToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstancePresetFromJSON(jsonValue));
    }

    /**
     * Create a VirtualMachineInstancePreset object.
     */
    async createNamespacedVirtualMachineInstancePreset(requestParameters: CreateNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstancePreset> {
        const response = await this.createNamespacedVirtualMachineInstancePresetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a VirtualMachineInstanceReplicaSet object.
     */
    async createNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters: CreateNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceReplicaSet>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineInstanceReplicaSet.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineInstanceReplicaSet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1VirtualMachineInstanceReplicaSetToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceReplicaSetFromJSON(jsonValue));
    }

    /**
     * Create a VirtualMachineInstanceReplicaSet object.
     */
    async createNamespacedVirtualMachineInstanceReplicaSet(requestParameters: CreateNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceReplicaSet> {
        const response = await this.createNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a VirtualMachineInstancetype object.
     */
    async createNamespacedVirtualMachineInstancetypeRaw(requestParameters: CreateNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineInstancetype>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineInstancetype.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineInstancetype.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineInstancetypeToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineInstancetypeFromJSON(jsonValue));
    }

    /**
     * Create a VirtualMachineInstancetype object.
     */
    async createNamespacedVirtualMachineInstancetype(requestParameters: CreateNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineInstancetype> {
        const response = await this.createNamespacedVirtualMachineInstancetypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a VirtualMachinePool object.
     */
    async createNamespacedVirtualMachinePoolRaw(requestParameters: CreateNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePool>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachinePool.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachinePool.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1alpha1VirtualMachinePoolToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1alpha1VirtualMachinePoolFromJSON(jsonValue));
    }

    /**
     * Create a VirtualMachinePool object.
     */
    async createNamespacedVirtualMachinePool(requestParameters: CreateNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<V1alpha1VirtualMachinePool> {
        const response = await this.createNamespacedVirtualMachinePoolRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a VirtualMachinePreference object.
     */
    async createNamespacedVirtualMachinePreferenceRaw(requestParameters: CreateNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachinePreference>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachinePreference.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachinePreference.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachinePreferenceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachinePreferenceFromJSON(jsonValue));
    }

    /**
     * Create a VirtualMachinePreference object.
     */
    async createNamespacedVirtualMachinePreference(requestParameters: CreateNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachinePreference> {
        const response = await this.createNamespacedVirtualMachinePreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a VirtualMachineRestore object.
     */
    async createNamespacedVirtualMachineRestoreRaw(requestParameters: CreateNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineRestore>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineRestore.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineRestore.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineRestoreToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineRestoreFromJSON(jsonValue));
    }

    /**
     * Create a VirtualMachineRestore object.
     */
    async createNamespacedVirtualMachineRestore(requestParameters: CreateNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineRestore> {
        const response = await this.createNamespacedVirtualMachineRestoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a VirtualMachineSnapshot object.
     */
    async createNamespacedVirtualMachineSnapshotRaw(requestParameters: CreateNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineSnapshot>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineSnapshot.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineSnapshot.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineSnapshotToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineSnapshotFromJSON(jsonValue));
    }

    /**
     * Create a VirtualMachineSnapshot object.
     */
    async createNamespacedVirtualMachineSnapshot(requestParameters: CreateNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineSnapshot> {
        const response = await this.createNamespacedVirtualMachineSnapshotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a VirtualMachineSnapshotContent object.
     */
    async createNamespacedVirtualMachineSnapshotContentRaw(requestParameters: CreateNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineSnapshotContent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedVirtualMachineSnapshotContent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedVirtualMachineSnapshotContent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineSnapshotContentToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineSnapshotContentFromJSON(jsonValue));
    }

    /**
     * Create a VirtualMachineSnapshotContent object.
     */
    async createNamespacedVirtualMachineSnapshotContent(requestParameters: CreateNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineSnapshotContent> {
        const response = await this.createNamespacedVirtualMachineSnapshotContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a VirtualMachineClone object.
     */
    async createVirtualMachineCloneRaw(requestParameters: CreateVirtualMachineCloneRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineClone>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createVirtualMachineClone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/clone.kubevirt.io/v1beta1/virtualmachineclones`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineCloneToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineCloneFromJSON(jsonValue));
    }

    /**
     * Create a VirtualMachineClone object.
     */
    async createVirtualMachineClone(requestParameters: CreateVirtualMachineCloneRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineClone> {
        const response = await this.createVirtualMachineCloneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a VirtualMachineClusterInstancetype object.
     */
    async createVirtualMachineClusterInstancetypeRaw(requestParameters: CreateVirtualMachineClusterInstancetypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineClusterInstancetype>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createVirtualMachineClusterInstancetype.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineClusterInstancetypeToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineClusterInstancetypeFromJSON(jsonValue));
    }

    /**
     * Create a VirtualMachineClusterInstancetype object.
     */
    async createVirtualMachineClusterInstancetype(requestParameters: CreateVirtualMachineClusterInstancetypeRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineClusterInstancetype> {
        const response = await this.createVirtualMachineClusterInstancetypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a VirtualMachineClusterPreference object.
     */
    async createVirtualMachineClusterPreferenceRaw(requestParameters: CreateVirtualMachineClusterPreferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineClusterPreference>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createVirtualMachineClusterPreference.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineClusterPreferenceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineClusterPreferenceFromJSON(jsonValue));
    }

    /**
     * Create a VirtualMachineClusterPreference object.
     */
    async createVirtualMachineClusterPreference(requestParameters: CreateVirtualMachineClusterPreferenceRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineClusterPreference> {
        const response = await this.createVirtualMachineClusterPreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of MigrationPolicy objects.
     */
    async deleteCollectionMigrationPolicyRaw(requestParameters: DeleteCollectionMigrationPolicyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of MigrationPolicy objects.
     */
    async deleteCollectionMigrationPolicy(requestParameters: DeleteCollectionMigrationPolicyRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionMigrationPolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of KubeVirt objects.
     */
    async deleteCollectionNamespacedKubeVirtRaw(requestParameters: DeleteCollectionNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of KubeVirt objects.
     */
    async deleteCollectionNamespacedKubeVirt(requestParameters: DeleteCollectionNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionNamespacedKubeVirtRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of VirtualMachine objects.
     */
    async deleteCollectionNamespacedVirtualMachineRaw(requestParameters: DeleteCollectionNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of VirtualMachine objects.
     */
    async deleteCollectionNamespacedVirtualMachine(requestParameters: DeleteCollectionNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionNamespacedVirtualMachineRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of VirtualMachineExport objects.
     */
    async deleteCollectionNamespacedVirtualMachineExportRaw(requestParameters: DeleteCollectionNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of VirtualMachineExport objects.
     */
    async deleteCollectionNamespacedVirtualMachineExport(requestParameters: DeleteCollectionNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionNamespacedVirtualMachineExportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of VirtualMachineInstance objects.
     */
    async deleteCollectionNamespacedVirtualMachineInstanceRaw(requestParameters: DeleteCollectionNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of VirtualMachineInstance objects.
     */
    async deleteCollectionNamespacedVirtualMachineInstance(requestParameters: DeleteCollectionNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionNamespacedVirtualMachineInstanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of VirtualMachineInstanceMigration objects.
     */
    async deleteCollectionNamespacedVirtualMachineInstanceMigrationRaw(requestParameters: DeleteCollectionNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of VirtualMachineInstanceMigration objects.
     */
    async deleteCollectionNamespacedVirtualMachineInstanceMigration(requestParameters: DeleteCollectionNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionNamespacedVirtualMachineInstanceMigrationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of VirtualMachineInstancePreset objects.
     */
    async deleteCollectionNamespacedVirtualMachineInstancePresetRaw(requestParameters: DeleteCollectionNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of VirtualMachineInstancePreset objects.
     */
    async deleteCollectionNamespacedVirtualMachineInstancePreset(requestParameters: DeleteCollectionNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionNamespacedVirtualMachineInstancePresetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of VirtualMachineInstanceReplicaSet objects.
     */
    async deleteCollectionNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters: DeleteCollectionNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of VirtualMachineInstanceReplicaSet objects.
     */
    async deleteCollectionNamespacedVirtualMachineInstanceReplicaSet(requestParameters: DeleteCollectionNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of VirtualMachineInstancetype objects.
     */
    async deleteCollectionNamespacedVirtualMachineInstancetypeRaw(requestParameters: DeleteCollectionNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of VirtualMachineInstancetype objects.
     */
    async deleteCollectionNamespacedVirtualMachineInstancetype(requestParameters: DeleteCollectionNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionNamespacedVirtualMachineInstancetypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of VirtualMachinePool objects.
     */
    async deleteCollectionNamespacedVirtualMachinePoolRaw(requestParameters: DeleteCollectionNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of VirtualMachinePool objects.
     */
    async deleteCollectionNamespacedVirtualMachinePool(requestParameters: DeleteCollectionNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionNamespacedVirtualMachinePoolRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of VirtualMachinePreference objects.
     */
    async deleteCollectionNamespacedVirtualMachinePreferenceRaw(requestParameters: DeleteCollectionNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of VirtualMachinePreference objects.
     */
    async deleteCollectionNamespacedVirtualMachinePreference(requestParameters: DeleteCollectionNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionNamespacedVirtualMachinePreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of VirtualMachineRestore objects.
     */
    async deleteCollectionNamespacedVirtualMachineRestoreRaw(requestParameters: DeleteCollectionNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of VirtualMachineRestore objects.
     */
    async deleteCollectionNamespacedVirtualMachineRestore(requestParameters: DeleteCollectionNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionNamespacedVirtualMachineRestoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of VirtualMachineSnapshot objects.
     */
    async deleteCollectionNamespacedVirtualMachineSnapshotRaw(requestParameters: DeleteCollectionNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of VirtualMachineSnapshot objects.
     */
    async deleteCollectionNamespacedVirtualMachineSnapshot(requestParameters: DeleteCollectionNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionNamespacedVirtualMachineSnapshotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of VirtualMachineSnapshotContent objects.
     */
    async deleteCollectionNamespacedVirtualMachineSnapshotContentRaw(requestParameters: DeleteCollectionNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of VirtualMachineSnapshotContent objects.
     */
    async deleteCollectionNamespacedVirtualMachineSnapshotContent(requestParameters: DeleteCollectionNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionNamespacedVirtualMachineSnapshotContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of VirtualMachineClone objects.
     */
    async deleteCollectionVirtualMachineCloneRaw(requestParameters: DeleteCollectionVirtualMachineCloneRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/clone.kubevirt.io/v1beta1/virtualmachineclones`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of VirtualMachineClone objects.
     */
    async deleteCollectionVirtualMachineClone(requestParameters: DeleteCollectionVirtualMachineCloneRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionVirtualMachineCloneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of VirtualMachineClusterInstancetype objects.
     */
    async deleteCollectionVirtualMachineClusterInstancetypeRaw(requestParameters: DeleteCollectionVirtualMachineClusterInstancetypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of VirtualMachineClusterInstancetype objects.
     */
    async deleteCollectionVirtualMachineClusterInstancetype(requestParameters: DeleteCollectionVirtualMachineClusterInstancetypeRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionVirtualMachineClusterInstancetypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a collection of VirtualMachineClusterPreference objects.
     */
    async deleteCollectionVirtualMachineClusterPreferenceRaw(requestParameters: DeleteCollectionVirtualMachineClusterPreferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a collection of VirtualMachineClusterPreference objects.
     */
    async deleteCollectionVirtualMachineClusterPreference(requestParameters: DeleteCollectionVirtualMachineClusterPreferenceRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCollectionVirtualMachineClusterPreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a MigrationPolicy object.
     */
    async deleteMigrationPolicyRaw(requestParameters: DeleteMigrationPolicyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteMigrationPolicy.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteMigrationPolicy.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a MigrationPolicy object.
     */
    async deleteMigrationPolicy(requestParameters: DeleteMigrationPolicyRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteMigrationPolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a KubeVirt object.
     */
    async deleteNamespacedKubeVirtRaw(requestParameters: DeleteNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedKubeVirt.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedKubeVirt.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteNamespacedKubeVirt.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a KubeVirt object.
     */
    async deleteNamespacedKubeVirt(requestParameters: DeleteNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteNamespacedKubeVirtRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a VirtualMachine object.
     */
    async deleteNamespacedVirtualMachineRaw(requestParameters: DeleteNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachine.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachine.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachine.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a VirtualMachine object.
     */
    async deleteNamespacedVirtualMachine(requestParameters: DeleteNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteNamespacedVirtualMachineRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a VirtualMachineExport object.
     */
    async deleteNamespacedVirtualMachineExportRaw(requestParameters: DeleteNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineExport.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineExport.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineExport.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a VirtualMachineExport object.
     */
    async deleteNamespacedVirtualMachineExport(requestParameters: DeleteNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteNamespacedVirtualMachineExportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a VirtualMachineInstance object.
     */
    async deleteNamespacedVirtualMachineInstanceRaw(requestParameters: DeleteNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineInstance.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineInstance.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineInstance.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a VirtualMachineInstance object.
     */
    async deleteNamespacedVirtualMachineInstance(requestParameters: DeleteNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteNamespacedVirtualMachineInstanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a VirtualMachineInstanceMigration object.
     */
    async deleteNamespacedVirtualMachineInstanceMigrationRaw(requestParameters: DeleteNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineInstanceMigration.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineInstanceMigration.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineInstanceMigration.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a VirtualMachineInstanceMigration object.
     */
    async deleteNamespacedVirtualMachineInstanceMigration(requestParameters: DeleteNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteNamespacedVirtualMachineInstanceMigrationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a VirtualMachineInstancePreset object.
     */
    async deleteNamespacedVirtualMachineInstancePresetRaw(requestParameters: DeleteNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineInstancePreset.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineInstancePreset.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineInstancePreset.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a VirtualMachineInstancePreset object.
     */
    async deleteNamespacedVirtualMachineInstancePreset(requestParameters: DeleteNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteNamespacedVirtualMachineInstancePresetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a VirtualMachineInstanceReplicaSet object.
     */
    async deleteNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters: DeleteNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineInstanceReplicaSet.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineInstanceReplicaSet.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineInstanceReplicaSet.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a VirtualMachineInstanceReplicaSet object.
     */
    async deleteNamespacedVirtualMachineInstanceReplicaSet(requestParameters: DeleteNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a VirtualMachineInstancetype object.
     */
    async deleteNamespacedVirtualMachineInstancetypeRaw(requestParameters: DeleteNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineInstancetype.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineInstancetype.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineInstancetype.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a VirtualMachineInstancetype object.
     */
    async deleteNamespacedVirtualMachineInstancetype(requestParameters: DeleteNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteNamespacedVirtualMachineInstancetypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a VirtualMachinePool object.
     */
    async deleteNamespacedVirtualMachinePoolRaw(requestParameters: DeleteNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachinePool.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachinePool.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachinePool.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a VirtualMachinePool object.
     */
    async deleteNamespacedVirtualMachinePool(requestParameters: DeleteNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteNamespacedVirtualMachinePoolRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a VirtualMachinePreference object.
     */
    async deleteNamespacedVirtualMachinePreferenceRaw(requestParameters: DeleteNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachinePreference.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachinePreference.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachinePreference.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a VirtualMachinePreference object.
     */
    async deleteNamespacedVirtualMachinePreference(requestParameters: DeleteNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteNamespacedVirtualMachinePreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a VirtualMachineRestore object.
     */
    async deleteNamespacedVirtualMachineRestoreRaw(requestParameters: DeleteNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineRestore.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineRestore.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineRestore.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a VirtualMachineRestore object.
     */
    async deleteNamespacedVirtualMachineRestore(requestParameters: DeleteNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteNamespacedVirtualMachineRestoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a VirtualMachineSnapshot object.
     */
    async deleteNamespacedVirtualMachineSnapshotRaw(requestParameters: DeleteNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineSnapshot.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineSnapshot.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineSnapshot.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a VirtualMachineSnapshot object.
     */
    async deleteNamespacedVirtualMachineSnapshot(requestParameters: DeleteNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteNamespacedVirtualMachineSnapshotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a VirtualMachineSnapshotContent object.
     */
    async deleteNamespacedVirtualMachineSnapshotContentRaw(requestParameters: DeleteNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedVirtualMachineSnapshotContent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedVirtualMachineSnapshotContent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteNamespacedVirtualMachineSnapshotContent.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a VirtualMachineSnapshotContent object.
     */
    async deleteNamespacedVirtualMachineSnapshotContent(requestParameters: DeleteNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteNamespacedVirtualMachineSnapshotContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a VirtualMachineClone object.
     */
    async deleteVirtualMachineCloneRaw(requestParameters: DeleteVirtualMachineCloneRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteVirtualMachineClone.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteVirtualMachineClone.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/clone.kubevirt.io/v1beta1/virtualmachineclones/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a VirtualMachineClone object.
     */
    async deleteVirtualMachineClone(requestParameters: DeleteVirtualMachineCloneRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteVirtualMachineCloneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a VirtualMachineClusterInstancetype object.
     */
    async deleteVirtualMachineClusterInstancetypeRaw(requestParameters: DeleteVirtualMachineClusterInstancetypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteVirtualMachineClusterInstancetype.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteVirtualMachineClusterInstancetype.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a VirtualMachineClusterInstancetype object.
     */
    async deleteVirtualMachineClusterInstancetype(requestParameters: DeleteVirtualMachineClusterInstancetypeRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteVirtualMachineClusterInstancetypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a VirtualMachineClusterPreference object.
     */
    async deleteVirtualMachineClusterPreferenceRaw(requestParameters: DeleteVirtualMachineClusterPreferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteVirtualMachineClusterPreference.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deleteVirtualMachineClusterPreference.');
        }

        const queryParameters: any = {};

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: K8sIoApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * Delete a VirtualMachineClusterPreference object.
     */
    async deleteVirtualMachineClusterPreference(requestParameters: DeleteVirtualMachineClusterPreferenceRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteVirtualMachineClusterPreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Health endpoint
     */
    async func13Raw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/healthz`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Health endpoint
     */
    async func13(initOverrides?: RequestInit): Promise<void> {
        await this.func13Raw(initOverrides);
    }

    /**
     */
    async func6Raw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/openapi/v2`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async func6(initOverrides?: RequestInit): Promise<void> {
        await this.func6Raw(initOverrides);
    }

    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupCloneKubevirtIoRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/clone.kubevirt.io/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue));
    }

    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupCloneKubevirtIo(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
        const response = await this.getAPIGroupCloneKubevirtIoRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupExportKubevirtIoRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/export.kubevirt.io/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue));
    }

    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupExportKubevirtIo(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
        const response = await this.getAPIGroupExportKubevirtIoRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupInstancetypeKubevirtIoRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue));
    }

    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupInstancetypeKubevirtIo(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
        const response = await this.getAPIGroupInstancetypeKubevirtIoRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupKubevirtIoRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue));
    }

    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupKubevirtIo(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
        const response = await this.getAPIGroupKubevirtIoRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a KubeVirt API GroupList
     */
    async getAPIGroupListRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroupList>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIGroupListFromJSON(jsonValue));
    }

    /**
     * Get a KubeVirt API GroupList
     */
    async getAPIGroupList(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIGroupList> {
        const response = await this.getAPIGroupListRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupMigrationsKubevirtIoRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/migrations.kubevirt.io/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue));
    }

    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupMigrationsKubevirtIo(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
        const response = await this.getAPIGroupMigrationsKubevirtIoRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupPoolKubevirtIoRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/pool.kubevirt.io/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue));
    }

    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupPoolKubevirtIo(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
        const response = await this.getAPIGroupPoolKubevirtIoRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupSnapshotKubevirtIoRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue));
    }

    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupSnapshotKubevirtIo(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
        const response = await this.getAPIGroupSnapshotKubevirtIoRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesCloneKubevirtIoV1beta1Raw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/clone.kubevirt.io/v1beta1/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue));
    }

    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesCloneKubevirtIoV1beta1(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
        const response = await this.getAPIResourcesCloneKubevirtIoV1beta1Raw(initOverrides);
        return await response.value();
    }

    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesExportKubevirtIoV1beta1Raw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/export.kubevirt.io/v1beta1/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue));
    }

    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesExportKubevirtIoV1beta1(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
        const response = await this.getAPIResourcesExportKubevirtIoV1beta1Raw(initOverrides);
        return await response.value();
    }

    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesInstancetypeKubevirtIoV1beta1Raw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue));
    }

    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesInstancetypeKubevirtIoV1beta1(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
        const response = await this.getAPIResourcesInstancetypeKubevirtIoV1beta1Raw(initOverrides);
        return await response.value();
    }

    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesKubevirtIoV1Raw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue));
    }

    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesKubevirtIoV1(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
        const response = await this.getAPIResourcesKubevirtIoV1Raw(initOverrides);
        return await response.value();
    }

    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesMigrationsKubevirtIoV1alpha1Raw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/migrations.kubevirt.io/v1alpha1/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue));
    }

    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesMigrationsKubevirtIoV1alpha1(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
        const response = await this.getAPIResourcesMigrationsKubevirtIoV1alpha1Raw(initOverrides);
        return await response.value();
    }

    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesPoolKubevirtIoV1alpha1Raw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/pool.kubevirt.io/v1alpha1/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue));
    }

    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesPoolKubevirtIoV1alpha1(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
        const response = await this.getAPIResourcesPoolKubevirtIoV1alpha1Raw(initOverrides);
        return await response.value();
    }

    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesSnapshotKubevirtIoV1beta1Raw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue));
    }

    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesSnapshotKubevirtIoV1beta1(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
        const response = await this.getAPIResourcesSnapshotKubevirtIoV1beta1Raw(initOverrides);
        return await response.value();
    }

    /**
     * Get KubeVirt API root paths
     */
    async getRootPathsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1RootPaths>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1RootPathsFromJSON(jsonValue));
    }

    /**
     * Get KubeVirt API root paths
     */
    async getRootPaths(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1RootPaths> {
        const response = await this.getRootPathsRaw(initOverrides);
        return await response.value();
    }

    /**
     * dump profiler results endpoint
     */
    async handleDumpProfilerRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/dump-profiler`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * dump profiler results endpoint
     */
    async handleDumpProfiler(initOverrides?: RequestInit): Promise<void> {
        await this.handleDumpProfilerRaw(initOverrides);
    }

    /**
     * start profiler endpoint
     */
    async handleStartProfilerRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/start-profiler`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * start profiler endpoint
     */
    async handleStartProfiler(initOverrides?: RequestInit): Promise<void> {
        await this.handleStartProfilerRaw(initOverrides);
    }

    /**
     * stop profiler endpoint
     */
    async handleStopProfilerRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/stop-profiler`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * stop profiler endpoint
     */
    async handleStopProfiler(initOverrides?: RequestInit): Promise<void> {
        await this.handleStopProfilerRaw(initOverrides);
    }

    /**
     * Get a list of all KubeVirt objects.
     */
    async listKubeVirtForAllNamespacesRaw(requestParameters: ListKubeVirtForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1KubeVirtList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/kubevirt`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1KubeVirtListFromJSON(jsonValue));
    }

    /**
     * Get a list of all KubeVirt objects.
     */
    async listKubeVirtForAllNamespaces(requestParameters: ListKubeVirtForAllNamespacesRequest, initOverrides?: RequestInit): Promise<V1KubeVirtList> {
        const response = await this.listKubeVirtForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of MigrationPolicy objects.
     */
    async listMigrationPolicyRaw(requestParameters: ListMigrationPolicyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1alpha1MigrationPolicyList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1alpha1MigrationPolicyListFromJSON(jsonValue));
    }

    /**
     * Get a list of MigrationPolicy objects.
     */
    async listMigrationPolicy(requestParameters: ListMigrationPolicyRequest, initOverrides?: RequestInit): Promise<V1alpha1MigrationPolicyList> {
        const response = await this.listMigrationPolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of KubeVirt objects.
     */
    async listNamespacedKubeVirtRaw(requestParameters: ListNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1KubeVirtList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedKubeVirt.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1KubeVirtListFromJSON(jsonValue));
    }

    /**
     * Get a list of KubeVirt objects.
     */
    async listNamespacedKubeVirt(requestParameters: ListNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<V1KubeVirtList> {
        const response = await this.listNamespacedKubeVirtRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of VirtualMachine objects.
     */
    async listNamespacedVirtualMachineRaw(requestParameters: ListNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachine.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineListFromJSON(jsonValue));
    }

    /**
     * Get a list of VirtualMachine objects.
     */
    async listNamespacedVirtualMachine(requestParameters: ListNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineList> {
        const response = await this.listNamespacedVirtualMachineRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of VirtualMachineExport objects.
     */
    async listNamespacedVirtualMachineExportRaw(requestParameters: ListNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineExportList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineExport.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineExportListFromJSON(jsonValue));
    }

    /**
     * Get a list of VirtualMachineExport objects.
     */
    async listNamespacedVirtualMachineExport(requestParameters: ListNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineExportList> {
        const response = await this.listNamespacedVirtualMachineExportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of VirtualMachineInstance objects.
     */
    async listNamespacedVirtualMachineInstanceRaw(requestParameters: ListNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineInstance.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceListFromJSON(jsonValue));
    }

    /**
     * Get a list of VirtualMachineInstance objects.
     */
    async listNamespacedVirtualMachineInstance(requestParameters: ListNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceList> {
        const response = await this.listNamespacedVirtualMachineInstanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of VirtualMachineInstanceMigration objects.
     */
    async listNamespacedVirtualMachineInstanceMigrationRaw(requestParameters: ListNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceMigrationList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineInstanceMigration.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceMigrationListFromJSON(jsonValue));
    }

    /**
     * Get a list of VirtualMachineInstanceMigration objects.
     */
    async listNamespacedVirtualMachineInstanceMigration(requestParameters: ListNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceMigrationList> {
        const response = await this.listNamespacedVirtualMachineInstanceMigrationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of VirtualMachineInstancePreset objects.
     */
    async listNamespacedVirtualMachineInstancePresetRaw(requestParameters: ListNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstancePresetList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineInstancePreset.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstancePresetListFromJSON(jsonValue));
    }

    /**
     * Get a list of VirtualMachineInstancePreset objects.
     */
    async listNamespacedVirtualMachineInstancePreset(requestParameters: ListNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstancePresetList> {
        const response = await this.listNamespacedVirtualMachineInstancePresetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of VirtualMachineInstanceReplicaSet objects.
     */
    async listNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters: ListNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceReplicaSetList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineInstanceReplicaSet.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceReplicaSetListFromJSON(jsonValue));
    }

    /**
     * Get a list of VirtualMachineInstanceReplicaSet objects.
     */
    async listNamespacedVirtualMachineInstanceReplicaSet(requestParameters: ListNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceReplicaSetList> {
        const response = await this.listNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of VirtualMachineInstancetype objects.
     */
    async listNamespacedVirtualMachineInstancetypeRaw(requestParameters: ListNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineInstancetypeList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineInstancetype.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineInstancetypeListFromJSON(jsonValue));
    }

    /**
     * Get a list of VirtualMachineInstancetype objects.
     */
    async listNamespacedVirtualMachineInstancetype(requestParameters: ListNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineInstancetypeList> {
        const response = await this.listNamespacedVirtualMachineInstancetypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of VirtualMachinePool objects.
     */
    async listNamespacedVirtualMachinePoolRaw(requestParameters: ListNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePoolList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachinePool.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1alpha1VirtualMachinePoolListFromJSON(jsonValue));
    }

    /**
     * Get a list of VirtualMachinePool objects.
     */
    async listNamespacedVirtualMachinePool(requestParameters: ListNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<V1alpha1VirtualMachinePoolList> {
        const response = await this.listNamespacedVirtualMachinePoolRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of VirtualMachinePreference objects.
     */
    async listNamespacedVirtualMachinePreferenceRaw(requestParameters: ListNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachinePreferenceList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachinePreference.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachinePreferenceListFromJSON(jsonValue));
    }

    /**
     * Get a list of VirtualMachinePreference objects.
     */
    async listNamespacedVirtualMachinePreference(requestParameters: ListNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachinePreferenceList> {
        const response = await this.listNamespacedVirtualMachinePreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of VirtualMachineRestore objects.
     */
    async listNamespacedVirtualMachineRestoreRaw(requestParameters: ListNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineRestoreList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineRestore.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineRestoreListFromJSON(jsonValue));
    }

    /**
     * Get a list of VirtualMachineRestore objects.
     */
    async listNamespacedVirtualMachineRestore(requestParameters: ListNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineRestoreList> {
        const response = await this.listNamespacedVirtualMachineRestoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of VirtualMachineSnapshot objects.
     */
    async listNamespacedVirtualMachineSnapshotRaw(requestParameters: ListNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineSnapshotList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineSnapshot.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineSnapshotListFromJSON(jsonValue));
    }

    /**
     * Get a list of VirtualMachineSnapshot objects.
     */
    async listNamespacedVirtualMachineSnapshot(requestParameters: ListNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineSnapshotList> {
        const response = await this.listNamespacedVirtualMachineSnapshotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of VirtualMachineSnapshotContent objects.
     */
    async listNamespacedVirtualMachineSnapshotContentRaw(requestParameters: ListNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineSnapshotContentList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedVirtualMachineSnapshotContent.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineSnapshotContentListFromJSON(jsonValue));
    }

    /**
     * Get a list of VirtualMachineSnapshotContent objects.
     */
    async listNamespacedVirtualMachineSnapshotContent(requestParameters: ListNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineSnapshotContentList> {
        const response = await this.listNamespacedVirtualMachineSnapshotContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of VirtualMachineClone objects.
     */
    async listVirtualMachineCloneRaw(requestParameters: ListVirtualMachineCloneRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineCloneList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/clone.kubevirt.io/v1beta1/virtualmachineclones`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineCloneListFromJSON(jsonValue));
    }

    /**
     * Get a list of VirtualMachineClone objects.
     */
    async listVirtualMachineClone(requestParameters: ListVirtualMachineCloneRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineCloneList> {
        const response = await this.listVirtualMachineCloneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of VirtualMachineClusterInstancetype objects.
     */
    async listVirtualMachineClusterInstancetypeRaw(requestParameters: ListVirtualMachineClusterInstancetypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineClusterInstancetypeList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineClusterInstancetypeListFromJSON(jsonValue));
    }

    /**
     * Get a list of VirtualMachineClusterInstancetype objects.
     */
    async listVirtualMachineClusterInstancetype(requestParameters: ListVirtualMachineClusterInstancetypeRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineClusterInstancetypeList> {
        const response = await this.listVirtualMachineClusterInstancetypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of VirtualMachineClusterPreference objects.
     */
    async listVirtualMachineClusterPreferenceRaw(requestParameters: ListVirtualMachineClusterPreferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineClusterPreferenceList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineClusterPreferenceListFromJSON(jsonValue));
    }

    /**
     * Get a list of VirtualMachineClusterPreference objects.
     */
    async listVirtualMachineClusterPreference(requestParameters: ListVirtualMachineClusterPreferenceRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineClusterPreferenceList> {
        const response = await this.listVirtualMachineClusterPreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all VirtualMachineExport objects.
     */
    async listVirtualMachineExportForAllNamespacesRaw(requestParameters: ListVirtualMachineExportForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineExportList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/export.kubevirt.io/v1beta1/virtualmachineexports`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineExportListFromJSON(jsonValue));
    }

    /**
     * Get a list of all VirtualMachineExport objects.
     */
    async listVirtualMachineExportForAllNamespaces(requestParameters: ListVirtualMachineExportForAllNamespacesRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineExportList> {
        const response = await this.listVirtualMachineExportForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all VirtualMachine objects.
     */
    async listVirtualMachineForAllNamespacesRaw(requestParameters: ListVirtualMachineForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/virtualmachines`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineListFromJSON(jsonValue));
    }

    /**
     * Get a list of all VirtualMachine objects.
     */
    async listVirtualMachineForAllNamespaces(requestParameters: ListVirtualMachineForAllNamespacesRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineList> {
        const response = await this.listVirtualMachineForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all VirtualMachineInstance objects.
     */
    async listVirtualMachineInstanceForAllNamespacesRaw(requestParameters: ListVirtualMachineInstanceForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/virtualmachineinstances`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceListFromJSON(jsonValue));
    }

    /**
     * Get a list of all VirtualMachineInstance objects.
     */
    async listVirtualMachineInstanceForAllNamespaces(requestParameters: ListVirtualMachineInstanceForAllNamespacesRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceList> {
        const response = await this.listVirtualMachineInstanceForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all VirtualMachineInstanceMigration objects.
     */
    async listVirtualMachineInstanceMigrationForAllNamespacesRaw(requestParameters: ListVirtualMachineInstanceMigrationForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceMigrationList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/virtualmachineinstancemigrations`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceMigrationListFromJSON(jsonValue));
    }

    /**
     * Get a list of all VirtualMachineInstanceMigration objects.
     */
    async listVirtualMachineInstanceMigrationForAllNamespaces(requestParameters: ListVirtualMachineInstanceMigrationForAllNamespacesRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceMigrationList> {
        const response = await this.listVirtualMachineInstanceMigrationForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all VirtualMachineInstancePreset objects.
     */
    async listVirtualMachineInstancePresetForAllNamespacesRaw(requestParameters: ListVirtualMachineInstancePresetForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstancePresetList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/virtualmachineinstancepresets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstancePresetListFromJSON(jsonValue));
    }

    /**
     * Get a list of all VirtualMachineInstancePreset objects.
     */
    async listVirtualMachineInstancePresetForAllNamespaces(requestParameters: ListVirtualMachineInstancePresetForAllNamespacesRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstancePresetList> {
        const response = await this.listVirtualMachineInstancePresetForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all VirtualMachineInstanceReplicaSet objects.
     */
    async listVirtualMachineInstanceReplicaSetForAllNamespacesRaw(requestParameters: ListVirtualMachineInstanceReplicaSetForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceReplicaSetList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/virtualmachineinstancereplicasets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceReplicaSetListFromJSON(jsonValue));
    }

    /**
     * Get a list of all VirtualMachineInstanceReplicaSet objects.
     */
    async listVirtualMachineInstanceReplicaSetForAllNamespaces(requestParameters: ListVirtualMachineInstanceReplicaSetForAllNamespacesRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceReplicaSetList> {
        const response = await this.listVirtualMachineInstanceReplicaSetForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all VirtualMachineInstancetype objects.
     */
    async listVirtualMachineInstancetypeForAllNamespacesRaw(requestParameters: ListVirtualMachineInstancetypeForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineInstancetypeList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachineinstancetypes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineInstancetypeListFromJSON(jsonValue));
    }

    /**
     * Get a list of all VirtualMachineInstancetype objects.
     */
    async listVirtualMachineInstancetypeForAllNamespaces(requestParameters: ListVirtualMachineInstancetypeForAllNamespacesRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineInstancetypeList> {
        const response = await this.listVirtualMachineInstancetypeForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all VirtualMachinePool objects.
     */
    async listVirtualMachinePoolForAllNamespacesRaw(requestParameters: ListVirtualMachinePoolForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePoolList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/pool.kubevirt.io/v1alpha1/virtualmachinepools`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1alpha1VirtualMachinePoolListFromJSON(jsonValue));
    }

    /**
     * Get a list of all VirtualMachinePool objects.
     */
    async listVirtualMachinePoolForAllNamespaces(requestParameters: ListVirtualMachinePoolForAllNamespacesRequest, initOverrides?: RequestInit): Promise<V1alpha1VirtualMachinePoolList> {
        const response = await this.listVirtualMachinePoolForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all VirtualMachinePreference objects.
     */
    async listVirtualMachinePreferenceForAllNamespacesRaw(requestParameters: ListVirtualMachinePreferenceForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachinePreferenceList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachinepreferences`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachinePreferenceListFromJSON(jsonValue));
    }

    /**
     * Get a list of all VirtualMachinePreference objects.
     */
    async listVirtualMachinePreferenceForAllNamespaces(requestParameters: ListVirtualMachinePreferenceForAllNamespacesRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachinePreferenceList> {
        const response = await this.listVirtualMachinePreferenceForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all VirtualMachineRestore objects.
     */
    async listVirtualMachineRestoreForAllNamespacesRaw(requestParameters: ListVirtualMachineRestoreForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineRestoreList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/virtualmachinerestores`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineRestoreListFromJSON(jsonValue));
    }

    /**
     * Get a list of all VirtualMachineRestore objects.
     */
    async listVirtualMachineRestoreForAllNamespaces(requestParameters: ListVirtualMachineRestoreForAllNamespacesRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineRestoreList> {
        const response = await this.listVirtualMachineRestoreForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all VirtualMachineSnapshotContent objects.
     */
    async listVirtualMachineSnapshotContentForAllNamespacesRaw(requestParameters: ListVirtualMachineSnapshotContentForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineSnapshotContentList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/virtualmachinesnapshotcontents`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineSnapshotContentListFromJSON(jsonValue));
    }

    /**
     * Get a list of all VirtualMachineSnapshotContent objects.
     */
    async listVirtualMachineSnapshotContentForAllNamespaces(requestParameters: ListVirtualMachineSnapshotContentForAllNamespacesRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineSnapshotContentList> {
        const response = await this.listVirtualMachineSnapshotContentForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all VirtualMachineSnapshot objects.
     */
    async listVirtualMachineSnapshotForAllNamespacesRaw(requestParameters: ListVirtualMachineSnapshotForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineSnapshotList>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/virtualmachinesnapshots`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineSnapshotListFromJSON(jsonValue));
    }

    /**
     * Get a list of all VirtualMachineSnapshot objects.
     */
    async listVirtualMachineSnapshotForAllNamespaces(requestParameters: ListVirtualMachineSnapshotForAllNamespacesRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineSnapshotList> {
        const response = await this.listVirtualMachineSnapshotForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a MigrationPolicy object.
     */
    async patchMigrationPolicyRaw(requestParameters: PatchMigrationPolicyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1alpha1MigrationPolicy>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchMigrationPolicy.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchMigrationPolicy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1alpha1MigrationPolicyFromJSON(jsonValue));
    }

    /**
     * Patch a MigrationPolicy object.
     */
    async patchMigrationPolicy(requestParameters: PatchMigrationPolicyRequest, initOverrides?: RequestInit): Promise<V1alpha1MigrationPolicy> {
        const response = await this.patchMigrationPolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a KubeVirt object.
     */
    async patchNamespacedKubeVirtRaw(requestParameters: PatchNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1KubeVirt>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedKubeVirt.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedKubeVirt.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedKubeVirt.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1KubeVirtFromJSON(jsonValue));
    }

    /**
     * Patch a KubeVirt object.
     */
    async patchNamespacedKubeVirt(requestParameters: PatchNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<V1KubeVirt> {
        const response = await this.patchNamespacedKubeVirtRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a VirtualMachine object.
     */
    async patchNamespacedVirtualMachineRaw(requestParameters: PatchNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachine>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachine.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachine.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachine.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineFromJSON(jsonValue));
    }

    /**
     * Patch a VirtualMachine object.
     */
    async patchNamespacedVirtualMachine(requestParameters: PatchNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<V1VirtualMachine> {
        const response = await this.patchNamespacedVirtualMachineRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a VirtualMachineExport object.
     */
    async patchNamespacedVirtualMachineExportRaw(requestParameters: PatchNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineExport>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineExport.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineExport.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineExport.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineExportFromJSON(jsonValue));
    }

    /**
     * Patch a VirtualMachineExport object.
     */
    async patchNamespacedVirtualMachineExport(requestParameters: PatchNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineExport> {
        const response = await this.patchNamespacedVirtualMachineExportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a VirtualMachineInstance object.
     */
    async patchNamespacedVirtualMachineInstanceRaw(requestParameters: PatchNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstance>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineInstance.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineInstance.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineInstance.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceFromJSON(jsonValue));
    }

    /**
     * Patch a VirtualMachineInstance object.
     */
    async patchNamespacedVirtualMachineInstance(requestParameters: PatchNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstance> {
        const response = await this.patchNamespacedVirtualMachineInstanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a VirtualMachineInstanceMigration object.
     */
    async patchNamespacedVirtualMachineInstanceMigrationRaw(requestParameters: PatchNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceMigration>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineInstanceMigration.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineInstanceMigration.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineInstanceMigration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceMigrationFromJSON(jsonValue));
    }

    /**
     * Patch a VirtualMachineInstanceMigration object.
     */
    async patchNamespacedVirtualMachineInstanceMigration(requestParameters: PatchNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceMigration> {
        const response = await this.patchNamespacedVirtualMachineInstanceMigrationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a VirtualMachineInstancePreset object.
     */
    async patchNamespacedVirtualMachineInstancePresetRaw(requestParameters: PatchNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstancePreset>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineInstancePreset.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineInstancePreset.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineInstancePreset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstancePresetFromJSON(jsonValue));
    }

    /**
     * Patch a VirtualMachineInstancePreset object.
     */
    async patchNamespacedVirtualMachineInstancePreset(requestParameters: PatchNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstancePreset> {
        const response = await this.patchNamespacedVirtualMachineInstancePresetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a VirtualMachineInstanceReplicaSet object.
     */
    async patchNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters: PatchNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceReplicaSet>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineInstanceReplicaSet.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineInstanceReplicaSet.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineInstanceReplicaSet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceReplicaSetFromJSON(jsonValue));
    }

    /**
     * Patch a VirtualMachineInstanceReplicaSet object.
     */
    async patchNamespacedVirtualMachineInstanceReplicaSet(requestParameters: PatchNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceReplicaSet> {
        const response = await this.patchNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a VirtualMachineInstancetype object.
     */
    async patchNamespacedVirtualMachineInstancetypeRaw(requestParameters: PatchNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineInstancetype>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineInstancetype.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineInstancetype.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineInstancetype.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineInstancetypeFromJSON(jsonValue));
    }

    /**
     * Patch a VirtualMachineInstancetype object.
     */
    async patchNamespacedVirtualMachineInstancetype(requestParameters: PatchNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineInstancetype> {
        const response = await this.patchNamespacedVirtualMachineInstancetypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a VirtualMachinePool object.
     */
    async patchNamespacedVirtualMachinePoolRaw(requestParameters: PatchNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePool>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachinePool.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachinePool.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachinePool.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1alpha1VirtualMachinePoolFromJSON(jsonValue));
    }

    /**
     * Patch a VirtualMachinePool object.
     */
    async patchNamespacedVirtualMachinePool(requestParameters: PatchNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<V1alpha1VirtualMachinePool> {
        const response = await this.patchNamespacedVirtualMachinePoolRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a VirtualMachinePreference object.
     */
    async patchNamespacedVirtualMachinePreferenceRaw(requestParameters: PatchNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachinePreference>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachinePreference.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachinePreference.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachinePreference.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachinePreferenceFromJSON(jsonValue));
    }

    /**
     * Patch a VirtualMachinePreference object.
     */
    async patchNamespacedVirtualMachinePreference(requestParameters: PatchNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachinePreference> {
        const response = await this.patchNamespacedVirtualMachinePreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a VirtualMachineRestore object.
     */
    async patchNamespacedVirtualMachineRestoreRaw(requestParameters: PatchNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineRestore>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineRestore.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineRestore.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineRestore.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineRestoreFromJSON(jsonValue));
    }

    /**
     * Patch a VirtualMachineRestore object.
     */
    async patchNamespacedVirtualMachineRestore(requestParameters: PatchNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineRestore> {
        const response = await this.patchNamespacedVirtualMachineRestoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a VirtualMachineSnapshot object.
     */
    async patchNamespacedVirtualMachineSnapshotRaw(requestParameters: PatchNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineSnapshot>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineSnapshot.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineSnapshot.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineSnapshot.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineSnapshotFromJSON(jsonValue));
    }

    /**
     * Patch a VirtualMachineSnapshot object.
     */
    async patchNamespacedVirtualMachineSnapshot(requestParameters: PatchNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineSnapshot> {
        const response = await this.patchNamespacedVirtualMachineSnapshotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a VirtualMachineSnapshotContent object.
     */
    async patchNamespacedVirtualMachineSnapshotContentRaw(requestParameters: PatchNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineSnapshotContent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedVirtualMachineSnapshotContent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedVirtualMachineSnapshotContent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedVirtualMachineSnapshotContent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineSnapshotContentFromJSON(jsonValue));
    }

    /**
     * Patch a VirtualMachineSnapshotContent object.
     */
    async patchNamespacedVirtualMachineSnapshotContent(requestParameters: PatchNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineSnapshotContent> {
        const response = await this.patchNamespacedVirtualMachineSnapshotContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a VirtualMachineClone object.
     */
    async patchVirtualMachineCloneRaw(requestParameters: PatchVirtualMachineCloneRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineClone>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchVirtualMachineClone.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchVirtualMachineClone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/clone.kubevirt.io/v1beta1/virtualmachineclones/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineCloneFromJSON(jsonValue));
    }

    /**
     * Patch a VirtualMachineClone object.
     */
    async patchVirtualMachineClone(requestParameters: PatchVirtualMachineCloneRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineClone> {
        const response = await this.patchVirtualMachineCloneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a VirtualMachineClusterInstancetype object.
     */
    async patchVirtualMachineClusterInstancetypeRaw(requestParameters: PatchVirtualMachineClusterInstancetypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineClusterInstancetype>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchVirtualMachineClusterInstancetype.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchVirtualMachineClusterInstancetype.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineClusterInstancetypeFromJSON(jsonValue));
    }

    /**
     * Patch a VirtualMachineClusterInstancetype object.
     */
    async patchVirtualMachineClusterInstancetype(requestParameters: PatchVirtualMachineClusterInstancetypeRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineClusterInstancetype> {
        const response = await this.patchVirtualMachineClusterInstancetypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch a VirtualMachineClusterPreference object.
     */
    async patchVirtualMachineClusterPreferenceRaw(requestParameters: PatchVirtualMachineClusterPreferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineClusterPreference>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchVirtualMachineClusterPreference.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchVirtualMachineClusterPreference.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineClusterPreferenceFromJSON(jsonValue));
    }

    /**
     * Patch a VirtualMachineClusterPreference object.
     */
    async patchVirtualMachineClusterPreference(requestParameters: PatchVirtualMachineClusterPreferenceRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineClusterPreference> {
        const response = await this.patchVirtualMachineClusterPreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a MigrationPolicy object.
     */
    async readMigrationPolicyRaw(requestParameters: ReadMigrationPolicyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1alpha1MigrationPolicy>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readMigrationPolicy.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1alpha1MigrationPolicyFromJSON(jsonValue));
    }

    /**
     * Get a MigrationPolicy object.
     */
    async readMigrationPolicy(requestParameters: ReadMigrationPolicyRequest, initOverrides?: RequestInit): Promise<V1alpha1MigrationPolicy> {
        const response = await this.readMigrationPolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a KubeVirt object.
     */
    async readNamespacedKubeVirtRaw(requestParameters: ReadNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1KubeVirt>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedKubeVirt.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedKubeVirt.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1KubeVirtFromJSON(jsonValue));
    }

    /**
     * Get a KubeVirt object.
     */
    async readNamespacedKubeVirt(requestParameters: ReadNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<V1KubeVirt> {
        const response = await this.readNamespacedKubeVirtRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a VirtualMachine object.
     */
    async readNamespacedVirtualMachineRaw(requestParameters: ReadNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachine>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachine.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachine.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineFromJSON(jsonValue));
    }

    /**
     * Get a VirtualMachine object.
     */
    async readNamespacedVirtualMachine(requestParameters: ReadNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<V1VirtualMachine> {
        const response = await this.readNamespacedVirtualMachineRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a VirtualMachineExport object.
     */
    async readNamespacedVirtualMachineExportRaw(requestParameters: ReadNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineExport>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineExport.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineExport.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineExportFromJSON(jsonValue));
    }

    /**
     * Get a VirtualMachineExport object.
     */
    async readNamespacedVirtualMachineExport(requestParameters: ReadNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineExport> {
        const response = await this.readNamespacedVirtualMachineExportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a VirtualMachineInstance object.
     */
    async readNamespacedVirtualMachineInstanceRaw(requestParameters: ReadNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstance>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineInstance.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineInstance.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceFromJSON(jsonValue));
    }

    /**
     * Get a VirtualMachineInstance object.
     */
    async readNamespacedVirtualMachineInstance(requestParameters: ReadNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstance> {
        const response = await this.readNamespacedVirtualMachineInstanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a VirtualMachineInstanceMigration object.
     */
    async readNamespacedVirtualMachineInstanceMigrationRaw(requestParameters: ReadNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceMigration>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineInstanceMigration.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineInstanceMigration.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceMigrationFromJSON(jsonValue));
    }

    /**
     * Get a VirtualMachineInstanceMigration object.
     */
    async readNamespacedVirtualMachineInstanceMigration(requestParameters: ReadNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceMigration> {
        const response = await this.readNamespacedVirtualMachineInstanceMigrationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a VirtualMachineInstancePreset object.
     */
    async readNamespacedVirtualMachineInstancePresetRaw(requestParameters: ReadNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstancePreset>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineInstancePreset.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineInstancePreset.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstancePresetFromJSON(jsonValue));
    }

    /**
     * Get a VirtualMachineInstancePreset object.
     */
    async readNamespacedVirtualMachineInstancePreset(requestParameters: ReadNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstancePreset> {
        const response = await this.readNamespacedVirtualMachineInstancePresetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a VirtualMachineInstanceReplicaSet object.
     */
    async readNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters: ReadNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceReplicaSet>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineInstanceReplicaSet.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineInstanceReplicaSet.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceReplicaSetFromJSON(jsonValue));
    }

    /**
     * Get a VirtualMachineInstanceReplicaSet object.
     */
    async readNamespacedVirtualMachineInstanceReplicaSet(requestParameters: ReadNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceReplicaSet> {
        const response = await this.readNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a VirtualMachineInstancetype object.
     */
    async readNamespacedVirtualMachineInstancetypeRaw(requestParameters: ReadNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineInstancetype>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineInstancetype.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineInstancetype.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineInstancetypeFromJSON(jsonValue));
    }

    /**
     * Get a VirtualMachineInstancetype object.
     */
    async readNamespacedVirtualMachineInstancetype(requestParameters: ReadNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineInstancetype> {
        const response = await this.readNamespacedVirtualMachineInstancetypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a VirtualMachinePool object.
     */
    async readNamespacedVirtualMachinePoolRaw(requestParameters: ReadNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePool>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachinePool.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachinePool.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1alpha1VirtualMachinePoolFromJSON(jsonValue));
    }

    /**
     * Get a VirtualMachinePool object.
     */
    async readNamespacedVirtualMachinePool(requestParameters: ReadNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<V1alpha1VirtualMachinePool> {
        const response = await this.readNamespacedVirtualMachinePoolRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a VirtualMachinePreference object.
     */
    async readNamespacedVirtualMachinePreferenceRaw(requestParameters: ReadNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachinePreference>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachinePreference.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachinePreference.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachinePreferenceFromJSON(jsonValue));
    }

    /**
     * Get a VirtualMachinePreference object.
     */
    async readNamespacedVirtualMachinePreference(requestParameters: ReadNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachinePreference> {
        const response = await this.readNamespacedVirtualMachinePreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a VirtualMachineRestore object.
     */
    async readNamespacedVirtualMachineRestoreRaw(requestParameters: ReadNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineRestore>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineRestore.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineRestore.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineRestoreFromJSON(jsonValue));
    }

    /**
     * Get a VirtualMachineRestore object.
     */
    async readNamespacedVirtualMachineRestore(requestParameters: ReadNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineRestore> {
        const response = await this.readNamespacedVirtualMachineRestoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a VirtualMachineSnapshot object.
     */
    async readNamespacedVirtualMachineSnapshotRaw(requestParameters: ReadNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineSnapshot>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineSnapshot.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineSnapshot.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineSnapshotFromJSON(jsonValue));
    }

    /**
     * Get a VirtualMachineSnapshot object.
     */
    async readNamespacedVirtualMachineSnapshot(requestParameters: ReadNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineSnapshot> {
        const response = await this.readNamespacedVirtualMachineSnapshotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a VirtualMachineSnapshotContent object.
     */
    async readNamespacedVirtualMachineSnapshotContentRaw(requestParameters: ReadNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineSnapshotContent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedVirtualMachineSnapshotContent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedVirtualMachineSnapshotContent.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineSnapshotContentFromJSON(jsonValue));
    }

    /**
     * Get a VirtualMachineSnapshotContent object.
     */
    async readNamespacedVirtualMachineSnapshotContent(requestParameters: ReadNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineSnapshotContent> {
        const response = await this.readNamespacedVirtualMachineSnapshotContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a VirtualMachineClone object.
     */
    async readVirtualMachineCloneRaw(requestParameters: ReadVirtualMachineCloneRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineClone>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readVirtualMachineClone.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/clone.kubevirt.io/v1beta1/virtualmachineclones/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineCloneFromJSON(jsonValue));
    }

    /**
     * Get a VirtualMachineClone object.
     */
    async readVirtualMachineClone(requestParameters: ReadVirtualMachineCloneRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineClone> {
        const response = await this.readVirtualMachineCloneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a VirtualMachineClusterInstancetype object.
     */
    async readVirtualMachineClusterInstancetypeRaw(requestParameters: ReadVirtualMachineClusterInstancetypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineClusterInstancetype>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readVirtualMachineClusterInstancetype.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineClusterInstancetypeFromJSON(jsonValue));
    }

    /**
     * Get a VirtualMachineClusterInstancetype object.
     */
    async readVirtualMachineClusterInstancetype(requestParameters: ReadVirtualMachineClusterInstancetypeRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineClusterInstancetype> {
        const response = await this.readVirtualMachineClusterInstancetypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a VirtualMachineClusterPreference object.
     */
    async readVirtualMachineClusterPreferenceRaw(requestParameters: ReadVirtualMachineClusterPreferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineClusterPreference>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readVirtualMachineClusterPreference.');
        }

        const queryParameters: any = {};

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineClusterPreferenceFromJSON(jsonValue));
    }

    /**
     * Get a VirtualMachineClusterPreference object.
     */
    async readVirtualMachineClusterPreference(requestParameters: ReadVirtualMachineClusterPreferenceRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineClusterPreference> {
        const response = await this.readVirtualMachineClusterPreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a MigrationPolicy object.
     */
    async replaceMigrationPolicyRaw(requestParameters: ReplaceMigrationPolicyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1alpha1MigrationPolicy>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceMigrationPolicy.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceMigrationPolicy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1alpha1MigrationPolicyToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1alpha1MigrationPolicyFromJSON(jsonValue));
    }

    /**
     * Update a MigrationPolicy object.
     */
    async replaceMigrationPolicy(requestParameters: ReplaceMigrationPolicyRequest, initOverrides?: RequestInit): Promise<V1alpha1MigrationPolicy> {
        const response = await this.replaceMigrationPolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a KubeVirt object.
     */
    async replaceNamespacedKubeVirtRaw(requestParameters: ReplaceNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1KubeVirt>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedKubeVirt.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedKubeVirt.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedKubeVirt.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1KubeVirtToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1KubeVirtFromJSON(jsonValue));
    }

    /**
     * Update a KubeVirt object.
     */
    async replaceNamespacedKubeVirt(requestParameters: ReplaceNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<V1KubeVirt> {
        const response = await this.replaceNamespacedKubeVirtRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a VirtualMachine object.
     */
    async replaceNamespacedVirtualMachineRaw(requestParameters: ReplaceNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachine>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachine.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachine.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachine.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1VirtualMachineToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineFromJSON(jsonValue));
    }

    /**
     * Update a VirtualMachine object.
     */
    async replaceNamespacedVirtualMachine(requestParameters: ReplaceNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<V1VirtualMachine> {
        const response = await this.replaceNamespacedVirtualMachineRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a VirtualMachineExport object.
     */
    async replaceNamespacedVirtualMachineExportRaw(requestParameters: ReplaceNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineExport>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineExport.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineExport.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineExport.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineExportToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineExportFromJSON(jsonValue));
    }

    /**
     * Update a VirtualMachineExport object.
     */
    async replaceNamespacedVirtualMachineExport(requestParameters: ReplaceNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineExport> {
        const response = await this.replaceNamespacedVirtualMachineExportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a VirtualMachineInstance object.
     */
    async replaceNamespacedVirtualMachineInstanceRaw(requestParameters: ReplaceNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstance>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineInstance.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineInstance.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineInstance.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1VirtualMachineInstanceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceFromJSON(jsonValue));
    }

    /**
     * Update a VirtualMachineInstance object.
     */
    async replaceNamespacedVirtualMachineInstance(requestParameters: ReplaceNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstance> {
        const response = await this.replaceNamespacedVirtualMachineInstanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a VirtualMachineInstanceMigration object.
     */
    async replaceNamespacedVirtualMachineInstanceMigrationRaw(requestParameters: ReplaceNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceMigration>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineInstanceMigration.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineInstanceMigration.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineInstanceMigration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1VirtualMachineInstanceMigrationToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceMigrationFromJSON(jsonValue));
    }

    /**
     * Update a VirtualMachineInstanceMigration object.
     */
    async replaceNamespacedVirtualMachineInstanceMigration(requestParameters: ReplaceNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceMigration> {
        const response = await this.replaceNamespacedVirtualMachineInstanceMigrationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a VirtualMachineInstancePreset object.
     */
    async replaceNamespacedVirtualMachineInstancePresetRaw(requestParameters: ReplaceNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstancePreset>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineInstancePreset.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineInstancePreset.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineInstancePreset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1VirtualMachineInstancePresetToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstancePresetFromJSON(jsonValue));
    }

    /**
     * Update a VirtualMachineInstancePreset object.
     */
    async replaceNamespacedVirtualMachineInstancePreset(requestParameters: ReplaceNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstancePreset> {
        const response = await this.replaceNamespacedVirtualMachineInstancePresetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a VirtualMachineInstanceReplicaSet object.
     */
    async replaceNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters: ReplaceNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceReplicaSet>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineInstanceReplicaSet.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineInstanceReplicaSet.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineInstanceReplicaSet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1VirtualMachineInstanceReplicaSetToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceReplicaSetFromJSON(jsonValue));
    }

    /**
     * Update a VirtualMachineInstanceReplicaSet object.
     */
    async replaceNamespacedVirtualMachineInstanceReplicaSet(requestParameters: ReplaceNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceReplicaSet> {
        const response = await this.replaceNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a VirtualMachineInstancetype object.
     */
    async replaceNamespacedVirtualMachineInstancetypeRaw(requestParameters: ReplaceNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineInstancetype>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineInstancetype.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineInstancetype.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineInstancetype.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineInstancetypeToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineInstancetypeFromJSON(jsonValue));
    }

    /**
     * Update a VirtualMachineInstancetype object.
     */
    async replaceNamespacedVirtualMachineInstancetype(requestParameters: ReplaceNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineInstancetype> {
        const response = await this.replaceNamespacedVirtualMachineInstancetypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a VirtualMachinePool object.
     */
    async replaceNamespacedVirtualMachinePoolRaw(requestParameters: ReplaceNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1alpha1VirtualMachinePool>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachinePool.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachinePool.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachinePool.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1alpha1VirtualMachinePoolToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1alpha1VirtualMachinePoolFromJSON(jsonValue));
    }

    /**
     * Update a VirtualMachinePool object.
     */
    async replaceNamespacedVirtualMachinePool(requestParameters: ReplaceNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<V1alpha1VirtualMachinePool> {
        const response = await this.replaceNamespacedVirtualMachinePoolRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a VirtualMachinePreference object.
     */
    async replaceNamespacedVirtualMachinePreferenceRaw(requestParameters: ReplaceNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachinePreference>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachinePreference.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachinePreference.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachinePreference.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachinePreferenceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachinePreferenceFromJSON(jsonValue));
    }

    /**
     * Update a VirtualMachinePreference object.
     */
    async replaceNamespacedVirtualMachinePreference(requestParameters: ReplaceNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachinePreference> {
        const response = await this.replaceNamespacedVirtualMachinePreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a VirtualMachineRestore object.
     */
    async replaceNamespacedVirtualMachineRestoreRaw(requestParameters: ReplaceNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineRestore>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineRestore.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineRestore.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineRestore.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineRestoreToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineRestoreFromJSON(jsonValue));
    }

    /**
     * Update a VirtualMachineRestore object.
     */
    async replaceNamespacedVirtualMachineRestore(requestParameters: ReplaceNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineRestore> {
        const response = await this.replaceNamespacedVirtualMachineRestoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a VirtualMachineSnapshot object.
     */
    async replaceNamespacedVirtualMachineSnapshotRaw(requestParameters: ReplaceNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineSnapshot>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineSnapshot.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineSnapshot.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineSnapshot.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineSnapshotToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineSnapshotFromJSON(jsonValue));
    }

    /**
     * Update a VirtualMachineSnapshot object.
     */
    async replaceNamespacedVirtualMachineSnapshot(requestParameters: ReplaceNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineSnapshot> {
        const response = await this.replaceNamespacedVirtualMachineSnapshotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a VirtualMachineSnapshotContent object.
     */
    async replaceNamespacedVirtualMachineSnapshotContentRaw(requestParameters: ReplaceNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineSnapshotContent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedVirtualMachineSnapshotContent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedVirtualMachineSnapshotContent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedVirtualMachineSnapshotContent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineSnapshotContentToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineSnapshotContentFromJSON(jsonValue));
    }

    /**
     * Update a VirtualMachineSnapshotContent object.
     */
    async replaceNamespacedVirtualMachineSnapshotContent(requestParameters: ReplaceNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineSnapshotContent> {
        const response = await this.replaceNamespacedVirtualMachineSnapshotContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a VirtualMachineClone object.
     */
    async replaceVirtualMachineCloneRaw(requestParameters: ReplaceVirtualMachineCloneRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineClone>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceVirtualMachineClone.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceVirtualMachineClone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/clone.kubevirt.io/v1beta1/virtualmachineclones/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineCloneToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineCloneFromJSON(jsonValue));
    }

    /**
     * Update a VirtualMachineClone object.
     */
    async replaceVirtualMachineClone(requestParameters: ReplaceVirtualMachineCloneRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineClone> {
        const response = await this.replaceVirtualMachineCloneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a VirtualMachineClusterInstancetype object.
     */
    async replaceVirtualMachineClusterInstancetypeRaw(requestParameters: ReplaceVirtualMachineClusterInstancetypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineClusterInstancetype>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceVirtualMachineClusterInstancetype.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceVirtualMachineClusterInstancetype.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineClusterInstancetypeToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineClusterInstancetypeFromJSON(jsonValue));
    }

    /**
     * Update a VirtualMachineClusterInstancetype object.
     */
    async replaceVirtualMachineClusterInstancetype(requestParameters: ReplaceVirtualMachineClusterInstancetypeRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineClusterInstancetype> {
        const response = await this.replaceVirtualMachineClusterInstancetypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a VirtualMachineClusterPreference object.
     */
    async replaceVirtualMachineClusterPreferenceRaw(requestParameters: ReplaceVirtualMachineClusterPreferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1beta1VirtualMachineClusterPreference>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceVirtualMachineClusterPreference.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceVirtualMachineClusterPreference.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1VirtualMachineClusterPreferenceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1VirtualMachineClusterPreferenceFromJSON(jsonValue));
    }

    /**
     * Update a VirtualMachineClusterPreference object.
     */
    async replaceVirtualMachineClusterPreference(requestParameters: ReplaceVirtualMachineClusterPreferenceRequest, initOverrides?: RequestInit): Promise<V1beta1VirtualMachineClusterPreference> {
        const response = await this.replaceVirtualMachineClusterPreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Health endpoint
     */
    async v1CheckHealthRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/healthz`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Health endpoint
     */
    async v1CheckHealth(initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1CheckHealthRaw(initOverrides);
        return await response.value();
    }

    /**
     * Open a websocket connection to a serial console on the specified VirtualMachineInstance.
     */
    async v1ConsoleRaw(requestParameters: V1ConsoleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1Console.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1Console.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/console`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection to a serial console on the specified VirtualMachineInstance.
     */
    async v1Console(requestParameters: V1ConsoleRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1ConsoleRaw(requestParameters, initOverrides);
    }

    /**
     * Expands instancetype and preference into the passed VirtualMachine object.
     */
    async v1ExpandSpecRaw(requestParameters: V1ExpandSpecRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1ExpandSpec.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/expand-vm-spec`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Expands instancetype and preference into the passed VirtualMachine object.
     */
    async v1ExpandSpec(requestParameters: V1ExpandSpecRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1ExpandSpecRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of active filesystems on guest machine via guest agent
     */
    async v1FilesystemlistRaw(requestParameters: V1FilesystemlistRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceFileSystemList>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1Filesystemlist.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1Filesystemlist.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/filesystemlist`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceFileSystemListFromJSON(jsonValue));
    }

    /**
     * Get list of active filesystems on guest machine via guest agent
     */
    async v1Filesystemlist(requestParameters: V1FilesystemlistRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceFileSystemList> {
        const response = await this.v1FilesystemlistRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Freeze a VirtualMachineInstance object.
     */
    async v1FreezeRaw(requestParameters: V1FreezeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1Freeze.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1Freeze.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1Freeze.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/freeze`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1FreezeUnfreezeTimeoutToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Freeze a VirtualMachineInstance object.
     */
    async v1Freeze(requestParameters: V1FreezeRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1FreezeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a KubeVirt API Group
     */
    async v1GetSubAPIGroupRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIGroup>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIGroupFromJSON(jsonValue));
    }

    /**
     * Get a KubeVirt API Group
     */
    async v1GetSubAPIGroup(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIGroup> {
        const response = await this.v1GetSubAPIGroupRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async v1GuestfsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/guestfs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async v1Guestfs(initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1GuestfsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get guest agent os information
     */
    async v1GuestosinfoRaw(requestParameters: V1GuestosinfoRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceGuestAgentInfo>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1Guestosinfo.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1Guestosinfo.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/guestosinfo`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceGuestAgentInfoFromJSON(jsonValue));
    }

    /**
     * Get guest agent os information
     */
    async v1Guestosinfo(requestParameters: V1GuestosinfoRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceGuestAgentInfo> {
        const response = await this.v1GuestosinfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Dumps a VirtualMachineInstance memory.
     */
    async v1MemoryDumpRaw(requestParameters: V1MemoryDumpRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1MemoryDump.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1MemoryDump.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1MemoryDump.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/memorydump`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1VirtualMachineMemoryDumpRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Dumps a VirtualMachineInstance memory.
     */
    async v1MemoryDump(requestParameters: V1MemoryDumpRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1MemoryDumpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Migrate a running VirtualMachine to another node.
     */
    async v1MigrateRaw(requestParameters: V1MigrateRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1Migrate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1Migrate.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1Migrate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/migrate`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1MigrateOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Migrate a running VirtualMachine to another node.
     */
    async v1Migrate(requestParameters: V1MigrateRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1MigrateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pause a VirtualMachineInstance object.
     */
    async v1PauseRaw(requestParameters: V1PauseRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1Pause.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1Pause.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1Pause.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/pause`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PauseOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Pause a VirtualMachineInstance object.
     */
    async v1Pause(requestParameters: V1PauseRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1PauseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove memory dump association.
     */
    async v1RemoveMemoryDumpRaw(requestParameters: V1RemoveMemoryDumpRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1RemoveMemoryDump.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1RemoveMemoryDump.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/removememorydump`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Remove memory dump association.
     */
    async v1RemoveMemoryDump(requestParameters: V1RemoveMemoryDumpRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1RemoveMemoryDumpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reset a VirtualMachineInstance object.
     */
    async v1ResetRaw(requestParameters: V1ResetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1Reset.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1Reset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/reset`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Reset a VirtualMachineInstance object.
     */
    async v1Reset(requestParameters: V1ResetRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1ResetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restart a VirtualMachine object.
     */
    async v1RestartRaw(requestParameters: V1RestartRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1Restart.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1Restart.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/restart`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1RestartOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Restart a VirtualMachine object.
     */
    async v1Restart(requestParameters: V1RestartRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1RestartRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch SEV certificate chain from the node where Virtual Machine is scheduled
     */
    async v1SEVFetchCertChainRaw(requestParameters: V1SEVFetchCertChainRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1SEVPlatformInfo>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1SEVFetchCertChain.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1SEVFetchCertChain.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/sev/fetchcertchain`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SEVPlatformInfoFromJSON(jsonValue));
    }

    /**
     * Fetch SEV certificate chain from the node where Virtual Machine is scheduled
     */
    async v1SEVFetchCertChain(requestParameters: V1SEVFetchCertChainRequest, initOverrides?: RequestInit): Promise<V1SEVPlatformInfo> {
        const response = await this.v1SEVFetchCertChainRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inject SEV launch secret into a Virtual Machine
     */
    async v1SEVInjectLaunchSecretRaw(requestParameters: V1SEVInjectLaunchSecretRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1SEVInjectLaunchSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1SEVInjectLaunchSecret.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1SEVInjectLaunchSecret.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/sev/injectlaunchsecret`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1SEVSecretOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Inject SEV launch secret into a Virtual Machine
     */
    async v1SEVInjectLaunchSecret(requestParameters: V1SEVInjectLaunchSecretRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1SEVInjectLaunchSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Query SEV launch measurement from a Virtual Machine
     */
    async v1SEVQueryLaunchMeasurementRaw(requestParameters: V1SEVQueryLaunchMeasurementRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1SEVMeasurementInfo>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1SEVQueryLaunchMeasurement.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1SEVQueryLaunchMeasurement.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/sev/querylaunchmeasurement`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SEVMeasurementInfoFromJSON(jsonValue));
    }

    /**
     * Query SEV launch measurement from a Virtual Machine
     */
    async v1SEVQueryLaunchMeasurement(requestParameters: V1SEVQueryLaunchMeasurementRequest, initOverrides?: RequestInit): Promise<V1SEVMeasurementInfo> {
        const response = await this.v1SEVQueryLaunchMeasurementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Setup SEV session parameters for a Virtual Machine
     */
    async v1SEVSetupSessionRaw(requestParameters: V1SEVSetupSessionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1SEVSetupSession.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1SEVSetupSession.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1SEVSetupSession.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/sev/setupsession`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1SEVSessionOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Setup SEV session parameters for a Virtual Machine
     */
    async v1SEVSetupSession(requestParameters: V1SEVSetupSessionRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1SEVSetupSessionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Soft reboot a VirtualMachineInstance object.
     */
    async v1SoftRebootRaw(requestParameters: V1SoftRebootRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1SoftReboot.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1SoftReboot.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/softreboot`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Soft reboot a VirtualMachineInstance object.
     */
    async v1SoftReboot(requestParameters: V1SoftRebootRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1SoftRebootRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Start a VirtualMachine object.
     */
    async v1StartRaw(requestParameters: V1StartRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1Start.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1Start.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1Start.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/start`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1StartOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Start a VirtualMachine object.
     */
    async v1Start(requestParameters: V1StartRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1StartRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stop a VirtualMachine object.
     */
    async v1StopRaw(requestParameters: V1StopRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1Stop.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1Stop.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/stop`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1StopOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Stop a VirtualMachine object.
     */
    async v1Stop(requestParameters: V1StopRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1StopRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unfreeze a VirtualMachineInstance object.
     */
    async v1UnfreezeRaw(requestParameters: V1UnfreezeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1Unfreeze.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1Unfreeze.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/unfreeze`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Unfreeze a VirtualMachineInstance object.
     */
    async v1Unfreeze(requestParameters: V1UnfreezeRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1UnfreezeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unpause a VirtualMachineInstance object.
     */
    async v1UnpauseRaw(requestParameters: V1UnpauseRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1Unpause.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1Unpause.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1Unpause.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/unpause`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1UnpauseOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Unpause a VirtualMachineInstance object.
     */
    async v1Unpause(requestParameters: V1UnpauseRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1UnpauseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of active users via guest agent
     */
    async v1UserlistRaw(requestParameters: V1UserlistRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceGuestOSUserList>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1Userlist.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1Userlist.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/userlist`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceGuestOSUserListFromJSON(jsonValue));
    }

    /**
     * Get list of active users via guest agent
     */
    async v1Userlist(requestParameters: V1UserlistRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceGuestOSUserList> {
        const response = await this.v1UserlistRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Open a websocket connection to connect to VNC on the specified VirtualMachineInstance.
     */
    async v1VNCRaw(requestParameters: V1VNCRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1VNC.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1VNC.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/vnc`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection to connect to VNC on the specified VirtualMachineInstance.
     */
    async v1VNC(requestParameters: V1VNCRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1VNCRaw(requestParameters, initOverrides);
    }

    /**
     * Get a PNG VNC screenshot of the specified VirtualMachineInstance.
     */
    async v1VNCScreenshotRaw(requestParameters: V1VNCScreenshotRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1VNCScreenshot.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1VNCScreenshot.');
        }

        const queryParameters: any = {};

        if (requestParameters.moveCursor !== undefined) {
            queryParameters['moveCursor'] = requestParameters.moveCursor;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/vnc/screenshot`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get a PNG VNC screenshot of the specified VirtualMachineInstance.
     */
    async v1VNCScreenshot(requestParameters: V1VNCScreenshotRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1VNCScreenshotRaw(requestParameters, initOverrides);
    }

    /**
     * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port via VSOCK.
     */
    async v1VSOCKRaw(requestParameters: V1VSOCKRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1VSOCK.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1VSOCK.');
        }

        if (requestParameters.port === null || requestParameters.port === undefined) {
            throw new runtime.RequiredError('port','Required parameter requestParameters.port was null or undefined when calling v1VSOCK.');
        }

        const queryParameters: any = {};

        if (requestParameters.port !== undefined) {
            queryParameters['port'] = requestParameters.port;
        }

        if (requestParameters.tls !== undefined) {
            queryParameters['tls'] = requestParameters.tls;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/vsock`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port via VSOCK.
     */
    async v1VSOCK(requestParameters: V1VSOCKRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1VSOCKRaw(requestParameters, initOverrides);
    }

    /**
     */
    async v1VersionRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/version`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async v1Version(initOverrides?: RequestInit): Promise<void> {
        await this.v1VersionRaw(initOverrides);
    }

    /**
     * Health endpoint
     */
    async v1alpha3CheckHealthRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/healthz`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Health endpoint
     */
    async v1alpha3CheckHealth(initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3CheckHealthRaw(initOverrides);
        return await response.value();
    }

    /**
     * Open a websocket connection to a serial console on the specified VirtualMachineInstance.
     */
    async v1alpha3ConsoleRaw(requestParameters: V1alpha3ConsoleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3Console.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Console.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/console`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection to a serial console on the specified VirtualMachineInstance.
     */
    async v1alpha3Console(requestParameters: V1alpha3ConsoleRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1alpha3ConsoleRaw(requestParameters, initOverrides);
    }

    /**
     * Expands instancetype and preference into the passed VirtualMachine object.
     */
    async v1alpha3ExpandSpecRaw(requestParameters: V1alpha3ExpandSpecRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3ExpandSpec.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/expand-vm-spec`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Expands instancetype and preference into the passed VirtualMachine object.
     */
    async v1alpha3ExpandSpec(requestParameters: V1alpha3ExpandSpecRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3ExpandSpecRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of active filesystems on guest machine via guest agent
     */
    async v1alpha3FilesystemlistRaw(requestParameters: V1alpha3FilesystemlistRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceFileSystemList>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3Filesystemlist.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Filesystemlist.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/filesystemlist`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceFileSystemListFromJSON(jsonValue));
    }

    /**
     * Get list of active filesystems on guest machine via guest agent
     */
    async v1alpha3Filesystemlist(requestParameters: V1alpha3FilesystemlistRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceFileSystemList> {
        const response = await this.v1alpha3FilesystemlistRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Freeze a VirtualMachineInstance object.
     */
    async v1alpha3FreezeRaw(requestParameters: V1alpha3FreezeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3Freeze.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Freeze.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1alpha3Freeze.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/freeze`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1FreezeUnfreezeTimeoutToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Freeze a VirtualMachineInstance object.
     */
    async v1alpha3Freeze(requestParameters: V1alpha3FreezeRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3FreezeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async v1alpha3GuestfsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/guestfs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async v1alpha3Guestfs(initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3GuestfsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get guest agent os information
     */
    async v1alpha3GuestosinfoRaw(requestParameters: V1alpha3GuestosinfoRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceGuestAgentInfo>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3Guestosinfo.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Guestosinfo.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/guestosinfo`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceGuestAgentInfoFromJSON(jsonValue));
    }

    /**
     * Get guest agent os information
     */
    async v1alpha3Guestosinfo(requestParameters: V1alpha3GuestosinfoRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceGuestAgentInfo> {
        const response = await this.v1alpha3GuestosinfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Dumps a VirtualMachineInstance memory.
     */
    async v1alpha3MemoryDumpRaw(requestParameters: V1alpha3MemoryDumpRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3MemoryDump.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3MemoryDump.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1alpha3MemoryDump.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/memorydump`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1VirtualMachineMemoryDumpRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Dumps a VirtualMachineInstance memory.
     */
    async v1alpha3MemoryDump(requestParameters: V1alpha3MemoryDumpRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3MemoryDumpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Migrate a running VirtualMachine to another node.
     */
    async v1alpha3MigrateRaw(requestParameters: V1alpha3MigrateRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3Migrate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Migrate.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1alpha3Migrate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/migrate`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1MigrateOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Migrate a running VirtualMachine to another node.
     */
    async v1alpha3Migrate(requestParameters: V1alpha3MigrateRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3MigrateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pause a VirtualMachineInstance object.
     */
    async v1alpha3PauseRaw(requestParameters: V1alpha3PauseRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3Pause.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Pause.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1alpha3Pause.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/pause`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PauseOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Pause a VirtualMachineInstance object.
     */
    async v1alpha3Pause(requestParameters: V1alpha3PauseRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3PauseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove memory dump association.
     */
    async v1alpha3RemoveMemoryDumpRaw(requestParameters: V1alpha3RemoveMemoryDumpRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3RemoveMemoryDump.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3RemoveMemoryDump.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/removememorydump`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Remove memory dump association.
     */
    async v1alpha3RemoveMemoryDump(requestParameters: V1alpha3RemoveMemoryDumpRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3RemoveMemoryDumpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reset a VirtualMachineInstance object.
     */
    async v1alpha3ResetRaw(requestParameters: V1alpha3ResetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3Reset.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Reset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/reset`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Reset a VirtualMachineInstance object.
     */
    async v1alpha3Reset(requestParameters: V1alpha3ResetRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3ResetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restart a VirtualMachine object.
     */
    async v1alpha3RestartRaw(requestParameters: V1alpha3RestartRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3Restart.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Restart.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/restart`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1RestartOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Restart a VirtualMachine object.
     */
    async v1alpha3Restart(requestParameters: V1alpha3RestartRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3RestartRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch SEV certificate chain from the node where Virtual Machine is scheduled
     */
    async v1alpha3SEVFetchCertChainRaw(requestParameters: V1alpha3SEVFetchCertChainRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1SEVPlatformInfo>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3SEVFetchCertChain.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3SEVFetchCertChain.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/sev/fetchcertchain`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SEVPlatformInfoFromJSON(jsonValue));
    }

    /**
     * Fetch SEV certificate chain from the node where Virtual Machine is scheduled
     */
    async v1alpha3SEVFetchCertChain(requestParameters: V1alpha3SEVFetchCertChainRequest, initOverrides?: RequestInit): Promise<V1SEVPlatformInfo> {
        const response = await this.v1alpha3SEVFetchCertChainRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inject SEV launch secret into a Virtual Machine
     */
    async v1alpha3SEVInjectLaunchSecretRaw(requestParameters: V1alpha3SEVInjectLaunchSecretRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3SEVInjectLaunchSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3SEVInjectLaunchSecret.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1alpha3SEVInjectLaunchSecret.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/sev/injectlaunchsecret`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1SEVSecretOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Inject SEV launch secret into a Virtual Machine
     */
    async v1alpha3SEVInjectLaunchSecret(requestParameters: V1alpha3SEVInjectLaunchSecretRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3SEVInjectLaunchSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Query SEV launch measurement from a Virtual Machine
     */
    async v1alpha3SEVQueryLaunchMeasurementRaw(requestParameters: V1alpha3SEVQueryLaunchMeasurementRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1SEVMeasurementInfo>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3SEVQueryLaunchMeasurement.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3SEVQueryLaunchMeasurement.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/sev/querylaunchmeasurement`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SEVMeasurementInfoFromJSON(jsonValue));
    }

    /**
     * Query SEV launch measurement from a Virtual Machine
     */
    async v1alpha3SEVQueryLaunchMeasurement(requestParameters: V1alpha3SEVQueryLaunchMeasurementRequest, initOverrides?: RequestInit): Promise<V1SEVMeasurementInfo> {
        const response = await this.v1alpha3SEVQueryLaunchMeasurementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Setup SEV session parameters for a Virtual Machine
     */
    async v1alpha3SEVSetupSessionRaw(requestParameters: V1alpha3SEVSetupSessionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3SEVSetupSession.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3SEVSetupSession.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1alpha3SEVSetupSession.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/sev/setupsession`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1SEVSessionOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Setup SEV session parameters for a Virtual Machine
     */
    async v1alpha3SEVSetupSession(requestParameters: V1alpha3SEVSetupSessionRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3SEVSetupSessionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Soft reboot a VirtualMachineInstance object.
     */
    async v1alpha3SoftRebootRaw(requestParameters: V1alpha3SoftRebootRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3SoftReboot.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3SoftReboot.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/softreboot`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Soft reboot a VirtualMachineInstance object.
     */
    async v1alpha3SoftReboot(requestParameters: V1alpha3SoftRebootRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3SoftRebootRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Start a VirtualMachine object.
     */
    async v1alpha3StartRaw(requestParameters: V1alpha3StartRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3Start.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Start.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1alpha3Start.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/start`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1StartOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Start a VirtualMachine object.
     */
    async v1alpha3Start(requestParameters: V1alpha3StartRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3StartRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stop a VirtualMachine object.
     */
    async v1alpha3StopRaw(requestParameters: V1alpha3StopRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3Stop.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Stop.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/stop`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1StopOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Stop a VirtualMachine object.
     */
    async v1alpha3Stop(requestParameters: V1alpha3StopRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3StopRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unfreeze a VirtualMachineInstance object.
     */
    async v1alpha3UnfreezeRaw(requestParameters: V1alpha3UnfreezeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3Unfreeze.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Unfreeze.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/unfreeze`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Unfreeze a VirtualMachineInstance object.
     */
    async v1alpha3Unfreeze(requestParameters: V1alpha3UnfreezeRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3UnfreezeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unpause a VirtualMachineInstance object.
     */
    async v1alpha3UnpauseRaw(requestParameters: V1alpha3UnpauseRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3Unpause.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Unpause.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1alpha3Unpause.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/unpause`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1UnpauseOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Unpause a VirtualMachineInstance object.
     */
    async v1alpha3Unpause(requestParameters: V1alpha3UnpauseRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3UnpauseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of active users via guest agent
     */
    async v1alpha3UserlistRaw(requestParameters: V1alpha3UserlistRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<V1VirtualMachineInstanceGuestOSUserList>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3Userlist.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3Userlist.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/userlist`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VirtualMachineInstanceGuestOSUserListFromJSON(jsonValue));
    }

    /**
     * Get list of active users via guest agent
     */
    async v1alpha3Userlist(requestParameters: V1alpha3UserlistRequest, initOverrides?: RequestInit): Promise<V1VirtualMachineInstanceGuestOSUserList> {
        const response = await this.v1alpha3UserlistRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Open a websocket connection to connect to VNC on the specified VirtualMachineInstance.
     */
    async v1alpha3VNCRaw(requestParameters: V1alpha3VNCRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3VNC.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3VNC.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/vnc`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection to connect to VNC on the specified VirtualMachineInstance.
     */
    async v1alpha3VNC(requestParameters: V1alpha3VNCRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1alpha3VNCRaw(requestParameters, initOverrides);
    }

    /**
     * Get a PNG VNC screenshot of the specified VirtualMachineInstance.
     */
    async v1alpha3VNCScreenshotRaw(requestParameters: V1alpha3VNCScreenshotRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3VNCScreenshot.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3VNCScreenshot.');
        }

        const queryParameters: any = {};

        if (requestParameters.moveCursor !== undefined) {
            queryParameters['moveCursor'] = requestParameters.moveCursor;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/vnc/screenshot`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get a PNG VNC screenshot of the specified VirtualMachineInstance.
     */
    async v1alpha3VNCScreenshot(requestParameters: V1alpha3VNCScreenshotRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1alpha3VNCScreenshotRaw(requestParameters, initOverrides);
    }

    /**
     * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port via VSOCK.
     */
    async v1alpha3VSOCKRaw(requestParameters: V1alpha3VSOCKRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3VSOCK.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3VSOCK.');
        }

        if (requestParameters.port === null || requestParameters.port === undefined) {
            throw new runtime.RequiredError('port','Required parameter requestParameters.port was null or undefined when calling v1alpha3VSOCK.');
        }

        const queryParameters: any = {};

        if (requestParameters.port !== undefined) {
            queryParameters['port'] = requestParameters.port;
        }

        if (requestParameters.tls !== undefined) {
            queryParameters['tls'] = requestParameters.tls;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/vsock`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port via VSOCK.
     */
    async v1alpha3VSOCK(requestParameters: V1alpha3VSOCKRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1alpha3VSOCKRaw(requestParameters, initOverrides);
    }

    /**
     */
    async v1alpha3VersionRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/version`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async v1alpha3Version(initOverrides?: RequestInit): Promise<void> {
        await this.v1alpha3VersionRaw(initOverrides);
    }

    /**
     */
    async v1alpha3dumpClusterProfilerRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/dump-cluster-profiler`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async v1alpha3dumpClusterProfiler(initOverrides?: RequestInit): Promise<void> {
        await this.v1alpha3dumpClusterProfilerRaw(initOverrides);
    }

    /**
     * Get a KubeVirt API resources
     */
    async v1alpha3getAPISubResourcesRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue));
    }

    /**
     * Get a KubeVirt API resources
     */
    async v1alpha3getAPISubResources(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
        const response = await this.v1alpha3getAPISubResourcesRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async v1alpha3startClusterProfilerRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/start-cluster-profiler`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async v1alpha3startClusterProfiler(initOverrides?: RequestInit): Promise<void> {
        await this.v1alpha3startClusterProfilerRaw(initOverrides);
    }

    /**
     */
    async v1alpha3stopClusterProfilerRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/stop-cluster-profiler`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async v1alpha3stopClusterProfiler(initOverrides?: RequestInit): Promise<void> {
        await this.v1alpha3stopClusterProfilerRaw(initOverrides);
    }

    /**
     * Open a websocket connection to connect to USB device on the specified VirtualMachineInstance.
     */
    async v1alpha3usbredirRaw(requestParameters: V1alpha3usbredirRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3usbredir.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3usbredir.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/usbredir`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection to connect to USB device on the specified VirtualMachineInstance.
     */
    async v1alpha3usbredir(requestParameters: V1alpha3usbredirRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1alpha3usbredirRaw(requestParameters, initOverrides);
    }

    /**
     * Add a volume and disk to a running Virtual Machine.
     */
    async v1alpha3vmAddvolumeRaw(requestParameters: V1alpha3vmAddvolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3vmAddvolume.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmAddvolume.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1alpha3vmAddvolume.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/addvolume`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1AddVolumeOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Add a volume and disk to a running Virtual Machine.
     */
    async v1alpha3vmAddvolume(requestParameters: V1alpha3vmAddvolumeRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3vmAddvolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get VirtualMachine object with expanded instancetype and preference.
     */
    async v1alpha3vmExpandSpecRaw(requestParameters: V1alpha3vmExpandSpecRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3vmExpandSpec.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmExpandSpec.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/expand-spec`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get VirtualMachine object with expanded instancetype and preference.
     */
    async v1alpha3vmExpandSpec(requestParameters: V1alpha3vmExpandSpecRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3vmExpandSpecRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Open a websocket connection forwarding traffic to the running VMI for the specified VirtualMachine and port.
     */
    async v1alpha3vmPortForwardRaw(requestParameters: V1alpha3vmPortForwardRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3vmPortForward.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmPortForward.');
        }

        if (requestParameters.port === null || requestParameters.port === undefined) {
            throw new runtime.RequiredError('port','Required parameter requestParameters.port was null or undefined when calling v1alpha3vmPortForward.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/portforward/{port}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"port"}}`, encodeURIComponent(String(requestParameters.port))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection forwarding traffic to the running VMI for the specified VirtualMachine and port.
     */
    async v1alpha3vmPortForward(requestParameters: V1alpha3vmPortForwardRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1alpha3vmPortForwardRaw(requestParameters, initOverrides);
    }

    /**
     * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachine and port.
     */
    async v1alpha3vmPortForwardWithProtocolRaw(requestParameters: V1alpha3vmPortForwardWithProtocolRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3vmPortForwardWithProtocol.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmPortForwardWithProtocol.');
        }

        if (requestParameters.port === null || requestParameters.port === undefined) {
            throw new runtime.RequiredError('port','Required parameter requestParameters.port was null or undefined when calling v1alpha3vmPortForwardWithProtocol.');
        }

        if (requestParameters.protocol === null || requestParameters.protocol === undefined) {
            throw new runtime.RequiredError('protocol','Required parameter requestParameters.protocol was null or undefined when calling v1alpha3vmPortForwardWithProtocol.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/portforward/{port}/{protocol}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"port"}}`, encodeURIComponent(String(requestParameters.port))).replace(`{${"protocol"}}`, encodeURIComponent(String(requestParameters.protocol))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachine and port.
     */
    async v1alpha3vmPortForwardWithProtocol(requestParameters: V1alpha3vmPortForwardWithProtocolRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1alpha3vmPortForwardWithProtocolRaw(requestParameters, initOverrides);
    }

    /**
     * Removes a volume and disk from a running Virtual Machine.
     */
    async v1alpha3vmRemovevolumeRaw(requestParameters: V1alpha3vmRemovevolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3vmRemovevolume.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmRemovevolume.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1alpha3vmRemovevolume.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/removevolume`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1RemoveVolumeOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Removes a volume and disk from a running Virtual Machine.
     */
    async v1alpha3vmRemovevolume(requestParameters: V1alpha3vmRemovevolumeRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3vmRemovevolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a volume and disk to a running Virtual Machine Instance
     */
    async v1alpha3vmiAddvolumeRaw(requestParameters: V1alpha3vmiAddvolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3vmiAddvolume.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmiAddvolume.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1alpha3vmiAddvolume.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/addvolume`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1AddVolumeOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Add a volume and disk to a running Virtual Machine Instance
     */
    async v1alpha3vmiAddvolume(requestParameters: V1alpha3vmiAddvolumeRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3vmiAddvolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port.
     */
    async v1alpha3vmiPortForwardRaw(requestParameters: V1alpha3vmiPortForwardRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3vmiPortForward.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmiPortForward.');
        }

        if (requestParameters.port === null || requestParameters.port === undefined) {
            throw new runtime.RequiredError('port','Required parameter requestParameters.port was null or undefined when calling v1alpha3vmiPortForward.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/portforward/{port}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"port"}}`, encodeURIComponent(String(requestParameters.port))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port.
     */
    async v1alpha3vmiPortForward(requestParameters: V1alpha3vmiPortForwardRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1alpha3vmiPortForwardRaw(requestParameters, initOverrides);
    }

    /**
     * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachineInstance and port.
     */
    async v1alpha3vmiPortForwardWithProtocolRaw(requestParameters: V1alpha3vmiPortForwardWithProtocolRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3vmiPortForwardWithProtocol.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmiPortForwardWithProtocol.');
        }

        if (requestParameters.port === null || requestParameters.port === undefined) {
            throw new runtime.RequiredError('port','Required parameter requestParameters.port was null or undefined when calling v1alpha3vmiPortForwardWithProtocol.');
        }

        if (requestParameters.protocol === null || requestParameters.protocol === undefined) {
            throw new runtime.RequiredError('protocol','Required parameter requestParameters.protocol was null or undefined when calling v1alpha3vmiPortForwardWithProtocol.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/portforward/{port}/{protocol}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"port"}}`, encodeURIComponent(String(requestParameters.port))).replace(`{${"protocol"}}`, encodeURIComponent(String(requestParameters.protocol))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachineInstance and port.
     */
    async v1alpha3vmiPortForwardWithProtocol(requestParameters: V1alpha3vmiPortForwardWithProtocolRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1alpha3vmiPortForwardWithProtocolRaw(requestParameters, initOverrides);
    }

    /**
     * Removes a volume and disk from a running Virtual Machine Instance
     */
    async v1alpha3vmiRemovevolumeRaw(requestParameters: V1alpha3vmiRemovevolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1alpha3vmiRemovevolume.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1alpha3vmiRemovevolume.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1alpha3vmiRemovevolume.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/removevolume`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1RemoveVolumeOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Removes a volume and disk from a running Virtual Machine Instance
     */
    async v1alpha3vmiRemovevolume(requestParameters: V1alpha3vmiRemovevolumeRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1alpha3vmiRemovevolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async v1dumpClusterProfilerRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/dump-cluster-profiler`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async v1dumpClusterProfiler(initOverrides?: RequestInit): Promise<void> {
        await this.v1dumpClusterProfilerRaw(initOverrides);
    }

    /**
     * Get a KubeVirt API resources
     */
    async v1getAPISubResourcesRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1APIResourceList>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue));
    }

    /**
     * Get a KubeVirt API resources
     */
    async v1getAPISubResources(initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1APIResourceList> {
        const response = await this.v1getAPISubResourcesRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async v1startClusterProfilerRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/start-cluster-profiler`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async v1startClusterProfiler(initOverrides?: RequestInit): Promise<void> {
        await this.v1startClusterProfilerRaw(initOverrides);
    }

    /**
     */
    async v1stopClusterProfilerRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/stop-cluster-profiler`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async v1stopClusterProfiler(initOverrides?: RequestInit): Promise<void> {
        await this.v1stopClusterProfilerRaw(initOverrides);
    }

    /**
     * Open a websocket connection to connect to USB device on the specified VirtualMachineInstance.
     */
    async v1usbredirRaw(requestParameters: V1usbredirRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1usbredir.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1usbredir.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/usbredir`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection to connect to USB device on the specified VirtualMachineInstance.
     */
    async v1usbredir(requestParameters: V1usbredirRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1usbredirRaw(requestParameters, initOverrides);
    }

    /**
     * Add a volume and disk to a running Virtual Machine.
     */
    async v1vmAddvolumeRaw(requestParameters: V1vmAddvolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1vmAddvolume.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1vmAddvolume.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1vmAddvolume.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/addvolume`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1AddVolumeOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Add a volume and disk to a running Virtual Machine.
     */
    async v1vmAddvolume(requestParameters: V1vmAddvolumeRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1vmAddvolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get VirtualMachine object with expanded instancetype and preference.
     */
    async v1vmExpandSpecRaw(requestParameters: V1vmExpandSpecRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1vmExpandSpec.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1vmExpandSpec.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/expand-spec`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get VirtualMachine object with expanded instancetype and preference.
     */
    async v1vmExpandSpec(requestParameters: V1vmExpandSpecRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1vmExpandSpecRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Open a websocket connection forwarding traffic to the running VMI for the specified VirtualMachine and port.
     */
    async v1vmPortForwardRaw(requestParameters: V1vmPortForwardRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1vmPortForward.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1vmPortForward.');
        }

        if (requestParameters.port === null || requestParameters.port === undefined) {
            throw new runtime.RequiredError('port','Required parameter requestParameters.port was null or undefined when calling v1vmPortForward.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/portforward/{port}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"port"}}`, encodeURIComponent(String(requestParameters.port))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection forwarding traffic to the running VMI for the specified VirtualMachine and port.
     */
    async v1vmPortForward(requestParameters: V1vmPortForwardRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1vmPortForwardRaw(requestParameters, initOverrides);
    }

    /**
     * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachine and port.
     */
    async v1vmPortForwardWithProtocolRaw(requestParameters: V1vmPortForwardWithProtocolRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1vmPortForwardWithProtocol.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1vmPortForwardWithProtocol.');
        }

        if (requestParameters.port === null || requestParameters.port === undefined) {
            throw new runtime.RequiredError('port','Required parameter requestParameters.port was null or undefined when calling v1vmPortForwardWithProtocol.');
        }

        if (requestParameters.protocol === null || requestParameters.protocol === undefined) {
            throw new runtime.RequiredError('protocol','Required parameter requestParameters.protocol was null or undefined when calling v1vmPortForwardWithProtocol.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/portforward/{port}/{protocol}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"port"}}`, encodeURIComponent(String(requestParameters.port))).replace(`{${"protocol"}}`, encodeURIComponent(String(requestParameters.protocol))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachine and port.
     */
    async v1vmPortForwardWithProtocol(requestParameters: V1vmPortForwardWithProtocolRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1vmPortForwardWithProtocolRaw(requestParameters, initOverrides);
    }

    /**
     * Removes a volume and disk from a running Virtual Machine.
     */
    async v1vmRemovevolumeRaw(requestParameters: V1vmRemovevolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1vmRemovevolume.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1vmRemovevolume.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1vmRemovevolume.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/removevolume`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1RemoveVolumeOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Removes a volume and disk from a running Virtual Machine.
     */
    async v1vmRemovevolume(requestParameters: V1vmRemovevolumeRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1vmRemovevolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a volume and disk to a running Virtual Machine Instance
     */
    async v1vmiAddvolumeRaw(requestParameters: V1vmiAddvolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1vmiAddvolume.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1vmiAddvolume.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1vmiAddvolume.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/addvolume`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1AddVolumeOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Add a volume and disk to a running Virtual Machine Instance
     */
    async v1vmiAddvolume(requestParameters: V1vmiAddvolumeRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1vmiAddvolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port.
     */
    async v1vmiPortForwardRaw(requestParameters: V1vmiPortForwardRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1vmiPortForward.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1vmiPortForward.');
        }

        if (requestParameters.port === null || requestParameters.port === undefined) {
            throw new runtime.RequiredError('port','Required parameter requestParameters.port was null or undefined when calling v1vmiPortForward.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/portforward/{port}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"port"}}`, encodeURIComponent(String(requestParameters.port))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port.
     */
    async v1vmiPortForward(requestParameters: V1vmiPortForwardRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1vmiPortForwardRaw(requestParameters, initOverrides);
    }

    /**
     * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachineInstance and port.
     */
    async v1vmiPortForwardWithProtocolRaw(requestParameters: V1vmiPortForwardWithProtocolRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1vmiPortForwardWithProtocol.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1vmiPortForwardWithProtocol.');
        }

        if (requestParameters.port === null || requestParameters.port === undefined) {
            throw new runtime.RequiredError('port','Required parameter requestParameters.port was null or undefined when calling v1vmiPortForwardWithProtocol.');
        }

        if (requestParameters.protocol === null || requestParameters.protocol === undefined) {
            throw new runtime.RequiredError('protocol','Required parameter requestParameters.protocol was null or undefined when calling v1vmiPortForwardWithProtocol.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/portforward/{port}/{protocol}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"port"}}`, encodeURIComponent(String(requestParameters.port))).replace(`{${"protocol"}}`, encodeURIComponent(String(requestParameters.protocol))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachineInstance and port.
     */
    async v1vmiPortForwardWithProtocol(requestParameters: V1vmiPortForwardWithProtocolRequest, initOverrides?: RequestInit): Promise<void> {
        await this.v1vmiPortForwardWithProtocolRaw(requestParameters, initOverrides);
    }

    /**
     * Removes a volume and disk from a running Virtual Machine Instance
     */
    async v1vmiRemovevolumeRaw(requestParameters: V1vmiRemovevolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling v1vmiRemovevolume.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling v1vmiRemovevolume.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling v1vmiRemovevolume.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/removevolume`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1RemoveVolumeOptionsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Removes a volume and disk from a running Virtual Machine Instance
     */
    async v1vmiRemovevolume(requestParameters: V1vmiRemovevolumeRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.v1vmiRemovevolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a KubeVirtList object.
     */
    async watchKubeVirtListForAllNamespacesRaw(requestParameters: WatchKubeVirtListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/watch/kubevirt`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a KubeVirtList object.
     */
    async watchKubeVirtListForAllNamespaces(requestParameters: WatchKubeVirtListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchKubeVirtListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a MigrationPolicyList object.
     */
    async watchMigrationPolicyListForAllNamespacesRaw(requestParameters: WatchMigrationPolicyListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/migrations.kubevirt.io/v1alpha1/watch/migrationpolicies`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a MigrationPolicyList object.
     */
    async watchMigrationPolicyListForAllNamespaces(requestParameters: WatchMigrationPolicyListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchMigrationPolicyListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a KubeVirt object.
     */
    async watchNamespacedKubeVirtRaw(requestParameters: WatchNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedKubeVirt.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/watch/namespaces/{namespace}/kubevirt`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a KubeVirt object.
     */
    async watchNamespacedKubeVirt(requestParameters: WatchNamespacedKubeVirtRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchNamespacedKubeVirtRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachine object.
     */
    async watchNamespacedVirtualMachineRaw(requestParameters: WatchNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachine.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/watch/namespaces/{namespace}/virtualmachines`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachine object.
     */
    async watchNamespacedVirtualMachine(requestParameters: WatchNamespacedVirtualMachineRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchNamespacedVirtualMachineRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineExport object.
     */
    async watchNamespacedVirtualMachineExportRaw(requestParameters: WatchNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineExport.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/export.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachineexports`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineExport object.
     */
    async watchNamespacedVirtualMachineExport(requestParameters: WatchNamespacedVirtualMachineExportRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchNamespacedVirtualMachineExportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineInstance object.
     */
    async watchNamespacedVirtualMachineInstanceRaw(requestParameters: WatchNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineInstance.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/watch/namespaces/{namespace}/virtualmachineinstances`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineInstance object.
     */
    async watchNamespacedVirtualMachineInstance(requestParameters: WatchNamespacedVirtualMachineInstanceRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchNamespacedVirtualMachineInstanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineInstanceMigration object.
     */
    async watchNamespacedVirtualMachineInstanceMigrationRaw(requestParameters: WatchNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineInstanceMigration.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/watch/namespaces/{namespace}/virtualmachineinstancemigrations`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineInstanceMigration object.
     */
    async watchNamespacedVirtualMachineInstanceMigration(requestParameters: WatchNamespacedVirtualMachineInstanceMigrationRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchNamespacedVirtualMachineInstanceMigrationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineInstancePreset object.
     */
    async watchNamespacedVirtualMachineInstancePresetRaw(requestParameters: WatchNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineInstancePreset.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/watch/namespaces/{namespace}/virtualmachineinstancepresets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineInstancePreset object.
     */
    async watchNamespacedVirtualMachineInstancePreset(requestParameters: WatchNamespacedVirtualMachineInstancePresetRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchNamespacedVirtualMachineInstancePresetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineInstanceReplicaSet object.
     */
    async watchNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters: WatchNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineInstanceReplicaSet.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/watch/namespaces/{namespace}/virtualmachineinstancereplicasets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineInstanceReplicaSet object.
     */
    async watchNamespacedVirtualMachineInstanceReplicaSet(requestParameters: WatchNamespacedVirtualMachineInstanceReplicaSetRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchNamespacedVirtualMachineInstanceReplicaSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineInstancetype object.
     */
    async watchNamespacedVirtualMachineInstancetypeRaw(requestParameters: WatchNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineInstancetype.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachineinstancetypes`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineInstancetype object.
     */
    async watchNamespacedVirtualMachineInstancetype(requestParameters: WatchNamespacedVirtualMachineInstancetypeRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchNamespacedVirtualMachineInstancetypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachinePool object.
     */
    async watchNamespacedVirtualMachinePoolRaw(requestParameters: WatchNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachinePool.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/pool.kubevirt.io/v1alpha1/watch/namespaces/{namespace}/virtualmachinepools`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachinePool object.
     */
    async watchNamespacedVirtualMachinePool(requestParameters: WatchNamespacedVirtualMachinePoolRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchNamespacedVirtualMachinePoolRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachinePreference object.
     */
    async watchNamespacedVirtualMachinePreferenceRaw(requestParameters: WatchNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachinePreference.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachinepreferences`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachinePreference object.
     */
    async watchNamespacedVirtualMachinePreference(requestParameters: WatchNamespacedVirtualMachinePreferenceRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchNamespacedVirtualMachinePreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineRestore object.
     */
    async watchNamespacedVirtualMachineRestoreRaw(requestParameters: WatchNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineRestore.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachinerestores`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineRestore object.
     */
    async watchNamespacedVirtualMachineRestore(requestParameters: WatchNamespacedVirtualMachineRestoreRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchNamespacedVirtualMachineRestoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineSnapshot object.
     */
    async watchNamespacedVirtualMachineSnapshotRaw(requestParameters: WatchNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineSnapshot.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachinesnapshots`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineSnapshot object.
     */
    async watchNamespacedVirtualMachineSnapshot(requestParameters: WatchNamespacedVirtualMachineSnapshotRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchNamespacedVirtualMachineSnapshotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineSnapshotContent object.
     */
    async watchNamespacedVirtualMachineSnapshotContentRaw(requestParameters: WatchNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchNamespacedVirtualMachineSnapshotContent.');
        }

        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachinesnapshotcontents`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineSnapshotContent object.
     */
    async watchNamespacedVirtualMachineSnapshotContent(requestParameters: WatchNamespacedVirtualMachineSnapshotContentRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchNamespacedVirtualMachineSnapshotContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineCloneList object.
     */
    async watchVirtualMachineCloneListForAllNamespacesRaw(requestParameters: WatchVirtualMachineCloneListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/clone.kubevirt.io/v1beta1/watch/virtualmachineclones`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineCloneList object.
     */
    async watchVirtualMachineCloneListForAllNamespaces(requestParameters: WatchVirtualMachineCloneListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchVirtualMachineCloneListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineClusterInstancetypeList object.
     */
    async watchVirtualMachineClusterInstancetypeListForAllNamespacesRaw(requestParameters: WatchVirtualMachineClusterInstancetypeListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/watch/virtualmachineclusterinstancetypes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineClusterInstancetypeList object.
     */
    async watchVirtualMachineClusterInstancetypeListForAllNamespaces(requestParameters: WatchVirtualMachineClusterInstancetypeListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchVirtualMachineClusterInstancetypeListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineClusterPreferenceList object.
     */
    async watchVirtualMachineClusterPreferenceListForAllNamespacesRaw(requestParameters: WatchVirtualMachineClusterPreferenceListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/watch/virtualmachineclusterpreferences`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineClusterPreferenceList object.
     */
    async watchVirtualMachineClusterPreferenceListForAllNamespaces(requestParameters: WatchVirtualMachineClusterPreferenceListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchVirtualMachineClusterPreferenceListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineExportList object.
     */
    async watchVirtualMachineExportListForAllNamespacesRaw(requestParameters: WatchVirtualMachineExportListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/export.kubevirt.io/v1beta1/watch/virtualmachineexports`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineExportList object.
     */
    async watchVirtualMachineExportListForAllNamespaces(requestParameters: WatchVirtualMachineExportListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchVirtualMachineExportListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineInstanceList object.
     */
    async watchVirtualMachineInstanceListForAllNamespacesRaw(requestParameters: WatchVirtualMachineInstanceListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/watch/virtualmachineinstances`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineInstanceList object.
     */
    async watchVirtualMachineInstanceListForAllNamespaces(requestParameters: WatchVirtualMachineInstanceListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchVirtualMachineInstanceListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineInstanceMigrationList object.
     */
    async watchVirtualMachineInstanceMigrationListForAllNamespacesRaw(requestParameters: WatchVirtualMachineInstanceMigrationListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/watch/virtualmachineinstancemigrations`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineInstanceMigrationList object.
     */
    async watchVirtualMachineInstanceMigrationListForAllNamespaces(requestParameters: WatchVirtualMachineInstanceMigrationListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchVirtualMachineInstanceMigrationListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineInstancePresetList object.
     */
    async watchVirtualMachineInstancePresetListForAllNamespacesRaw(requestParameters: WatchVirtualMachineInstancePresetListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/watch/virtualmachineinstancepresets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineInstancePresetList object.
     */
    async watchVirtualMachineInstancePresetListForAllNamespaces(requestParameters: WatchVirtualMachineInstancePresetListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchVirtualMachineInstancePresetListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineInstanceReplicaSetList object.
     */
    async watchVirtualMachineInstanceReplicaSetListForAllNamespacesRaw(requestParameters: WatchVirtualMachineInstanceReplicaSetListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/watch/virtualmachineinstancereplicasets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineInstanceReplicaSetList object.
     */
    async watchVirtualMachineInstanceReplicaSetListForAllNamespaces(requestParameters: WatchVirtualMachineInstanceReplicaSetListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchVirtualMachineInstanceReplicaSetListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineInstancetypeList object.
     */
    async watchVirtualMachineInstancetypeListForAllNamespacesRaw(requestParameters: WatchVirtualMachineInstancetypeListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/watch/virtualmachineinstancetypes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineInstancetypeList object.
     */
    async watchVirtualMachineInstancetypeListForAllNamespaces(requestParameters: WatchVirtualMachineInstancetypeListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchVirtualMachineInstancetypeListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineList object.
     */
    async watchVirtualMachineListForAllNamespacesRaw(requestParameters: WatchVirtualMachineListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/kubevirt.io/v1/watch/virtualmachines`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineList object.
     */
    async watchVirtualMachineListForAllNamespaces(requestParameters: WatchVirtualMachineListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchVirtualMachineListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachinePoolList object.
     */
    async watchVirtualMachinePoolListForAllNamespacesRaw(requestParameters: WatchVirtualMachinePoolListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/pool.kubevirt.io/v1alpha1/watch/virtualmachinepools`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachinePoolList object.
     */
    async watchVirtualMachinePoolListForAllNamespaces(requestParameters: WatchVirtualMachinePoolListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchVirtualMachinePoolListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachinePreferenceList object.
     */
    async watchVirtualMachinePreferenceListForAllNamespacesRaw(requestParameters: WatchVirtualMachinePreferenceListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/instancetype.kubevirt.io/v1beta1/watch/virtualmachinepreferences`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachinePreferenceList object.
     */
    async watchVirtualMachinePreferenceListForAllNamespaces(requestParameters: WatchVirtualMachinePreferenceListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchVirtualMachinePreferenceListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineRestoreList object.
     */
    async watchVirtualMachineRestoreListForAllNamespacesRaw(requestParameters: WatchVirtualMachineRestoreListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/watch/virtualmachinerestores`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineRestoreList object.
     */
    async watchVirtualMachineRestoreListForAllNamespaces(requestParameters: WatchVirtualMachineRestoreListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchVirtualMachineRestoreListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineSnapshotContentList object.
     */
    async watchVirtualMachineSnapshotContentListForAllNamespacesRaw(requestParameters: WatchVirtualMachineSnapshotContentListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/watch/virtualmachinesnapshotcontents`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineSnapshotContentList object.
     */
    async watchVirtualMachineSnapshotContentListForAllNamespaces(requestParameters: WatchVirtualMachineSnapshotContentListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchVirtualMachineSnapshotContentListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch a VirtualMachineSnapshotList object.
     */
    async watchVirtualMachineSnapshotListForAllNamespacesRaw(requestParameters: WatchVirtualMachineSnapshotListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<K8sIoApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: any = {};

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = requestParameters.includeUninitialized;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/snapshot.kubevirt.io/v1beta1/watch/virtualmachinesnapshots`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => K8sIoApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * Watch a VirtualMachineSnapshotList object.
     */
    async watchVirtualMachineSnapshotListForAllNamespaces(requestParameters: WatchVirtualMachineSnapshotListForAllNamespacesRequest, initOverrides?: RequestInit): Promise<K8sIoApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchVirtualMachineSnapshotListForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
